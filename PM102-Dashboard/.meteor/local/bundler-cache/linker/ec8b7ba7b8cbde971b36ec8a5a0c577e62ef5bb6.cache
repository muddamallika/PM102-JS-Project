[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar NpmModuleBcrypt = Package['npm-bcrypt'].NpmModuleBcrypt;\nvar Accounts = Package['accounts-base'].Accounts;\nvar SRP = Package.srp.SRP;\nvar SHA256 = Package.sha.SHA256;\nvar EJSON = Package.ejson.EJSON;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar Email = Package.email.Email;\nvar EmailInternals = Package.email.EmailInternals;\nvar Random = Package.random.Random;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar _ = Package.underscore._;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar Symbol = Package['ecmascript-runtime'].Symbol;\nvar Map = Package['ecmascript-runtime'].Map;\nvar Set = Package['ecmascript-runtime'].Set;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"accounts-password\":{\"email_templates.js\":function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/accounts-password/email_templates.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nfunction greet(welcomeMsg) {                                                                                           // 1\n  return function (user, url) {                                                                                        // 2\n    var greeting = user.profile && user.profile.name ? \"Hello \" + user.profile.name + \",\" : \"Hello,\";                  // 3\n    return greeting + \"\\n\\n\" + welcomeMsg + \", simply click the link below.\\n\\n\" + url + \"\\n\\nThanks.\\n\";              // 5\n  };                                                                                                                   // 13\n}                                                                                                                      // 14\n                                                                                                                       //\n/**                                                                                                                    // 16\n * @summary Options to customize emails sent from the Accounts system.                                                 //\n * @locus Server                                                                                                       //\n * @importFromPackage accounts-base                                                                                    //\n */                                                                                                                    //\nAccounts.emailTemplates = {                                                                                            // 21\n  from: \"Meteor Accounts <no-reply@meteor.com>\",                                                                       // 22\n  siteName: Meteor.absoluteUrl().replace(/^https?:\\/\\//, '').replace(/\\/$/, ''),                                       // 23\n                                                                                                                       //\n  resetPassword: {                                                                                                     // 25\n    subject: function () {                                                                                             // 26\n      function subject(user) {                                                                                         // 26\n        return \"How to reset your password on \" + Accounts.emailTemplates.siteName;                                    // 27\n      }                                                                                                                // 28\n                                                                                                                       //\n      return subject;                                                                                                  // 26\n    }(),                                                                                                               // 26\n    text: function () {                                                                                                // 29\n      function text(user, url) {                                                                                       // 29\n        var greeting = user.profile && user.profile.name ? \"Hello \" + user.profile.name + \",\" : \"Hello,\";              // 30\n        return greeting + \"\\n\\nTo reset your password, simply click the link below.\\n\\n\" + url + \"\\n\\nThanks.\\n\";      // 32\n      }                                                                                                                // 40\n                                                                                                                       //\n      return text;                                                                                                     // 29\n    }()                                                                                                                // 29\n  },                                                                                                                   // 25\n  verifyEmail: {                                                                                                       // 42\n    subject: function () {                                                                                             // 43\n      function subject(user) {                                                                                         // 43\n        return \"How to verify email address on \" + Accounts.emailTemplates.siteName;                                   // 44\n      }                                                                                                                // 45\n                                                                                                                       //\n      return subject;                                                                                                  // 43\n    }(),                                                                                                               // 43\n    text: greet(\"To verify your account email\")                                                                        // 46\n  },                                                                                                                   // 42\n  enrollAccount: {                                                                                                     // 48\n    subject: function () {                                                                                             // 49\n      function subject(user) {                                                                                         // 49\n        return \"An account has been created for you on \" + Accounts.emailTemplates.siteName;                           // 50\n      }                                                                                                                // 51\n                                                                                                                       //\n      return subject;                                                                                                  // 49\n    }(),                                                                                                               // 49\n    text: greet(\"To start using the service\")                                                                          // 52\n  }                                                                                                                    // 48\n};                                                                                                                     // 21\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"password_server.js\":[\"babel-runtime/helpers/typeof\",function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/accounts-password/password_server.js                                                                       //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nvar _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});                          //\n/// BCRYPT                                                                                                             // 1\n                                                                                                                       //\nvar bcrypt = NpmModuleBcrypt;                                                                                          // 3\nvar bcryptHash = Meteor.wrapAsync(bcrypt.hash);                                                                        // 4\nvar bcryptCompare = Meteor.wrapAsync(bcrypt.compare);                                                                  // 5\n                                                                                                                       //\n// User records have a 'services.password.bcrypt' field on them to hold                                                // 7\n// their hashed passwords (unless they have a 'services.password.srp'                                                  // 8\n// field, in which case they will be upgraded to bcrypt the next time                                                  // 9\n// they log in).                                                                                                       // 10\n//                                                                                                                     // 11\n// When the client sends a password to the server, it can either be a                                                  // 12\n// string (the plaintext password) or an object with keys 'digest' and                                                 // 13\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends                                             // 14\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients                                               // 15\n// that don't have access to SHA can just send plaintext passwords as                                                  // 16\n// strings.                                                                                                            // 17\n//                                                                                                                     // 18\n// When the server receives a plaintext password as a string, it always                                                // 19\n// hashes it with SHA256 before passing it into bcrypt. When the server                                                // 20\n// receives a password as an object, it asserts that the algorithm is                                                  // 21\n// \"sha-256\" and then passes the digest to bcrypt.                                                                     // 22\n                                                                                                                       //\n                                                                                                                       //\nAccounts._bcryptRounds = 10;                                                                                           // 25\n                                                                                                                       //\n// Given a 'password' from the client, extract the string that we should                                               // 27\n// bcrypt. 'password' can be one of:                                                                                   // 28\n//  - String (the plaintext password)                                                                                  // 29\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".                                        // 30\n//                                                                                                                     // 31\nvar getPasswordString = function getPasswordString(password) {                                                         // 32\n  if (typeof password === \"string\") {                                                                                  // 33\n    password = SHA256(password);                                                                                       // 34\n  } else {                                                                                                             // 35\n    // 'password' is an object                                                                                         // 35\n    if (password.algorithm !== \"sha-256\") {                                                                            // 36\n      throw new Error(\"Invalid password hash algorithm. \" + \"Only 'sha-256' is allowed.\");                             // 37\n    }                                                                                                                  // 39\n    password = password.digest;                                                                                        // 40\n  }                                                                                                                    // 41\n  return password;                                                                                                     // 42\n};                                                                                                                     // 43\n                                                                                                                       //\n// Use bcrypt to hash the password for storage in the database.                                                        // 45\n// `password` can be a string (in which case it will be run through                                                    // 46\n// SHA256 before bcrypt) or an object with properties `digest` and                                                     // 47\n// `algorithm` (in which case we bcrypt `password.digest`).                                                            // 48\n//                                                                                                                     // 49\nvar hashPassword = function hashPassword(password) {                                                                   // 50\n  password = getPasswordString(password);                                                                              // 51\n  return bcryptHash(password, Accounts._bcryptRounds);                                                                 // 52\n};                                                                                                                     // 53\n                                                                                                                       //\n// Check whether the provided password matches the bcrypt'ed password in                                               // 55\n// the database user record. `password` can be a string (in which case                                                 // 56\n// it will be run through SHA256 before bcrypt) or an object with                                                      // 57\n// properties `digest` and `algorithm` (in which case we bcrypt                                                        // 58\n// `password.digest`).                                                                                                 // 59\n//                                                                                                                     // 60\nAccounts._checkPassword = function (user, password) {                                                                  // 61\n  var result = {                                                                                                       // 62\n    userId: user._id                                                                                                   // 63\n  };                                                                                                                   // 62\n                                                                                                                       //\n  password = getPasswordString(password);                                                                              // 66\n                                                                                                                       //\n  if (!bcryptCompare(password, user.services.password.bcrypt)) {                                                       // 68\n    result.error = new Meteor.Error(403, \"Incorrect password\");                                                        // 69\n  }                                                                                                                    // 70\n                                                                                                                       //\n  return result;                                                                                                       // 72\n};                                                                                                                     // 73\nvar checkPassword = Accounts._checkPassword;                                                                           // 74\n                                                                                                                       //\n///                                                                                                                    // 76\n/// LOGIN                                                                                                              // 77\n///                                                                                                                    // 78\n                                                                                                                       //\nAccounts._findUserByQuery = function (query) {                                                                         // 80\n  var user = null;                                                                                                     // 81\n                                                                                                                       //\n  if (query.id) {                                                                                                      // 83\n    user = Meteor.users.findOne({ _id: query.id });                                                                    // 84\n  } else {                                                                                                             // 85\n    var fieldName;                                                                                                     // 86\n    var fieldValue;                                                                                                    // 87\n    if (query.username) {                                                                                              // 88\n      fieldName = 'username';                                                                                          // 89\n      fieldValue = query.username;                                                                                     // 90\n    } else if (query.email) {                                                                                          // 91\n      fieldName = 'emails.address';                                                                                    // 92\n      fieldValue = query.email;                                                                                        // 93\n    } else {                                                                                                           // 94\n      throw new Error(\"shouldn't happen (validation missed something)\");                                               // 95\n    }                                                                                                                  // 96\n    var selector = {};                                                                                                 // 97\n    selector[fieldName] = fieldValue;                                                                                  // 98\n    user = Meteor.users.findOne(selector);                                                                             // 99\n    // If user is not found, try a case insensitive lookup                                                             // 100\n    if (!user) {                                                                                                       // 101\n      selector = selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);                                          // 102\n      var candidateUsers = Meteor.users.find(selector).fetch();                                                        // 103\n      // No match if multiple candidates are found                                                                     // 104\n      if (candidateUsers.length === 1) {                                                                               // 105\n        user = candidateUsers[0];                                                                                      // 106\n      }                                                                                                                // 107\n    }                                                                                                                  // 108\n  }                                                                                                                    // 109\n                                                                                                                       //\n  return user;                                                                                                         // 111\n};                                                                                                                     // 112\n                                                                                                                       //\n/**                                                                                                                    // 114\n * @summary Finds the user with the specified username.                                                                //\n * First tries to match username case sensitively; if that fails, it                                                   //\n * tries case insensitively; but if more than one user matches the case                                                //\n * insensitive search, it returns null.                                                                                //\n * @locus Server                                                                                                       //\n * @param {String} username The username to look for                                                                   //\n * @returns {Object} A user if found, else null                                                                        //\n * @importFromPackage accounts-base                                                                                    //\n */                                                                                                                    //\nAccounts.findUserByUsername = function (username) {                                                                    // 124\n  return Accounts._findUserByQuery({                                                                                   // 125\n    username: username                                                                                                 // 126\n  });                                                                                                                  // 125\n};                                                                                                                     // 128\n                                                                                                                       //\n/**                                                                                                                    // 130\n * @summary Finds the user with the specified email.                                                                   //\n * First tries to match email case sensitively; if that fails, it                                                      //\n * tries case insensitively; but if more than one user matches the case                                                //\n * insensitive search, it returns null.                                                                                //\n * @locus Server                                                                                                       //\n * @param {String} email The email address to look for                                                                 //\n * @returns {Object} A user if found, else null                                                                        //\n * @importFromPackage accounts-base                                                                                    //\n */                                                                                                                    //\nAccounts.findUserByEmail = function (email) {                                                                          // 140\n  return Accounts._findUserByQuery({                                                                                   // 141\n    email: email                                                                                                       // 142\n  });                                                                                                                  // 141\n};                                                                                                                     // 144\n                                                                                                                       //\n// Generates a MongoDB selector that can be used to perform a fast case                                                // 146\n// insensitive lookup for the given fieldName and string. Since MongoDB does                                           // 147\n// not support case insensitive indexes, and case insensitive regex queries                                            // 148\n// are slow, we construct a set of prefix selectors for all permutations of                                            // 149\n// the first 4 characters ourselves. We first attempt to matching against                                              // 150\n// these, and because 'prefix expression' regex queries do use indexes (see                                            // 151\n// http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),                                            // 152\n// this has been found to greatly improve performance (from 1200ms to 5ms in a                                         // 153\n// test with 1.000.000 users).                                                                                         // 154\nvar selectorForFastCaseInsensitiveLookup = function selectorForFastCaseInsensitiveLookup(fieldName, string) {          // 155\n  // Performance seems to improve up to 4 prefix characters                                                            // 156\n  var prefix = string.substring(0, Math.min(string.length, 4));                                                        // 157\n  var orClause = _.map(generateCasePermutationsForString(prefix), function (prefixPermutation) {                       // 158\n    var selector = {};                                                                                                 // 160\n    selector[fieldName] = new RegExp('^' + Meteor._escapeRegExp(prefixPermutation));                                   // 161\n    return selector;                                                                                                   // 163\n  });                                                                                                                  // 164\n  var caseInsensitiveClause = {};                                                                                      // 165\n  caseInsensitiveClause[fieldName] = new RegExp('^' + Meteor._escapeRegExp(string) + '$', 'i');                        // 166\n  return { $and: [{ $or: orClause }, caseInsensitiveClause] };                                                         // 168\n};                                                                                                                     // 169\n                                                                                                                       //\n// Generates permutations of all case variations of a given string.                                                    // 171\nvar generateCasePermutationsForString = function generateCasePermutationsForString(string) {                           // 172\n  var permutations = [''];                                                                                             // 173\n  for (var i = 0; i < string.length; i++) {                                                                            // 174\n    var ch = string.charAt(i);                                                                                         // 175\n    permutations = _.flatten(_.map(permutations, function (prefix) {                                                   // 176\n      var lowerCaseChar = ch.toLowerCase();                                                                            // 177\n      var upperCaseChar = ch.toUpperCase();                                                                            // 178\n      // Don't add unneccesary permutations when ch is not a letter                                                    // 179\n      if (lowerCaseChar === upperCaseChar) {                                                                           // 180\n        return [prefix + ch];                                                                                          // 181\n      } else {                                                                                                         // 182\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];                                                       // 183\n      }                                                                                                                // 184\n    }));                                                                                                               // 185\n  }                                                                                                                    // 186\n  return permutations;                                                                                                 // 187\n};                                                                                                                     // 188\n                                                                                                                       //\nvar checkForCaseInsensitiveDuplicates = function checkForCaseInsensitiveDuplicates(fieldName, displayName, fieldValue, ownUserId) {\n  // Some tests need the ability to add users with the same case insensitive                                           // 191\n  // value, hence the _skipCaseInsensitiveChecksForTest check                                                          // 192\n  var skipCheck = _.has(Accounts._skipCaseInsensitiveChecksForTest, fieldValue);                                       // 193\n                                                                                                                       //\n  if (fieldValue && !skipCheck) {                                                                                      // 195\n    var matchedUsers = Meteor.users.find(selectorForFastCaseInsensitiveLookup(fieldName, fieldValue)).fetch();         // 196\n                                                                                                                       //\n    if (matchedUsers.length > 0 && (                                                                                   // 199\n    // If we don't have a userId yet, any match we find is a duplicate                                                 // 200\n    !ownUserId ||                                                                                                      // 201\n    // Otherwise, check to see if there are multiple matches or a match                                                // 202\n    // that is not us                                                                                                  // 203\n    matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId)) {                                                   // 204\n      throw new Meteor.Error(403, displayName + \" already exists.\");                                                   // 205\n    }                                                                                                                  // 206\n  }                                                                                                                    // 207\n};                                                                                                                     // 208\n                                                                                                                       //\n// XXX maybe this belongs in the check package                                                                         // 210\nvar NonEmptyString = Match.Where(function (x) {                                                                        // 211\n  check(x, String);                                                                                                    // 212\n  return x.length > 0;                                                                                                 // 213\n});                                                                                                                    // 214\n                                                                                                                       //\nvar userQueryValidator = Match.Where(function (user) {                                                                 // 216\n  check(user, {                                                                                                        // 217\n    id: Match.Optional(NonEmptyString),                                                                                // 218\n    username: Match.Optional(NonEmptyString),                                                                          // 219\n    email: Match.Optional(NonEmptyString)                                                                              // 220\n  });                                                                                                                  // 217\n  if (_.keys(user).length !== 1) throw new Match.Error(\"User property must have exactly one field\");                   // 222\n  return true;                                                                                                         // 224\n});                                                                                                                    // 225\n                                                                                                                       //\nvar passwordValidator = Match.OneOf(String, { digest: String, algorithm: String });                                    // 227\n                                                                                                                       //\n// Handler to login with a password.                                                                                   // 232\n//                                                                                                                     // 233\n// The Meteor client sets options.password to an object with keys                                                      // 234\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").                                                     // 235\n//                                                                                                                     // 236\n// For other DDP clients which don't have access to SHA, the handler                                                   // 237\n// also accepts the plaintext password in options.password as a string.                                                // 238\n//                                                                                                                     // 239\n// (It might be nice if servers could turn the plaintext password                                                      // 240\n// option off. Or maybe it should be opt-in, not opt-out?                                                              // 241\n// Accounts.config option?)                                                                                            // 242\n//                                                                                                                     // 243\n// Note that neither password option is secure without SSL.                                                            // 244\n//                                                                                                                     // 245\nAccounts.registerLoginHandler(\"password\", function (options) {                                                         // 246\n  if (!options.password || options.srp) return undefined; // don't handle                                              // 247\n                                                                                                                       //\n  check(options, {                                                                                                     // 250\n    user: userQueryValidator,                                                                                          // 251\n    password: passwordValidator                                                                                        // 252\n  });                                                                                                                  // 250\n                                                                                                                       //\n  var user = Accounts._findUserByQuery(options.user);                                                                  // 256\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                            // 257\n                                                                                                                       //\n  if (!user.services || !user.services.password || !(user.services.password.bcrypt || user.services.password.srp)) throw new Meteor.Error(403, \"User has no password set\");\n                                                                                                                       //\n  if (!user.services.password.bcrypt) {                                                                                // 264\n    if (typeof options.password === \"string\") {                                                                        // 265\n      // The client has presented a plaintext password, and the user is                                                // 266\n      // not upgraded to bcrypt yet. We don't attempt to tell the client                                               // 267\n      // to upgrade to bcrypt, because it might be a standalone DDP                                                    // 268\n      // client doesn't know how to do such a thing.                                                                   // 269\n      var verifier = user.services.password.srp;                                                                       // 270\n      var newVerifier = SRP.generateVerifier(options.password, {                                                       // 271\n        identity: verifier.identity, salt: verifier.salt });                                                           // 272\n                                                                                                                       //\n      if (verifier.verifier !== newVerifier.verifier) {                                                                // 274\n        return {                                                                                                       // 275\n          userId: user._id,                                                                                            // 276\n          error: new Meteor.Error(403, \"Incorrect password\")                                                           // 277\n        };                                                                                                             // 275\n      }                                                                                                                // 279\n                                                                                                                       //\n      return { userId: user._id };                                                                                     // 281\n    } else {                                                                                                           // 282\n      // Tell the client to use the SRP upgrade process.                                                               // 283\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({                                             // 284\n        format: 'srp',                                                                                                 // 285\n        identity: user.services.password.srp.identity                                                                  // 286\n      }));                                                                                                             // 284\n    }                                                                                                                  // 288\n  }                                                                                                                    // 289\n                                                                                                                       //\n  return checkPassword(user, options.password);                                                                        // 291\n});                                                                                                                    // 295\n                                                                                                                       //\n// Handler to login using the SRP upgrade path. To use this login                                                      // 297\n// handler, the client must provide:                                                                                   // 298\n//   - srp: H(identity + \":\" + password)                                                                               // 299\n//   - password: a string or an object with properties 'digest' and 'algorithm'                                        // 300\n//                                                                                                                     // 301\n// We use `options.srp` to verify that the client knows the correct                                                    // 302\n// password without doing a full SRP flow. Once we've checked that, we                                                 // 303\n// upgrade the user to bcrypt and remove the SRP information from the                                                  // 304\n// user document.                                                                                                      // 305\n//                                                                                                                     // 306\n// The client ends up using this login handler after trying the normal                                                 // 307\n// login handler (above), which throws an error telling the client to                                                  // 308\n// try the SRP upgrade path.                                                                                           // 309\n//                                                                                                                     // 310\n// XXX COMPAT WITH 0.8.1.3                                                                                             // 311\nAccounts.registerLoginHandler(\"password\", function (options) {                                                         // 312\n  if (!options.srp || !options.password) return undefined; // don't handle                                             // 313\n                                                                                                                       //\n  check(options, {                                                                                                     // 316\n    user: userQueryValidator,                                                                                          // 317\n    srp: String,                                                                                                       // 318\n    password: passwordValidator                                                                                        // 319\n  });                                                                                                                  // 316\n                                                                                                                       //\n  var user = Accounts._findUserByQuery(options.user);                                                                  // 322\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                            // 323\n                                                                                                                       //\n  // Check to see if another simultaneous login has already upgraded                                                   // 326\n  // the user record to bcrypt.                                                                                        // 327\n  if (user.services && user.services.password && user.services.password.bcrypt) return checkPassword(user, options.password);\n                                                                                                                       //\n  if (!(user.services && user.services.password && user.services.password.srp)) throw new Meteor.Error(403, \"User has no password set\");\n                                                                                                                       //\n  var v1 = user.services.password.srp.verifier;                                                                        // 334\n  var v2 = SRP.generateVerifier(null, {                                                                                // 335\n    hashedIdentityAndPassword: options.srp,                                                                            // 338\n    salt: user.services.password.srp.salt                                                                              // 339\n  }).verifier;                                                                                                         // 337\n  if (v1 !== v2) return {                                                                                              // 342\n    userId: user._id,                                                                                                  // 344\n    error: new Meteor.Error(403, \"Incorrect password\")                                                                 // 345\n  };                                                                                                                   // 343\n                                                                                                                       //\n  // Upgrade to bcrypt on successful login.                                                                            // 348\n  var salted = hashPassword(options.password);                                                                         // 349\n  Meteor.users.update(user._id, {                                                                                      // 350\n    $unset: { 'services.password.srp': 1 },                                                                            // 353\n    $set: { 'services.password.bcrypt': salted }                                                                       // 354\n  });                                                                                                                  // 352\n                                                                                                                       //\n  return { userId: user._id };                                                                                         // 358\n});                                                                                                                    // 359\n                                                                                                                       //\n///                                                                                                                    // 362\n/// CHANGING                                                                                                           // 363\n///                                                                                                                    // 364\n                                                                                                                       //\n/**                                                                                                                    // 366\n * @summary Change a user's username. Use this instead of updating the                                                 //\n * database directly. The operation will fail if there is an existing user                                             //\n * with a username only differing in case.                                                                             //\n * @locus Server                                                                                                       //\n * @param {String} userId The ID of the user to update.                                                                //\n * @param {String} newUsername A new username for the user.                                                            //\n * @importFromPackage accounts-base                                                                                    //\n */                                                                                                                    //\nAccounts.setUsername = function (userId, newUsername) {                                                                // 375\n  check(userId, NonEmptyString);                                                                                       // 376\n  check(newUsername, NonEmptyString);                                                                                  // 377\n                                                                                                                       //\n  var user = Meteor.users.findOne(userId);                                                                             // 379\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                            // 380\n                                                                                                                       //\n  var oldUsername = user.username;                                                                                     // 383\n                                                                                                                       //\n  // Perform a case insensitive check for duplicates before update                                                     // 385\n  checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);                                    // 386\n                                                                                                                       //\n  Meteor.users.update({ _id: user._id }, { $set: { username: newUsername } });                                         // 388\n                                                                                                                       //\n  // Perform another check after update, in case a matching user has been                                              // 390\n  // inserted in the meantime                                                                                          // 391\n  try {                                                                                                                // 392\n    checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);                                  // 393\n  } catch (ex) {                                                                                                       // 394\n    // Undo update if the check fails                                                                                  // 395\n    Meteor.users.update({ _id: user._id }, { $set: { username: oldUsername } });                                       // 396\n    throw ex;                                                                                                          // 397\n  }                                                                                                                    // 398\n};                                                                                                                     // 399\n                                                                                                                       //\n// Let the user change their own password if they know the old                                                         // 401\n// password. `oldPassword` and `newPassword` should be objects with keys                                               // 402\n// `digest` and `algorithm` (representing the SHA256 of the password).                                                 // 403\n//                                                                                                                     // 404\n// XXX COMPAT WITH 0.8.1.3                                                                                             // 405\n// Like the login method, if the user hasn't been upgraded from SRP to                                                 // 406\n// bcrypt yet, then this method will throw an 'old password format'                                                    // 407\n// error. The client should call the SRP upgrade login handler and then                                                // 408\n// retry this method again.                                                                                            // 409\n//                                                                                                                     // 410\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade                                               // 411\n// errors thrown. The reasoning for this is that clients using this                                                    // 412\n// method directly will need to be updated anyway because we no longer                                                 // 413\n// support the SRP flow that they would have been doing to use this                                                    // 414\n// method previously.                                                                                                  // 415\nMeteor.methods({ changePassword: function () {                                                                         // 416\n    function changePassword(oldPassword, newPassword) {                                                                // 416\n      check(oldPassword, passwordValidator);                                                                           // 417\n      check(newPassword, passwordValidator);                                                                           // 418\n                                                                                                                       //\n      if (!this.userId) throw new Meteor.Error(401, \"Must be logged in\");                                              // 420\n                                                                                                                       //\n      var user = Meteor.users.findOne(this.userId);                                                                    // 423\n      if (!user) throw new Meteor.Error(403, \"User not found\");                                                        // 424\n                                                                                                                       //\n      if (!user.services || !user.services.password || !user.services.password.bcrypt && !user.services.password.srp) throw new Meteor.Error(403, \"User has no password set\");\n                                                                                                                       //\n      if (!user.services.password.bcrypt) {                                                                            // 431\n        throw new Meteor.Error(400, \"old password format\", EJSON.stringify({                                           // 432\n          format: 'srp',                                                                                               // 433\n          identity: user.services.password.srp.identity                                                                // 434\n        }));                                                                                                           // 432\n      }                                                                                                                // 436\n                                                                                                                       //\n      var result = checkPassword(user, oldPassword);                                                                   // 438\n      if (result.error) throw result.error;                                                                            // 439\n                                                                                                                       //\n      var hashed = hashPassword(newPassword);                                                                          // 442\n                                                                                                                       //\n      // It would be better if this removed ALL existing tokens and replaced                                           // 444\n      // the token for the current connection with a new one, but that would                                           // 445\n      // be tricky, so we'll settle for just replacing all tokens other than                                           // 446\n      // the one for the current connection.                                                                           // 447\n      var currentToken = Accounts._getLoginToken(this.connection.id);                                                  // 448\n      Meteor.users.update({ _id: this.userId }, {                                                                      // 449\n        $set: { 'services.password.bcrypt': hashed },                                                                  // 452\n        $pull: {                                                                                                       // 453\n          'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }                                        // 454\n        },                                                                                                             // 453\n        $unset: { 'services.password.reset': 1 }                                                                       // 456\n      });                                                                                                              // 451\n                                                                                                                       //\n      return { passwordChanged: true };                                                                                // 460\n    }                                                                                                                  // 461\n                                                                                                                       //\n    return changePassword;                                                                                             // 416\n  }() });                                                                                                              // 416\n                                                                                                                       //\n// Force change the users password.                                                                                    // 464\n                                                                                                                       //\n/**                                                                                                                    // 466\n * @summary Forcibly change the password for a user.                                                                   //\n * @locus Server                                                                                                       //\n * @param {String} userId The id of the user to update.                                                                //\n * @param {String} newPassword A new password for the user.                                                            //\n * @param {Object} [options]                                                                                           //\n * @param {Object} options.logout Logout all current connections with this userId (default: true)                      //\n * @importFromPackage accounts-base                                                                                    //\n */                                                                                                                    //\nAccounts.setPassword = function (userId, newPlaintextPassword, options) {                                              // 475\n  options = _.extend({ logout: true }, options);                                                                       // 476\n                                                                                                                       //\n  var user = Meteor.users.findOne(userId);                                                                             // 478\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                            // 479\n                                                                                                                       //\n  var update = {                                                                                                       // 482\n    $unset: {                                                                                                          // 483\n      'services.password.srp': 1, // XXX COMPAT WITH 0.8.1.3                                                           // 484\n      'services.password.reset': 1                                                                                     // 485\n    },                                                                                                                 // 483\n    $set: { 'services.password.bcrypt': hashPassword(newPlaintextPassword) }                                           // 487\n  };                                                                                                                   // 482\n                                                                                                                       //\n  if (options.logout) {                                                                                                // 490\n    update.$unset['services.resume.loginTokens'] = 1;                                                                  // 491\n  }                                                                                                                    // 492\n                                                                                                                       //\n  Meteor.users.update({ _id: user._id }, update);                                                                      // 494\n};                                                                                                                     // 495\n                                                                                                                       //\n///                                                                                                                    // 498\n/// RESETTING VIA EMAIL                                                                                                // 499\n///                                                                                                                    // 500\n                                                                                                                       //\n// Method called by a user to request a password reset email. This is                                                  // 502\n// the start of the reset process.                                                                                     // 503\nMeteor.methods({ forgotPassword: function () {                                                                         // 504\n    function forgotPassword(options) {                                                                                 // 504\n      check(options, { email: String });                                                                               // 505\n                                                                                                                       //\n      var user = Accounts.findUserByEmail(options.email);                                                              // 507\n      if (!user) throw new Meteor.Error(403, \"User not found\");                                                        // 508\n                                                                                                                       //\n      var emails = _.pluck(user.emails || [], 'address');                                                              // 511\n      var caseSensitiveEmail = _.find(emails, function (email) {                                                       // 512\n        return email.toLowerCase() === options.email.toLowerCase();                                                    // 513\n      });                                                                                                              // 514\n                                                                                                                       //\n      Accounts.sendResetPasswordEmail(user._id, caseSensitiveEmail);                                                   // 516\n    }                                                                                                                  // 517\n                                                                                                                       //\n    return forgotPassword;                                                                                             // 504\n  }() });                                                                                                              // 504\n                                                                                                                       //\n// send the user an email with a link that when opened allows the user                                                 // 519\n// to set a new password, without the old password.                                                                    // 520\n                                                                                                                       //\n/**                                                                                                                    // 522\n * @summary Send an email with a link the user can use to reset their password.                                        //\n * @locus Server                                                                                                       //\n * @param {String} userId The id of the user to send email to.                                                         //\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @importFromPackage accounts-base                                                                                    //\n */                                                                                                                    //\nAccounts.sendResetPasswordEmail = function (userId, email) {                                                           // 529\n  // Make sure the user exists, and email is one of their addresses.                                                   // 530\n  var user = Meteor.users.findOne(userId);                                                                             // 531\n  if (!user) throw new Error(\"Can't find user\");                                                                       // 532\n  // pick the first email if we weren't passed an email.                                                               // 534\n  if (!email && user.emails && user.emails[0]) email = user.emails[0].address;                                         // 535\n  // make sure we have a valid email                                                                                   // 537\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email)) throw new Error(\"No such email for user.\");\n                                                                                                                       //\n  var token = Random.secret();                                                                                         // 541\n  var when = new Date();                                                                                               // 542\n  var tokenRecord = {                                                                                                  // 543\n    token: token,                                                                                                      // 544\n    email: email,                                                                                                      // 545\n    when: when,                                                                                                        // 546\n    reason: 'reset'                                                                                                    // 547\n  };                                                                                                                   // 543\n  Meteor.users.update(userId, { $set: {                                                                                // 549\n      \"services.password.reset\": tokenRecord                                                                           // 550\n    } });                                                                                                              // 549\n  // before passing to template, update user object with new token                                                     // 552\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;                                                    // 553\n                                                                                                                       //\n  var resetPasswordUrl = Accounts.urls.resetPassword(token);                                                           // 555\n                                                                                                                       //\n  var options = {                                                                                                      // 557\n    to: email,                                                                                                         // 558\n    from: Accounts.emailTemplates.resetPassword.from ? Accounts.emailTemplates.resetPassword.from(user) : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.resetPassword.subject(user)                                                       // 562\n  };                                                                                                                   // 557\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.resetPassword.text === 'function') {                                              // 565\n    options.text = Accounts.emailTemplates.resetPassword.text(user, resetPasswordUrl);                                 // 566\n  }                                                                                                                    // 568\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.resetPassword.html === 'function') options.html = Accounts.emailTemplates.resetPassword.html(user, resetPasswordUrl);\n                                                                                                                       //\n  if (_typeof(Accounts.emailTemplates.headers) === 'object') {                                                         // 574\n    options.headers = Accounts.emailTemplates.headers;                                                                 // 575\n  }                                                                                                                    // 576\n                                                                                                                       //\n  Email.send(options);                                                                                                 // 578\n};                                                                                                                     // 579\n                                                                                                                       //\n// send the user an email informing them that their account was created, with                                          // 581\n// a link that when opened both marks their email as verified and forces them                                          // 582\n// to choose their password. The email must be one of the addresses in the                                             // 583\n// user's emails field, or undefined to pick the first email automatically.                                            // 584\n//                                                                                                                     // 585\n// This is not called automatically. It must be called manually if you                                                 // 586\n// want to use enrollment emails.                                                                                      // 587\n                                                                                                                       //\n/**                                                                                                                    // 589\n * @summary Send an email with a link the user can use to set their initial password.                                  //\n * @locus Server                                                                                                       //\n * @param {String} userId The id of the user to send email to.                                                         //\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @importFromPackage accounts-base                                                                                    //\n */                                                                                                                    //\nAccounts.sendEnrollmentEmail = function (userId, email) {                                                              // 596\n  // XXX refactor! This is basically identical to sendResetPasswordEmail.                                              // 597\n                                                                                                                       //\n  // Make sure the user exists, and email is in their addresses.                                                       // 599\n  var user = Meteor.users.findOne(userId);                                                                             // 600\n  if (!user) throw new Error(\"Can't find user\");                                                                       // 601\n  // pick the first email if we weren't passed an email.                                                               // 603\n  if (!email && user.emails && user.emails[0]) email = user.emails[0].address;                                         // 604\n  // make sure we have a valid email                                                                                   // 606\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email)) throw new Error(\"No such email for user.\");\n                                                                                                                       //\n  var token = Random.secret();                                                                                         // 610\n  var when = new Date();                                                                                               // 611\n  var tokenRecord = {                                                                                                  // 612\n    token: token,                                                                                                      // 613\n    email: email,                                                                                                      // 614\n    when: when,                                                                                                        // 615\n    reason: 'enroll'                                                                                                   // 616\n  };                                                                                                                   // 612\n  Meteor.users.update(userId, { $set: {                                                                                // 618\n      \"services.password.reset\": tokenRecord                                                                           // 619\n    } });                                                                                                              // 618\n                                                                                                                       //\n  // before passing to template, update user object with new token                                                     // 622\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;                                                    // 623\n                                                                                                                       //\n  var enrollAccountUrl = Accounts.urls.enrollAccount(token);                                                           // 625\n                                                                                                                       //\n  var options = {                                                                                                      // 627\n    to: email,                                                                                                         // 628\n    from: Accounts.emailTemplates.enrollAccount.from ? Accounts.emailTemplates.enrollAccount.from(user) : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.enrollAccount.subject(user)                                                       // 632\n  };                                                                                                                   // 627\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.enrollAccount.text === 'function') {                                              // 635\n    options.text = Accounts.emailTemplates.enrollAccount.text(user, enrollAccountUrl);                                 // 636\n  }                                                                                                                    // 638\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.enrollAccount.html === 'function') options.html = Accounts.emailTemplates.enrollAccount.html(user, enrollAccountUrl);\n                                                                                                                       //\n  if (_typeof(Accounts.emailTemplates.headers) === 'object') {                                                         // 644\n    options.headers = Accounts.emailTemplates.headers;                                                                 // 645\n  }                                                                                                                    // 646\n                                                                                                                       //\n  Email.send(options);                                                                                                 // 648\n};                                                                                                                     // 649\n                                                                                                                       //\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change                                               // 652\n// the users password, and log them in.                                                                                // 653\nMeteor.methods({ resetPassword: function () {                                                                          // 654\n    function resetPassword(token, newPassword) {                                                                       // 654\n      var self = this;                                                                                                 // 655\n      return Accounts._loginMethod(self, \"resetPassword\", arguments, \"password\", function () {                         // 656\n        check(token, String);                                                                                          // 662\n        check(newPassword, passwordValidator);                                                                         // 663\n                                                                                                                       //\n        var user = Meteor.users.findOne({                                                                              // 665\n          \"services.password.reset.token\": token });                                                                   // 666\n        if (!user) throw new Meteor.Error(403, \"Token expired\");                                                       // 667\n        var when = user.services.password.reset.when;                                                                  // 669\n        var reason = user.services.password.reset.reason;                                                              // 670\n        var tokenLifetimeMs = Accounts._getPasswordResetTokenLifetimeMs();                                             // 671\n        if (reason === \"enroll\") {                                                                                     // 672\n          tokenLifetimeMs = Accounts._getPasswordEnrollTokenLifetimeMs();                                              // 673\n        }                                                                                                              // 674\n        var currentTimeMs = Date.now();                                                                                // 675\n        if (currentTimeMs - when > tokenLifetimeMs) throw new Meteor.Error(403, \"Token expired\");                      // 676\n        var email = user.services.password.reset.email;                                                                // 678\n        if (!_.include(_.pluck(user.emails || [], 'address'), email)) return {                                         // 679\n          userId: user._id,                                                                                            // 681\n          error: new Meteor.Error(403, \"Token has invalid email address\")                                              // 682\n        };                                                                                                             // 680\n                                                                                                                       //\n        var hashed = hashPassword(newPassword);                                                                        // 685\n                                                                                                                       //\n        // NOTE: We're about to invalidate tokens on the user, who we might be                                         // 687\n        // logged in as. Make sure to avoid logging ourselves out if this                                              // 688\n        // happens. But also make sure not to leave the connection in a state                                          // 689\n        // of having a bad token set if things fail.                                                                   // 690\n        var oldToken = Accounts._getLoginToken(self.connection.id);                                                    // 691\n        Accounts._setLoginToken(user._id, self.connection, null);                                                      // 692\n        var resetToOldToken = function () {                                                                            // 693\n          function resetToOldToken() {                                                                                 // 693\n            Accounts._setLoginToken(user._id, self.connection, oldToken);                                              // 694\n          }                                                                                                            // 695\n                                                                                                                       //\n          return resetToOldToken;                                                                                      // 693\n        }();                                                                                                           // 693\n                                                                                                                       //\n        try {                                                                                                          // 697\n          // Update the user record by:                                                                                // 698\n          // - Changing the password to the new one                                                                    // 699\n          // - Forgetting about the reset token that was just used                                                     // 700\n          // - Verifying their email, since they got the password reset via email.                                     // 701\n          var affectedRecords = Meteor.users.update({                                                                  // 702\n            _id: user._id,                                                                                             // 704\n            'emails.address': email,                                                                                   // 705\n            'services.password.reset.token': token                                                                     // 706\n          }, { $set: { 'services.password.bcrypt': hashed,                                                             // 703\n              'emails.$.verified': true },                                                                             // 709\n            $unset: { 'services.password.reset': 1,                                                                    // 710\n              'services.password.srp': 1 } });                                                                         // 711\n          if (affectedRecords !== 1) return {                                                                          // 712\n            userId: user._id,                                                                                          // 714\n            error: new Meteor.Error(403, \"Invalid email\")                                                              // 715\n          };                                                                                                           // 713\n        } catch (err) {                                                                                                // 717\n          resetToOldToken();                                                                                           // 718\n          throw err;                                                                                                   // 719\n        }                                                                                                              // 720\n                                                                                                                       //\n        // Replace all valid login tokens with new ones (changing                                                      // 722\n        // password should invalidate existing sessions).                                                              // 723\n        Accounts._clearAllLoginTokens(user._id);                                                                       // 724\n                                                                                                                       //\n        return { userId: user._id };                                                                                   // 726\n      });                                                                                                              // 727\n    }                                                                                                                  // 729\n                                                                                                                       //\n    return resetPassword;                                                                                              // 654\n  }() });                                                                                                              // 654\n                                                                                                                       //\n///                                                                                                                    // 731\n/// EMAIL VERIFICATION                                                                                                 // 732\n///                                                                                                                    // 733\n                                                                                                                       //\n                                                                                                                       //\n// send the user an email with a link that when opened marks that                                                      // 736\n// address as verified                                                                                                 // 737\n                                                                                                                       //\n/**                                                                                                                    // 739\n * @summary Send an email with a link the user can use verify their email address.                                     //\n * @locus Server                                                                                                       //\n * @param {String} userId The id of the user to send email to.                                                         //\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n * @importFromPackage accounts-base                                                                                    //\n */                                                                                                                    //\nAccounts.sendVerificationEmail = function (userId, address) {                                                          // 746\n  // XXX Also generate a link using which someone can delete this                                                      // 747\n  // account if they own said address but weren't those who created                                                    // 748\n  // this account.                                                                                                     // 749\n                                                                                                                       //\n  // Make sure the user exists, and address is one of their addresses.                                                 // 751\n  var user = Meteor.users.findOne(userId);                                                                             // 752\n  if (!user) throw new Error(\"Can't find user\");                                                                       // 753\n  // pick the first unverified address if we weren't passed an address.                                                // 755\n  if (!address) {                                                                                                      // 756\n    var email = _.find(user.emails || [], function (e) {                                                               // 757\n      return !e.verified;                                                                                              // 758\n    });                                                                                                                // 758\n    address = (email || {}).address;                                                                                   // 759\n                                                                                                                       //\n    if (!address) {                                                                                                    // 761\n      throw new Error(\"That user has no unverified email addresses.\");                                                 // 762\n    }                                                                                                                  // 763\n  }                                                                                                                    // 764\n  // make sure we have a valid address                                                                                 // 765\n  if (!address || !_.contains(_.pluck(user.emails || [], 'address'), address)) throw new Error(\"No such email address for user.\");\n                                                                                                                       //\n  var tokenRecord = {                                                                                                  // 770\n    token: Random.secret(),                                                                                            // 771\n    address: address,                                                                                                  // 772\n    when: new Date() };                                                                                                // 773\n  Meteor.users.update({ _id: userId }, { $push: { 'services.email.verificationTokens': tokenRecord } });               // 774\n                                                                                                                       //\n  // before passing to template, update user object with new token                                                     // 778\n  Meteor._ensure(user, 'services', 'email');                                                                           // 779\n  if (!user.services.email.verificationTokens) {                                                                       // 780\n    user.services.email.verificationTokens = [];                                                                       // 781\n  }                                                                                                                    // 782\n  user.services.email.verificationTokens.push(tokenRecord);                                                            // 783\n                                                                                                                       //\n  var verifyEmailUrl = Accounts.urls.verifyEmail(tokenRecord.token);                                                   // 785\n                                                                                                                       //\n  var options = {                                                                                                      // 787\n    to: address,                                                                                                       // 788\n    from: Accounts.emailTemplates.verifyEmail.from ? Accounts.emailTemplates.verifyEmail.from(user) : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.verifyEmail.subject(user)                                                         // 792\n  };                                                                                                                   // 787\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.verifyEmail.text === 'function') {                                                // 795\n    options.text = Accounts.emailTemplates.verifyEmail.text(user, verifyEmailUrl);                                     // 796\n  }                                                                                                                    // 798\n                                                                                                                       //\n  if (typeof Accounts.emailTemplates.verifyEmail.html === 'function') options.html = Accounts.emailTemplates.verifyEmail.html(user, verifyEmailUrl);\n                                                                                                                       //\n  if (_typeof(Accounts.emailTemplates.headers) === 'object') {                                                         // 804\n    options.headers = Accounts.emailTemplates.headers;                                                                 // 805\n  }                                                                                                                    // 806\n                                                                                                                       //\n  Email.send(options);                                                                                                 // 808\n};                                                                                                                     // 809\n                                                                                                                       //\n// Take token from sendVerificationEmail, mark the email as verified,                                                  // 811\n// and log them in.                                                                                                    // 812\nMeteor.methods({ verifyEmail: function () {                                                                            // 813\n    function verifyEmail(token) {                                                                                      // 813\n      var self = this;                                                                                                 // 814\n      return Accounts._loginMethod(self, \"verifyEmail\", arguments, \"password\", function () {                           // 815\n        check(token, String);                                                                                          // 821\n                                                                                                                       //\n        var user = Meteor.users.findOne({ 'services.email.verificationTokens.token': token });                         // 823\n        if (!user) throw new Meteor.Error(403, \"Verify email link expired\");                                           // 825\n                                                                                                                       //\n        var tokenRecord = _.find(user.services.email.verificationTokens, function (t) {                                // 828\n          return t.token == token;                                                                                     // 830\n        });                                                                                                            // 831\n        if (!tokenRecord) return {                                                                                     // 832\n          userId: user._id,                                                                                            // 834\n          error: new Meteor.Error(403, \"Verify email link expired\")                                                    // 835\n        };                                                                                                             // 833\n                                                                                                                       //\n        var emailsRecord = _.find(user.emails, function (e) {                                                          // 838\n          return e.address == tokenRecord.address;                                                                     // 839\n        });                                                                                                            // 840\n        if (!emailsRecord) return {                                                                                    // 841\n          userId: user._id,                                                                                            // 843\n          error: new Meteor.Error(403, \"Verify email link is for unknown address\")                                     // 844\n        };                                                                                                             // 842\n                                                                                                                       //\n        // By including the address in the query, we can use 'emails.$' in the                                         // 847\n        // modifier to get a reference to the specific object in the emails                                            // 848\n        // array. See                                                                                                  // 849\n        // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)                            // 850\n        // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull                                               // 851\n        Meteor.users.update({ _id: user._id,                                                                           // 852\n          'emails.address': tokenRecord.address }, { $set: { 'emails.$.verified': true },                              // 854\n          $pull: { 'services.email.verificationTokens': { address: tokenRecord.address } } });                         // 856\n                                                                                                                       //\n        return { userId: user._id };                                                                                   // 858\n      });                                                                                                              // 859\n    }                                                                                                                  // 861\n                                                                                                                       //\n    return verifyEmail;                                                                                                // 813\n  }() });                                                                                                              // 813\n                                                                                                                       //\n/**                                                                                                                    // 863\n * @summary Add an email address for a user. Use this instead of directly                                              //\n * updating the database. The operation will fail if there is a different user                                         //\n * with an email only differing in case. If the specified user has an existing                                         //\n * email only differing in case however, we replace it.                                                                //\n * @locus Server                                                                                                       //\n * @param {String} userId The ID of the user to update.                                                                //\n * @param {String} newEmail A new email address for the user.                                                          //\n * @param {Boolean} [verified] Optional - whether the new email address should                                         //\n * be marked as verified. Defaults to false.                                                                           //\n * @importFromPackage accounts-base                                                                                    //\n */                                                                                                                    //\nAccounts.addEmail = function (userId, newEmail, verified) {                                                            // 875\n  check(userId, NonEmptyString);                                                                                       // 876\n  check(newEmail, NonEmptyString);                                                                                     // 877\n  check(verified, Match.Optional(Boolean));                                                                            // 878\n                                                                                                                       //\n  if (_.isUndefined(verified)) {                                                                                       // 880\n    verified = false;                                                                                                  // 881\n  }                                                                                                                    // 882\n                                                                                                                       //\n  var user = Meteor.users.findOne(userId);                                                                             // 884\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                            // 885\n                                                                                                                       //\n  // Allow users to change their own email to a version with a different case                                          // 888\n                                                                                                                       //\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case                                              // 890\n  // insensitive check across all emails in the database here because: (1) if                                          // 891\n  // there is no case-insensitive duplicate between this user and other users,                                         // 892\n  // then we are OK and (2) if this would create a conflict with other users                                           // 893\n  // then there would already be a case-insensitive duplicate and we can't fix                                         // 894\n  // that in this code anyway.                                                                                         // 895\n  var caseInsensitiveRegExp = new RegExp('^' + Meteor._escapeRegExp(newEmail) + '$', 'i');                             // 896\n                                                                                                                       //\n  var didUpdateOwnEmail = _.any(user.emails, function (email, index) {                                                 // 899\n    if (caseInsensitiveRegExp.test(email.address)) {                                                                   // 900\n      Meteor.users.update({                                                                                            // 901\n        _id: user._id,                                                                                                 // 902\n        'emails.address': email.address                                                                                // 903\n      }, { $set: {                                                                                                     // 901\n          'emails.$.address': newEmail,                                                                                // 905\n          'emails.$.verified': verified                                                                                // 906\n        } });                                                                                                          // 904\n      return true;                                                                                                     // 908\n    }                                                                                                                  // 909\n                                                                                                                       //\n    return false;                                                                                                      // 911\n  });                                                                                                                  // 912\n                                                                                                                       //\n  // In the other updates below, we have to do another call to                                                         // 914\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values                                         // 915\n  // were added to the database in the meantime. We don't have to do this for                                          // 916\n  // the case where the user is updating their email address to one that is the                                        // 917\n  // same as before, but only different because of capitalization. Read the                                            // 918\n  // big comment above to understand why.                                                                              // 919\n                                                                                                                       //\n  if (didUpdateOwnEmail) {                                                                                             // 921\n    return;                                                                                                            // 922\n  }                                                                                                                    // 923\n                                                                                                                       //\n  // Perform a case insensitive check for duplicates before update                                                     // 925\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);                                    // 926\n                                                                                                                       //\n  Meteor.users.update({                                                                                                // 928\n    _id: user._id                                                                                                      // 929\n  }, {                                                                                                                 // 928\n    $addToSet: {                                                                                                       // 931\n      emails: {                                                                                                        // 932\n        address: newEmail,                                                                                             // 933\n        verified: verified                                                                                             // 934\n      }                                                                                                                // 932\n    }                                                                                                                  // 931\n  });                                                                                                                  // 930\n                                                                                                                       //\n  // Perform another check after update, in case a matching user has been                                              // 939\n  // inserted in the meantime                                                                                          // 940\n  try {                                                                                                                // 941\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);                                  // 942\n  } catch (ex) {                                                                                                       // 943\n    // Undo update if the check fails                                                                                  // 944\n    Meteor.users.update({ _id: user._id }, { $pull: { emails: { address: newEmail } } });                              // 945\n    throw ex;                                                                                                          // 947\n  }                                                                                                                    // 948\n};                                                                                                                     // 949\n                                                                                                                       //\n/**                                                                                                                    // 951\n * @summary Remove an email address for a user. Use this instead of updating                                           //\n * the database directly.                                                                                              //\n * @locus Server                                                                                                       //\n * @param {String} userId The ID of the user to update.                                                                //\n * @param {String} email The email address to remove.                                                                  //\n * @importFromPackage accounts-base                                                                                    //\n */                                                                                                                    //\nAccounts.removeEmail = function (userId, email) {                                                                      // 959\n  check(userId, NonEmptyString);                                                                                       // 960\n  check(email, NonEmptyString);                                                                                        // 961\n                                                                                                                       //\n  var user = Meteor.users.findOne(userId);                                                                             // 963\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                            // 964\n                                                                                                                       //\n  Meteor.users.update({ _id: user._id }, { $pull: { emails: { address: email } } });                                   // 967\n};                                                                                                                     // 969\n                                                                                                                       //\n///                                                                                                                    // 971\n/// CREATING USERS                                                                                                     // 972\n///                                                                                                                    // 973\n                                                                                                                       //\n// Shared createUser function called from the createUser method, both                                                  // 975\n// if originates in client or server code. Calls user provided hooks,                                                  // 976\n// does the actual user insertion.                                                                                     // 977\n//                                                                                                                     // 978\n// returns the user id                                                                                                 // 979\nvar _createUser = function _createUser(options) {                                                                      // 980\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary                                               // 981\n  // options.                                                                                                          // 982\n  check(options, Match.ObjectIncluding({                                                                               // 983\n    username: Match.Optional(String),                                                                                  // 984\n    email: Match.Optional(String),                                                                                     // 985\n    password: Match.Optional(passwordValidator)                                                                        // 986\n  }));                                                                                                                 // 983\n                                                                                                                       //\n  var username = options.username;                                                                                     // 989\n  var email = options.email;                                                                                           // 990\n  if (!username && !email) throw new Meteor.Error(400, \"Need to set a username or email\");                             // 991\n                                                                                                                       //\n  var user = { services: {} };                                                                                         // 994\n  if (options.password) {                                                                                              // 995\n    var hashed = hashPassword(options.password);                                                                       // 996\n    user.services.password = { bcrypt: hashed };                                                                       // 997\n  }                                                                                                                    // 998\n                                                                                                                       //\n  if (username) user.username = username;                                                                              // 1000\n  if (email) user.emails = [{ address: email, verified: false }];                                                      // 1002\n                                                                                                                       //\n  // Perform a case insensitive check before insert                                                                    // 1005\n  checkForCaseInsensitiveDuplicates('username', 'Username', username);                                                 // 1006\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);                                                 // 1007\n                                                                                                                       //\n  var userId = Accounts.insertUserDoc(options, user);                                                                  // 1009\n  // Perform another check after insert, in case a matching user has been                                              // 1010\n  // inserted in the meantime                                                                                          // 1011\n  try {                                                                                                                // 1012\n    checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);                                       // 1013\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);                                       // 1014\n  } catch (ex) {                                                                                                       // 1015\n    // Remove inserted user if the check fails                                                                         // 1016\n    Meteor.users.remove(userId);                                                                                       // 1017\n    throw ex;                                                                                                          // 1018\n  }                                                                                                                    // 1019\n  return userId;                                                                                                       // 1020\n};                                                                                                                     // 1021\n                                                                                                                       //\n// method for create user. Requests come from the client.                                                              // 1023\nMeteor.methods({ createUser: function () {                                                                             // 1024\n    function createUser(options) {                                                                                     // 1024\n      var self = this;                                                                                                 // 1025\n      return Accounts._loginMethod(self, \"createUser\", arguments, \"password\", function () {                            // 1026\n        // createUser() above does more checking.                                                                      // 1032\n        check(options, Object);                                                                                        // 1033\n        if (Accounts._options.forbidClientAccountCreation) return {                                                    // 1034\n          error: new Meteor.Error(403, \"Signups forbidden\")                                                            // 1036\n        };                                                                                                             // 1035\n                                                                                                                       //\n        // Create user. result contains id and token.                                                                  // 1039\n        var userId = _createUser(options);                                                                             // 1040\n        // safety belt. createUser is supposed to throw on error. send 500 error                                       // 1041\n        // instead of sending a verification email with empty userid.                                                  // 1042\n        if (!userId) throw new Error(\"createUser failed to insert new user\");                                          // 1043\n                                                                                                                       //\n        // If `Accounts._options.sendVerificationEmail` is set, register                                               // 1046\n        // a token to verify the user's primary email, and send it to                                                  // 1047\n        // that address.                                                                                               // 1048\n        if (options.email && Accounts._options.sendVerificationEmail) Accounts.sendVerificationEmail(userId, options.email);\n                                                                                                                       //\n        // client gets logged in as the new user afterwards.                                                           // 1052\n        return { userId: userId };                                                                                     // 1053\n      });                                                                                                              // 1054\n    }                                                                                                                  // 1056\n                                                                                                                       //\n    return createUser;                                                                                                 // 1024\n  }() });                                                                                                              // 1024\n                                                                                                                       //\n// Create user directly on the server.                                                                                 // 1058\n//                                                                                                                     // 1059\n// Unlike the client version, this does not log you in as this user                                                    // 1060\n// after creation.                                                                                                     // 1061\n//                                                                                                                     // 1062\n// returns userId or throws an error if it can't create                                                                // 1063\n//                                                                                                                     // 1064\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,                                         // 1065\n// which is always empty when called from the createUser method? eg, \"admin:                                           // 1066\n// true\", which we want to prevent the client from setting, but which a custom                                         // 1067\n// method calling Accounts.createUser could set?                                                                       // 1068\n//                                                                                                                     // 1069\nAccounts.createUser = function (options, callback) {                                                                   // 1070\n  options = _.clone(options);                                                                                          // 1071\n                                                                                                                       //\n  // XXX allow an optional callback?                                                                                   // 1073\n  if (callback) {                                                                                                      // 1074\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");                             // 1075\n  }                                                                                                                    // 1076\n                                                                                                                       //\n  return _createUser(options);                                                                                         // 1078\n};                                                                                                                     // 1079\n                                                                                                                       //\n///                                                                                                                    // 1081\n/// PASSWORD-SPECIFIC INDEXES ON USERS                                                                                 // 1082\n///                                                                                                                    // 1083\nMeteor.users._ensureIndex('services.email.verificationTokens.token', { unique: 1, sparse: 1 });                        // 1084\nMeteor.users._ensureIndex('services.password.reset.token', { unique: 1, sparse: 1 });                                  // 1086\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}}}},{\"extensions\":[\".js\",\".json\"]});\nrequire(\"./node_modules/meteor/accounts-password/email_templates.js\");\nrequire(\"./node_modules/meteor/accounts-password/password_server.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['accounts-password'] = {};\n\n})();\n","servePath":"/packages/accounts-password.js","sourceMap":{"version":3,"sources":["/packages/accounts-password/email_templates.js","/packages/accounts-password/password_server.js"],"names":["greet","welcomeMsg","user","url","greeting","profile","name","Accounts","emailTemplates","from","siteName","Meteor","absoluteUrl","replace","resetPassword","subject","text","verifyEmail","enrollAccount","bcrypt","NpmModuleBcrypt","bcryptHash","wrapAsync","hash","bcryptCompare","compare","_bcryptRounds","getPasswordString","password","SHA256","algorithm","Error","digest","hashPassword","_checkPassword","result","userId","_id","services","error","checkPassword","_findUserByQuery","query","id","users","findOne","fieldName","fieldValue","username","email","selector","selectorForFastCaseInsensitiveLookup","candidateUsers","find","fetch","length","findUserByUsername","findUserByEmail","string","prefix","substring","Math","min","orClause","_","map","generateCasePermutationsForString","prefixPermutation","RegExp","_escapeRegExp","caseInsensitiveClause","$and","$or","permutations","i","ch","charAt","flatten","lowerCaseChar","toLowerCase","upperCaseChar","toUpperCase","checkForCaseInsensitiveDuplicates","displayName","ownUserId","skipCheck","has","_skipCaseInsensitiveChecksForTest","matchedUsers","NonEmptyString","Match","Where","x","check","String","userQueryValidator","Optional","keys","passwordValidator","OneOf","registerLoginHandler","options","srp","undefined","verifier","newVerifier","SRP","generateVerifier","identity","salt","EJSON","stringify","format","v1","v2","hashedIdentityAndPassword","salted","update","$unset","$set","setUsername","newUsername","oldUsername","ex","methods","changePassword","oldPassword","newPassword","hashed","currentToken","_getLoginToken","connection","$pull","hashedToken","$ne","passwordChanged","setPassword","newPlaintextPassword","extend","logout","forgotPassword","emails","pluck","caseSensitiveEmail","sendResetPasswordEmail","address","contains","token","Random","secret","when","Date","tokenRecord","reason","_ensure","reset","resetPasswordUrl","urls","to","html","headers","Email","send","sendEnrollmentEmail","enrollAccountUrl","self","_loginMethod","arguments","tokenLifetimeMs","_getPasswordResetTokenLifetimeMs","_getPasswordEnrollTokenLifetimeMs","currentTimeMs","now","include","oldToken","_setLoginToken","resetToOldToken","affectedRecords","err","_clearAllLoginTokens","sendVerificationEmail","e","verified","$push","verificationTokens","push","verifyEmailUrl","t","emailsRecord","addEmail","newEmail","Boolean","isUndefined","caseInsensitiveRegExp","didUpdateOwnEmail","any","index","test","$addToSet","removeEmail","createUser","ObjectIncluding","insertUserDoc","remove","Object","_options","forbidClientAccountCreation","callback","clone","_ensureIndex","unique","sparse"],"mappings":"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","file":"/packages/accounts-password.js","sourcesContent":["function greet(welcomeMsg) {\n  return function(user, url) {\n      var greeting = (user.profile && user.profile.name) ?\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\n      return `${greeting}\n\n${welcomeMsg}, simply click the link below.\n\n${url}\n\nThanks.\n`;\n  };\n}\n\n/**\n * @summary Options to customize emails sent from the Accounts system.\n * @locus Server\n * @importFromPackage accounts-base\n */\nAccounts.emailTemplates = {\n  from: \"Meteor Accounts <no-reply@meteor.com>\",\n  siteName: Meteor.absoluteUrl().replace(/^https?:\\/\\//, '').replace(/\\/$/, ''),\n\n  resetPassword: {\n    subject: function(user) {\n      return \"How to reset your password on \" + Accounts.emailTemplates.siteName;\n    },\n    text: function(user, url) {\n      var greeting = (user.profile && user.profile.name) ?\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\n      return `${greeting}\n\nTo reset your password, simply click the link below.\n\n${url}\n\nThanks.\n`;\n    }\n  },\n  verifyEmail: {\n    subject: function(user) {\n      return \"How to verify email address on \" + Accounts.emailTemplates.siteName;\n    },\n    text: greet(\"To verify your account email\")\n  },\n  enrollAccount: {\n    subject: function(user) {\n      return \"An account has been created for you on \" + Accounts.emailTemplates.siteName;\n    },\n    text: greet(\"To start using the service\")\n  }\n};\n","/// BCRYPT\n\nvar bcrypt = NpmModuleBcrypt;\nvar bcryptHash = Meteor.wrapAsync(bcrypt.hash);\nvar bcryptCompare = Meteor.wrapAsync(bcrypt.compare);\n\n// User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords (unless they have a 'services.password.srp'\n// field, in which case they will be upgraded to bcrypt the next time\n// they log in).\n//\n// When the client sends a password to the server, it can either be a\n// string (the plaintext password) or an object with keys 'digest' and\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n// that don't have access to SHA can just send plaintext passwords as\n// strings.\n//\n// When the server receives a plaintext password as a string, it always\n// hashes it with SHA256 before passing it into bcrypt. When the server\n// receives a password as an object, it asserts that the algorithm is\n// \"sha-256\" and then passes the digest to bcrypt.\n\n\nAccounts._bcryptRounds = 10;\n\n// Given a 'password' from the client, extract the string that we should\n// bcrypt. 'password' can be one of:\n//  - String (the plaintext password)\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n//\nvar getPasswordString = function (password) {\n  if (typeof password === \"string\") {\n    password = SHA256(password);\n  } else { // 'password' is an object\n    if (password.algorithm !== \"sha-256\") {\n      throw new Error(\"Invalid password hash algorithm. \" +\n                      \"Only 'sha-256' is allowed.\");\n    }\n    password = password.digest;\n  }\n  return password;\n};\n\n// Use bcrypt to hash the password for storage in the database.\n// `password` can be a string (in which case it will be run through\n// SHA256 before bcrypt) or an object with properties `digest` and\n// `algorithm` (in which case we bcrypt `password.digest`).\n//\nvar hashPassword = function (password) {\n  password = getPasswordString(password);\n  return bcryptHash(password, Accounts._bcryptRounds);\n};\n\n// Check whether the provided password matches the bcrypt'ed password in\n// the database user record. `password` can be a string (in which case\n// it will be run through SHA256 before bcrypt) or an object with\n// properties `digest` and `algorithm` (in which case we bcrypt\n// `password.digest`).\n//\nAccounts._checkPassword = function (user, password) {\n  var result = {\n    userId: user._id\n  };\n\n  password = getPasswordString(password);\n\n  if (! bcryptCompare(password, user.services.password.bcrypt)) {\n    result.error = new Meteor.Error(403, \"Incorrect password\");\n  }\n\n  return result;\n};\nvar checkPassword = Accounts._checkPassword;\n\n///\n/// LOGIN\n///\n\nAccounts._findUserByQuery = function (query) {\n  var user = null;\n\n  if (query.id) {\n    user = Meteor.users.findOne({ _id: query.id });\n  } else {\n    var fieldName;\n    var fieldValue;\n    if (query.username) {\n      fieldName = 'username';\n      fieldValue = query.username;\n    } else if (query.email) {\n      fieldName = 'emails.address';\n      fieldValue = query.email;\n    } else {\n      throw new Error(\"shouldn't happen (validation missed something)\");\n    }\n    var selector = {};\n    selector[fieldName] = fieldValue;\n    user = Meteor.users.findOne(selector);\n    // If user is not found, try a case insensitive lookup\n    if (!user) {\n      selector = selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);\n      var candidateUsers = Meteor.users.find(selector).fetch();\n      // No match if multiple candidates are found\n      if (candidateUsers.length === 1) {\n        user = candidateUsers[0];\n      }\n    }\n  }\n\n  return user;\n};\n\n/**\n * @summary Finds the user with the specified username.\n * First tries to match username case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} username The username to look for\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByUsername = function (username) {\n  return Accounts._findUserByQuery({\n    username: username\n  });\n};\n\n/**\n * @summary Finds the user with the specified email.\n * First tries to match email case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} email The email address to look for\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByEmail = function (email) {\n  return Accounts._findUserByQuery({\n    email: email\n  });\n};\n\n// Generates a MongoDB selector that can be used to perform a fast case\n// insensitive lookup for the given fieldName and string. Since MongoDB does\n// not support case insensitive indexes, and case insensitive regex queries\n// are slow, we construct a set of prefix selectors for all permutations of\n// the first 4 characters ourselves. We first attempt to matching against\n// these, and because 'prefix expression' regex queries do use indexes (see\n// http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),\n// this has been found to greatly improve performance (from 1200ms to 5ms in a\n// test with 1.000.000 users).\nvar selectorForFastCaseInsensitiveLookup = function (fieldName, string) {\n  // Performance seems to improve up to 4 prefix characters\n  var prefix = string.substring(0, Math.min(string.length, 4));\n  var orClause = _.map(generateCasePermutationsForString(prefix),\n    function (prefixPermutation) {\n      var selector = {};\n      selector[fieldName] =\n        new RegExp('^' + Meteor._escapeRegExp(prefixPermutation));\n      return selector;\n    });\n  var caseInsensitiveClause = {};\n  caseInsensitiveClause[fieldName] =\n    new RegExp('^' + Meteor._escapeRegExp(string) + '$', 'i')\n  return {$and: [{$or: orClause}, caseInsensitiveClause]};\n}\n\n// Generates permutations of all case variations of a given string.\nvar generateCasePermutationsForString = function (string) {\n  var permutations = [''];\n  for (var i = 0; i < string.length; i++) {\n    var ch = string.charAt(i);\n    permutations = _.flatten(_.map(permutations, function (prefix) {\n      var lowerCaseChar = ch.toLowerCase();\n      var upperCaseChar = ch.toUpperCase();\n      // Don't add unneccesary permutations when ch is not a letter\n      if (lowerCaseChar === upperCaseChar) {\n        return [prefix + ch];\n      } else {\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];\n      }\n    }));\n  }\n  return permutations;\n}\n\nvar checkForCaseInsensitiveDuplicates = function (fieldName, displayName, fieldValue, ownUserId) {\n  // Some tests need the ability to add users with the same case insensitive\n  // value, hence the _skipCaseInsensitiveChecksForTest check\n  var skipCheck = _.has(Accounts._skipCaseInsensitiveChecksForTest, fieldValue);\n\n  if (fieldValue && !skipCheck) {\n    var matchedUsers = Meteor.users.find(\n      selectorForFastCaseInsensitiveLookup(fieldName, fieldValue)).fetch();\n\n    if (matchedUsers.length > 0 &&\n        // If we don't have a userId yet, any match we find is a duplicate\n        (!ownUserId ||\n        // Otherwise, check to see if there are multiple matches or a match\n        // that is not us\n        (matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId))) {\n      throw new Meteor.Error(403, displayName + \" already exists.\");\n    }\n  }\n};\n\n// XXX maybe this belongs in the check package\nvar NonEmptyString = Match.Where(function (x) {\n  check(x, String);\n  return x.length > 0;\n});\n\nvar userQueryValidator = Match.Where(function (user) {\n  check(user, {\n    id: Match.Optional(NonEmptyString),\n    username: Match.Optional(NonEmptyString),\n    email: Match.Optional(NonEmptyString)\n  });\n  if (_.keys(user).length !== 1)\n    throw new Match.Error(\"User property must have exactly one field\");\n  return true;\n});\n\nvar passwordValidator = Match.OneOf(\n  String,\n  { digest: String, algorithm: String }\n);\n\n// Handler to login with a password.\n//\n// The Meteor client sets options.password to an object with keys\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n//\n// For other DDP clients which don't have access to SHA, the handler\n// also accepts the plaintext password in options.password as a string.\n//\n// (It might be nice if servers could turn the plaintext password\n// option off. Or maybe it should be opt-in, not opt-out?\n// Accounts.config option?)\n//\n// Note that neither password option is secure without SSL.\n//\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (! options.password || options.srp)\n    return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    password: passwordValidator\n  });\n\n\n  var user = Accounts._findUserByQuery(options.user);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  if (!user.services || !user.services.password ||\n      !(user.services.password.bcrypt || user.services.password.srp))\n    throw new Meteor.Error(403, \"User has no password set\");\n\n  if (!user.services.password.bcrypt) {\n    if (typeof options.password === \"string\") {\n      // The client has presented a plaintext password, and the user is\n      // not upgraded to bcrypt yet. We don't attempt to tell the client\n      // to upgrade to bcrypt, because it might be a standalone DDP\n      // client doesn't know how to do such a thing.\n      var verifier = user.services.password.srp;\n      var newVerifier = SRP.generateVerifier(options.password, {\n        identity: verifier.identity, salt: verifier.salt});\n\n      if (verifier.verifier !== newVerifier.verifier) {\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Incorrect password\")\n        };\n      }\n\n      return {userId: user._id};\n    } else {\n      // Tell the client to use the SRP upgrade process.\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n        format: 'srp',\n        identity: user.services.password.srp.identity\n      }));\n    }\n  }\n\n  return checkPassword(\n    user,\n    options.password\n  );\n});\n\n// Handler to login using the SRP upgrade path. To use this login\n// handler, the client must provide:\n//   - srp: H(identity + \":\" + password)\n//   - password: a string or an object with properties 'digest' and 'algorithm'\n//\n// We use `options.srp` to verify that the client knows the correct\n// password without doing a full SRP flow. Once we've checked that, we\n// upgrade the user to bcrypt and remove the SRP information from the\n// user document.\n//\n// The client ends up using this login handler after trying the normal\n// login handler (above), which throws an error telling the client to\n// try the SRP upgrade path.\n//\n// XXX COMPAT WITH 0.8.1.3\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (!options.srp || !options.password)\n    return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    srp: String,\n    password: passwordValidator\n  });\n\n  var user = Accounts._findUserByQuery(options.user);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  // Check to see if another simultaneous login has already upgraded\n  // the user record to bcrypt.\n  if (user.services && user.services.password && user.services.password.bcrypt)\n    return checkPassword(user, options.password);\n\n  if (!(user.services && user.services.password && user.services.password.srp))\n    throw new Meteor.Error(403, \"User has no password set\");\n\n  var v1 = user.services.password.srp.verifier;\n  var v2 = SRP.generateVerifier(\n    null,\n    {\n      hashedIdentityAndPassword: options.srp,\n      salt: user.services.password.srp.salt\n    }\n  ).verifier;\n  if (v1 !== v2)\n    return {\n      userId: user._id,\n      error: new Meteor.Error(403, \"Incorrect password\")\n    };\n\n  // Upgrade to bcrypt on successful login.\n  var salted = hashPassword(options.password);\n  Meteor.users.update(\n    user._id,\n    {\n      $unset: { 'services.password.srp': 1 },\n      $set: { 'services.password.bcrypt': salted }\n    }\n  );\n\n  return {userId: user._id};\n});\n\n\n///\n/// CHANGING\n///\n\n/**\n * @summary Change a user's username. Use this instead of updating the\n * database directly. The operation will fail if there is an existing user\n * with a username only differing in case.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newUsername A new username for the user.\n * @importFromPackage accounts-base\n */\nAccounts.setUsername = function (userId, newUsername) {\n  check(userId, NonEmptyString);\n  check(newUsername, NonEmptyString);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  var oldUsername = user.username;\n\n  // Perform a case insensitive check for duplicates before update\n  checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n\n  Meteor.users.update({_id: user._id}, {$set: {username: newUsername}});\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id}, {$set: {username: oldUsername}});\n    throw ex;\n  }\n};\n\n// Let the user change their own password if they know the old\n// password. `oldPassword` and `newPassword` should be objects with keys\n// `digest` and `algorithm` (representing the SHA256 of the password).\n//\n// XXX COMPAT WITH 0.8.1.3\n// Like the login method, if the user hasn't been upgraded from SRP to\n// bcrypt yet, then this method will throw an 'old password format'\n// error. The client should call the SRP upgrade login handler and then\n// retry this method again.\n//\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade\n// errors thrown. The reasoning for this is that clients using this\n// method directly will need to be updated anyway because we no longer\n// support the SRP flow that they would have been doing to use this\n// method previously.\nMeteor.methods({changePassword: function (oldPassword, newPassword) {\n  check(oldPassword, passwordValidator);\n  check(newPassword, passwordValidator);\n\n  if (!this.userId)\n    throw new Meteor.Error(401, \"Must be logged in\");\n\n  var user = Meteor.users.findOne(this.userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  if (!user.services || !user.services.password ||\n      (!user.services.password.bcrypt && !user.services.password.srp))\n    throw new Meteor.Error(403, \"User has no password set\");\n\n  if (! user.services.password.bcrypt) {\n    throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n      format: 'srp',\n      identity: user.services.password.srp.identity\n    }));\n  }\n\n  var result = checkPassword(user, oldPassword);\n  if (result.error)\n    throw result.error;\n\n  var hashed = hashPassword(newPassword);\n\n  // It would be better if this removed ALL existing tokens and replaced\n  // the token for the current connection with a new one, but that would\n  // be tricky, so we'll settle for just replacing all tokens other than\n  // the one for the current connection.\n  var currentToken = Accounts._getLoginToken(this.connection.id);\n  Meteor.users.update(\n    { _id: this.userId },\n    {\n      $set: { 'services.password.bcrypt': hashed },\n      $pull: {\n        'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }\n      },\n      $unset: { 'services.password.reset': 1 }\n    }\n  );\n\n  return {passwordChanged: true};\n}});\n\n\n// Force change the users password.\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n * @importFromPackage accounts-base\n */\nAccounts.setPassword = function (userId, newPlaintextPassword, options) {\n  options = _.extend({logout: true}, options);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  var update = {\n    $unset: {\n      'services.password.srp': 1, // XXX COMPAT WITH 0.8.1.3\n      'services.password.reset': 1\n    },\n    $set: {'services.password.bcrypt': hashPassword(newPlaintextPassword)}\n  };\n\n  if (options.logout) {\n    update.$unset['services.resume.loginTokens'] = 1;\n  }\n\n  Meteor.users.update({_id: user._id}, update);\n};\n\n\n///\n/// RESETTING VIA EMAIL\n///\n\n// Method called by a user to request a password reset email. This is\n// the start of the reset process.\nMeteor.methods({forgotPassword: function (options) {\n  check(options, {email: String});\n\n  var user = Accounts.findUserByEmail(options.email);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  const emails = _.pluck(user.emails || [], 'address');\n  const caseSensitiveEmail = _.find(emails, email => {\n    return email.toLowerCase() === options.email.toLowerCase();\n  });\n\n  Accounts.sendResetPasswordEmail(user._id, caseSensitiveEmail);\n}});\n\n// send the user an email with a link that when opened allows the user\n// to set a new password, without the old password.\n\n/**\n * @summary Send an email with a link the user can use to reset their password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @importFromPackage accounts-base\n */\nAccounts.sendResetPasswordEmail = function (userId, email) {\n  // Make sure the user exists, and email is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Error(\"Can't find user\");\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0])\n    email = user.emails[0].address;\n  // make sure we have a valid email\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email))\n    throw new Error(\"No such email for user.\");\n\n  var token = Random.secret();\n  var when = new Date();\n  var tokenRecord = {\n    token: token,\n    email: email,\n    when: when,\n    reason: 'reset'\n  };\n  Meteor.users.update(userId, {$set: {\n    \"services.password.reset\": tokenRecord\n  }});\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n\n  var resetPasswordUrl = Accounts.urls.resetPassword(token);\n\n  var options = {\n    to: email,\n    from: Accounts.emailTemplates.resetPassword.from\n      ? Accounts.emailTemplates.resetPassword.from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.resetPassword.subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates.resetPassword.text === 'function') {\n    options.text =\n      Accounts.emailTemplates.resetPassword.text(user, resetPasswordUrl);\n  }\n\n  if (typeof Accounts.emailTemplates.resetPassword.html === 'function')\n    options.html =\n      Accounts.emailTemplates.resetPassword.html(user, resetPasswordUrl);\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  Email.send(options);\n};\n\n// send the user an email informing them that their account was created, with\n// a link that when opened both marks their email as verified and forces them\n// to choose their password. The email must be one of the addresses in the\n// user's emails field, or undefined to pick the first email automatically.\n//\n// This is not called automatically. It must be called manually if you\n// want to use enrollment emails.\n\n/**\n * @summary Send an email with a link the user can use to set their initial password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @importFromPackage accounts-base\n */\nAccounts.sendEnrollmentEmail = function (userId, email) {\n  // XXX refactor! This is basically identical to sendResetPasswordEmail.\n\n  // Make sure the user exists, and email is in their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Error(\"Can't find user\");\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0])\n    email = user.emails[0].address;\n  // make sure we have a valid email\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email))\n    throw new Error(\"No such email for user.\");\n\n  var token = Random.secret();\n  var when = new Date();\n  var tokenRecord = {\n    token: token,\n    email: email,\n    when: when,\n    reason: 'enroll'\n  };\n  Meteor.users.update(userId, {$set: {\n    \"services.password.reset\": tokenRecord\n  }});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n\n  var enrollAccountUrl = Accounts.urls.enrollAccount(token);\n\n  var options = {\n    to: email,\n    from: Accounts.emailTemplates.enrollAccount.from\n      ? Accounts.emailTemplates.enrollAccount.from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.enrollAccount.subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates.enrollAccount.text === 'function') {\n    options.text =\n      Accounts.emailTemplates.enrollAccount.text(user, enrollAccountUrl);\n  }\n\n  if (typeof Accounts.emailTemplates.enrollAccount.html === 'function')\n    options.html =\n      Accounts.emailTemplates.enrollAccount.html(user, enrollAccountUrl);\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  Email.send(options);\n};\n\n\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n// the users password, and log them in.\nMeteor.methods({resetPassword: function (token, newPassword) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"resetPassword\",\n    arguments,\n    \"password\",\n    function () {\n      check(token, String);\n      check(newPassword, passwordValidator);\n\n      var user = Meteor.users.findOne({\n        \"services.password.reset.token\": token});\n      if (!user)\n        throw new Meteor.Error(403, \"Token expired\");\n      var when = user.services.password.reset.when;\n      var reason = user.services.password.reset.reason;\n      var tokenLifetimeMs = Accounts._getPasswordResetTokenLifetimeMs();\n      if (reason === \"enroll\") {\n        tokenLifetimeMs = Accounts._getPasswordEnrollTokenLifetimeMs();\n      }\n      var currentTimeMs = Date.now();\n      if ((currentTimeMs - when) > tokenLifetimeMs)\n        throw new Meteor.Error(403, \"Token expired\");\n      var email = user.services.password.reset.email;\n      if (!_.include(_.pluck(user.emails || [], 'address'), email))\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Token has invalid email address\")\n        };\n\n      var hashed = hashPassword(newPassword);\n\n      // NOTE: We're about to invalidate tokens on the user, who we might be\n      // logged in as. Make sure to avoid logging ourselves out if this\n      // happens. But also make sure not to leave the connection in a state\n      // of having a bad token set if things fail.\n      var oldToken = Accounts._getLoginToken(self.connection.id);\n      Accounts._setLoginToken(user._id, self.connection, null);\n      var resetToOldToken = function () {\n        Accounts._setLoginToken(user._id, self.connection, oldToken);\n      };\n\n      try {\n        // Update the user record by:\n        // - Changing the password to the new one\n        // - Forgetting about the reset token that was just used\n        // - Verifying their email, since they got the password reset via email.\n        var affectedRecords = Meteor.users.update(\n          {\n            _id: user._id,\n            'emails.address': email,\n            'services.password.reset.token': token\n          },\n          {$set: {'services.password.bcrypt': hashed,\n                  'emails.$.verified': true},\n           $unset: {'services.password.reset': 1,\n                    'services.password.srp': 1}});\n        if (affectedRecords !== 1)\n          return {\n            userId: user._id,\n            error: new Meteor.Error(403, \"Invalid email\")\n          };\n      } catch (err) {\n        resetToOldToken();\n        throw err;\n      }\n\n      // Replace all valid login tokens with new ones (changing\n      // password should invalidate existing sessions).\n      Accounts._clearAllLoginTokens(user._id);\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n///\n/// EMAIL VERIFICATION\n///\n\n\n// send the user an email with a link that when opened marks that\n// address as verified\n\n/**\n * @summary Send an email with a link the user can use verify their email address.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n * @importFromPackage accounts-base\n */\nAccounts.sendVerificationEmail = function (userId, address) {\n  // XXX Also generate a link using which someone can delete this\n  // account if they own said address but weren't those who created\n  // this account.\n\n  // Make sure the user exists, and address is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Error(\"Can't find user\");\n  // pick the first unverified address if we weren't passed an address.\n  if (!address) {\n    var email = _.find(user.emails || [],\n                       function (e) { return !e.verified; });\n    address = (email || {}).address;\n\n    if (!address) {\n      throw new Error(\"That user has no unverified email addresses.\");\n    }\n  }\n  // make sure we have a valid address\n  if (!address || !_.contains(_.pluck(user.emails || [], 'address'), address))\n    throw new Error(\"No such email address for user.\");\n\n\n  var tokenRecord = {\n    token: Random.secret(),\n    address: address,\n    when: new Date()};\n  Meteor.users.update(\n    {_id: userId},\n    {$push: {'services.email.verificationTokens': tokenRecord}});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'email');\n  if (!user.services.email.verificationTokens) {\n    user.services.email.verificationTokens = [];\n  }\n  user.services.email.verificationTokens.push(tokenRecord);\n\n  var verifyEmailUrl = Accounts.urls.verifyEmail(tokenRecord.token);\n\n  var options = {\n    to: address,\n    from: Accounts.emailTemplates.verifyEmail.from\n      ? Accounts.emailTemplates.verifyEmail.from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.verifyEmail.subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates.verifyEmail.text === 'function') {\n    options.text =\n      Accounts.emailTemplates.verifyEmail.text(user, verifyEmailUrl);\n  }\n\n  if (typeof Accounts.emailTemplates.verifyEmail.html === 'function')\n    options.html =\n      Accounts.emailTemplates.verifyEmail.html(user, verifyEmailUrl);\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  Email.send(options);\n};\n\n// Take token from sendVerificationEmail, mark the email as verified,\n// and log them in.\nMeteor.methods({verifyEmail: function (token) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"verifyEmail\",\n    arguments,\n    \"password\",\n    function () {\n      check(token, String);\n\n      var user = Meteor.users.findOne(\n        {'services.email.verificationTokens.token': token});\n      if (!user)\n        throw new Meteor.Error(403, \"Verify email link expired\");\n\n      var tokenRecord = _.find(user.services.email.verificationTokens,\n                               function (t) {\n                                 return t.token == token;\n                               });\n      if (!tokenRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link expired\")\n        };\n\n      var emailsRecord = _.find(user.emails, function (e) {\n        return e.address == tokenRecord.address;\n      });\n      if (!emailsRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n        };\n\n      // By including the address in the query, we can use 'emails.$' in the\n      // modifier to get a reference to the specific object in the emails\n      // array. See\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n      Meteor.users.update(\n        {_id: user._id,\n         'emails.address': tokenRecord.address},\n        {$set: {'emails.$.verified': true},\n         $pull: {'services.email.verificationTokens': {address: tokenRecord.address}}});\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n/**\n * @summary Add an email address for a user. Use this instead of directly\n * updating the database. The operation will fail if there is a different user\n * with an email only differing in case. If the specified user has an existing\n * email only differing in case however, we replace it.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newEmail A new email address for the user.\n * @param {Boolean} [verified] Optional - whether the new email address should\n * be marked as verified. Defaults to false.\n * @importFromPackage accounts-base\n */\nAccounts.addEmail = function (userId, newEmail, verified) {\n  check(userId, NonEmptyString);\n  check(newEmail, NonEmptyString);\n  check(verified, Match.Optional(Boolean));\n\n  if (_.isUndefined(verified)) {\n    verified = false;\n  }\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  // Allow users to change their own email to a version with a different case\n\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case\n  // insensitive check across all emails in the database here because: (1) if\n  // there is no case-insensitive duplicate between this user and other users,\n  // then we are OK and (2) if this would create a conflict with other users\n  // then there would already be a case-insensitive duplicate and we can't fix\n  // that in this code anyway.\n  var caseInsensitiveRegExp =\n    new RegExp('^' + Meteor._escapeRegExp(newEmail) + '$', 'i');\n\n  var didUpdateOwnEmail = _.any(user.emails, function(email, index) {\n    if (caseInsensitiveRegExp.test(email.address)) {\n      Meteor.users.update({\n        _id: user._id,\n        'emails.address': email.address\n      }, {$set: {\n        'emails.$.address': newEmail,\n        'emails.$.verified': verified\n      }});\n      return true;\n    }\n\n    return false;\n  });\n\n  // In the other updates below, we have to do another call to\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values\n  // were added to the database in the meantime. We don't have to do this for\n  // the case where the user is updating their email address to one that is the\n  // same as before, but only different because of capitalization. Read the\n  // big comment above to understand why.\n\n  if (didUpdateOwnEmail) {\n    return;\n  }\n\n  // Perform a case insensitive check for duplicates before update\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $addToSet: {\n      emails: {\n        address: newEmail,\n        verified: verified\n      }\n    }\n  });\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id},\n      {$pull: {emails: {address: newEmail}}});\n    throw ex;\n  }\n}\n\n/**\n * @summary Remove an email address for a user. Use this instead of updating\n * the database directly.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} email The email address to remove.\n * @importFromPackage accounts-base\n */\nAccounts.removeEmail = function (userId, email) {\n  check(userId, NonEmptyString);\n  check(email, NonEmptyString);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  Meteor.users.update({_id: user._id},\n    {$pull: {emails: {address: email}}});\n}\n\n///\n/// CREATING USERS\n///\n\n// Shared createUser function called from the createUser method, both\n// if originates in client or server code. Calls user provided hooks,\n// does the actual user insertion.\n//\n// returns the user id\nvar createUser = function (options) {\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n  // options.\n  check(options, Match.ObjectIncluding({\n    username: Match.Optional(String),\n    email: Match.Optional(String),\n    password: Match.Optional(passwordValidator)\n  }));\n\n  var username = options.username;\n  var email = options.email;\n  if (!username && !email)\n    throw new Meteor.Error(400, \"Need to set a username or email\");\n\n  var user = {services: {}};\n  if (options.password) {\n    var hashed = hashPassword(options.password);\n    user.services.password = { bcrypt: hashed };\n  }\n\n  if (username)\n    user.username = username;\n  if (email)\n    user.emails = [{address: email, verified: false}];\n\n  // Perform a case insensitive check before insert\n  checkForCaseInsensitiveDuplicates('username', 'Username', username);\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);\n\n  var userId = Accounts.insertUserDoc(options, user);\n  // Perform another check after insert, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);\n  } catch (ex) {\n    // Remove inserted user if the check fails\n    Meteor.users.remove(userId);\n    throw ex;\n  }\n  return userId;\n};\n\n// method for create user. Requests come from the client.\nMeteor.methods({createUser: function (options) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"createUser\",\n    arguments,\n    \"password\",\n    function () {\n      // createUser() above does more checking.\n      check(options, Object);\n      if (Accounts._options.forbidClientAccountCreation)\n        return {\n          error: new Meteor.Error(403, \"Signups forbidden\")\n        };\n\n      // Create user. result contains id and token.\n      var userId = createUser(options);\n      // safety belt. createUser is supposed to throw on error. send 500 error\n      // instead of sending a verification email with empty userid.\n      if (! userId)\n        throw new Error(\"createUser failed to insert new user\");\n\n      // If `Accounts._options.sendVerificationEmail` is set, register\n      // a token to verify the user's primary email, and send it to\n      // that address.\n      if (options.email && Accounts._options.sendVerificationEmail)\n        Accounts.sendVerificationEmail(userId, options.email);\n\n      // client gets logged in as the new user afterwards.\n      return {userId: userId};\n    }\n  );\n}});\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns userId or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\nAccounts.createUser = function (options, callback) {\n  options = _.clone(options);\n\n  // XXX allow an optional callback?\n  if (callback) {\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n  }\n\n  return createUser(options);\n};\n\n///\n/// PASSWORD-SPECIFIC INDEXES ON USERS\n///\nMeteor.users._ensureIndex('services.email.verificationTokens.token',\n                          {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('services.password.reset.token',\n                          {unique: 1, sparse: 1});\n"]}}]