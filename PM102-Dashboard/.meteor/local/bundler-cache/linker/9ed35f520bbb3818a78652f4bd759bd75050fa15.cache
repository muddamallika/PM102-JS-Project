[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar meteorBabelHelpers;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"babel-runtime\":{\"babel-runtime.js\":[\"meteor-babel-helpers\",\"regenerator-runtime\",function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/babel-runtime/babel-runtime.js                                                                 //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nvar hasOwn = Object.prototype.hasOwnProperty;                                                              // 1\nvar S = typeof Symbol === \"function\" ? Symbol : {};                                                        // 2\nvar iteratorSymbol = S.iterator || \"@@iterator\";                                                           // 3\n                                                                                                           // 4\nvar hasDefineProperty = false;                                                                             // 5\ntry {                                                                                                      // 6\n  // IE 8 has a broken Object.defineProperty, so feature-test by                                           // 7\n  // trying to call it.                                                                                    // 8\n  Object.defineProperty({}, 'x', {});                                                                      // 9\n  hasDefineProperty = true;                                                                                // 10\n} catch (e) {}                                                                                             // 11\n                                                                                                           // 12\nfunction defineProperties(target, props) {                                                                 // 13\n  for (var i = 0; i < props.length; i++) {                                                                 // 14\n    var descriptor = props[i];                                                                             // 15\n    descriptor.enumerable = descriptor.enumerable || false;                                                // 16\n    descriptor.configurable = true;                                                                        // 17\n    if (\"value\" in descriptor) descriptor.writable = true;                                                 // 18\n    Object.defineProperty(target, descriptor.key, descriptor);                                             // 19\n  }                                                                                                        // 20\n}                                                                                                          // 21\n                                                                                                           // 22\nexports.meteorBabelHelpers = require(\"meteor-babel-helpers\");                                              // 23\n                                                                                                           // 24\n// Returns true if a given absolute identifier will be provided at runtime                                 // 25\n// by the babel-runtime package.                                                                           // 26\nexports.checkHelper = function checkHelper(id) {                                                           // 27\n  var parts = id.split(\"/\");                                                                               // 28\n  var index = 0;                                                                                           // 29\n                                                                                                           // 30\n  // Skip over leading / and node_modules.                                                                 // 31\n  if (parts[index] === \"\") ++index;                                                                        // 32\n  if (parts[index] === \"node_modules\") ++index;                                                            // 33\n                                                                                                           // 34\n  if (parts[index] !== \"babel-runtime\") {                                                                  // 35\n    return false;                                                                                          // 36\n  }                                                                                                        // 37\n                                                                                                           // 38\n  // Skip over babel-runtime.                                                                              // 39\n  ++index;                                                                                                 // 40\n                                                                                                           // 41\n  if (parts.length - index === 2) {                                                                        // 42\n    return parts[index] === \"helpers\" &&                                                                   // 43\n      hasOwn.call(BabelRuntime, stripDotJS(parts[index + 1]));                                             // 44\n  }                                                                                                        // 45\n                                                                                                           // 46\n  if (parts.length - index === 1) {                                                                        // 47\n    return stripDotJS(parts[index]) === \"regenerator\";                                                     // 48\n  }                                                                                                        // 49\n                                                                                                           // 50\n  return false;                                                                                            // 51\n};                                                                                                         // 52\n                                                                                                           // 53\nfunction stripDotJS(name) {                                                                                // 54\n  return name.replace(/\\.js$/, \"\");                                                                        // 55\n}                                                                                                          // 56\n                                                                                                           // 57\nvar BabelRuntime = {                                                                                       // 58\n  // es6.templateLiterals                                                                                  // 59\n  // Constructs the object passed to the tag function in a tagged                                          // 60\n  // template literal.                                                                                     // 61\n  taggedTemplateLiteralLoose: function (strings, raw) {                                                    // 62\n    // Babel's own version of this calls Object.freeze on `strings` and                                    // 63\n    // `strings.raw`, but it doesn't seem worth the compatibility and                                      // 64\n    // performance concerns.  If you're writing code against this helper,                                  // 65\n    // don't add properties to these objects.                                                              // 66\n    strings.raw = raw;                                                                                     // 67\n    return strings;                                                                                        // 68\n  },                                                                                                       // 69\n                                                                                                           // 70\n  // es6.classes                                                                                           // 71\n  // Checks that a class constructor is being called with `new`, and throws                                // 72\n  // an error if it is not.                                                                                // 73\n  classCallCheck: function (instance, Constructor) {                                                       // 74\n    if (!(instance instanceof Constructor)) {                                                              // 75\n      throw new TypeError(\"Cannot call a class as a function\");                                            // 76\n    }                                                                                                      // 77\n  },                                                                                                       // 78\n                                                                                                           // 79\n  // es6.classes                                                                                           // 80\n  inherits: function (subClass, superClass) {                                                              // 81\n    if (typeof superClass !== \"function\" && superClass !== null) {                                         // 82\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }                                                                                                      // 84\n                                                                                                           // 85\n    if (superClass) {                                                                                      // 86\n      if (Object.create) {                                                                                 // 87\n        // All but IE 8                                                                                    // 88\n        subClass.prototype = Object.create(superClass.prototype, {                                         // 89\n          constructor: {                                                                                   // 90\n            value: subClass,                                                                               // 91\n            enumerable: false,                                                                             // 92\n            writable: true,                                                                                // 93\n            configurable: true                                                                             // 94\n          }                                                                                                // 95\n        });                                                                                                // 96\n      } else {                                                                                             // 97\n        // IE 8 path.  Slightly worse for modern browsers, because `constructor`                           // 98\n        // is enumerable and shows up in the inspector unnecessarily.                                      // 99\n        // It's not an \"own\" property of any instance though.                                              // 100\n        //                                                                                                 // 101\n        // For correctness when writing code,                                                              // 102\n        // don't enumerate all the own-and-inherited properties of an instance                             // 103\n        // of a class and expect not to find `constructor` (but who does that?).                           // 104\n        var F = function () {                                                                              // 105\n          this.constructor = subClass;                                                                     // 106\n        };                                                                                                 // 107\n        F.prototype = superClass.prototype;                                                                // 108\n        subClass.prototype = new F();                                                                      // 109\n      }                                                                                                    // 110\n                                                                                                           // 111\n      // For modern browsers, this would be `subClass.__proto__ = superClass`,                             // 112\n      // but IE <=10 don't support `__proto__`, and in this case the difference                            // 113\n      // would be detectable; code that works in modern browsers could easily                              // 114\n      // fail on IE 8 if we ever used the `__proto__` trick.                                               // 115\n      //                                                                                                   // 116\n      // There's no perfect way to make static methods inherited if they are                               // 117\n      // assigned after declaration of the classes.  The best we can do is                                 // 118\n      // to copy them.  In other words, when you write `class Foo                                          // 119\n      // extends Bar`, we copy the static methods from Bar onto Foo, but future                            // 120\n      // ones are not copied.                                                                              // 121\n      //                                                                                                   // 122\n      // For correctness when writing code, don't add static methods to a class                            // 123\n      // after you subclass it.                                                                            // 124\n                                                                                                           // 125\n      // The ecmascript-runtime package provides adequate polyfills for                                    // 126\n      // all of these Object.* functions (and Array#forEach), and anyone                                   // 127\n      // using babel-runtime is almost certainly using it because of the                                   // 128\n      // ecmascript package, which also implies ecmascript-runtime.                                        // 129\n      Object.getOwnPropertyNames(superClass).forEach(function (k) {                                        // 130\n        // This property descriptor dance preserves getter/setter behavior                                 // 131\n        // in browsers that support accessor properties (all except                                        // 132\n        // IE8). In IE8, the superClass can't have accessor properties                                     // 133\n        // anyway, so this code is still safe.                                                             // 134\n        var descriptor = Object.getOwnPropertyDescriptor(superClass, k);                                   // 135\n        if (descriptor && typeof descriptor === \"object\") {                                                // 136\n          if (Object.getOwnPropertyDescriptor(subClass, k)) {                                              // 137\n            // If subClass already has a property by this name, then it                                    // 138\n            // would not be inherited, so it should not be copied. This                                    // 139\n            // notably excludes properties like .prototype and .name.                                      // 140\n            return;                                                                                        // 141\n          }                                                                                                // 142\n                                                                                                           // 143\n          Object.defineProperty(subClass, k, descriptor);                                                  // 144\n        }                                                                                                  // 145\n      });                                                                                                  // 146\n    }                                                                                                      // 147\n  },                                                                                                       // 148\n                                                                                                           // 149\n  defineProperty: function (obj, key, value) {                                                             // 150\n    if (hasDefineProperty && (key in obj)) {                                                               // 151\n      Object.defineProperty(obj, key, {                                                                    // 152\n        value: value,                                                                                      // 153\n        enumerable: true,                                                                                  // 154\n        configurable: true,                                                                                // 155\n        writable: true                                                                                     // 156\n      });                                                                                                  // 157\n    } else {                                                                                               // 158\n      obj[key] = value;                                                                                    // 159\n    }                                                                                                      // 160\n                                                                                                           // 161\n    return obj;                                                                                            // 162\n  },                                                                                                       // 163\n                                                                                                           // 164\n  createClass: function (Constructor, protoProps, staticProps) {                                           // 165\n    if (! hasDefineProperty) {                                                                             // 166\n      // e.g. `class Foo { get bar() {} }`.  If you try to use getters and                                 // 167\n      // setters in IE 8, you will get a big nasty error, with or without                                  // 168\n      // Babel.  I don't know of any other syntax features besides getters                                 // 169\n      // and setters that will trigger this error.                                                         // 170\n      throw new Error(                                                                                     // 171\n        \"Your browser does not support this type of class property.  \" +                                   // 172\n          \"For example, Internet Explorer 8 does not support getters and \" +                               // 173\n          \"setters.\");                                                                                     // 174\n    }                                                                                                      // 175\n                                                                                                           // 176\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);                                   // 177\n    if (staticProps) defineProperties(Constructor, staticProps);                                           // 178\n    return Constructor;                                                                                    // 179\n  },                                                                                                       // 180\n                                                                                                           // 181\n  \"typeof\": function (obj) {                                                                               // 182\n    return obj && obj.constructor === Symbol ? \"symbol\" : typeof obj;                                      // 183\n  },                                                                                                       // 184\n                                                                                                           // 185\n  possibleConstructorReturn: function (self, call) {                                                       // 186\n    if (! self) {                                                                                          // 187\n      throw new ReferenceError(                                                                            // 188\n        \"this hasn't been initialised - super() hasn't been called\"                                        // 189\n      );                                                                                                   // 190\n    }                                                                                                      // 191\n                                                                                                           // 192\n    var callType = typeof call;                                                                            // 193\n    if (call &&                                                                                            // 194\n        callType === \"function\" ||                                                                         // 195\n        callType === \"object\") {                                                                           // 196\n      return call;                                                                                         // 197\n    }                                                                                                      // 198\n                                                                                                           // 199\n    return self;                                                                                           // 200\n  },                                                                                                       // 201\n                                                                                                           // 202\n  interopRequireDefault: function (obj) {                                                                  // 203\n    return obj && obj.__esModule ? obj : { 'default': obj };                                               // 204\n  },                                                                                                       // 205\n                                                                                                           // 206\n  interopRequireWildcard: function (obj) {                                                                 // 207\n    if (obj && obj.__esModule) {                                                                           // 208\n      return obj;                                                                                          // 209\n    }                                                                                                      // 210\n                                                                                                           // 211\n    var newObj = {};                                                                                       // 212\n                                                                                                           // 213\n    if (obj != null) {                                                                                     // 214\n      for (var key in obj) {                                                                               // 215\n        if (hasOwn.call(obj, key)) {                                                                       // 216\n          newObj[key] = obj[key];                                                                          // 217\n        }                                                                                                  // 218\n      }                                                                                                    // 219\n    }                                                                                                      // 220\n                                                                                                           // 221\n    newObj[\"default\"] = obj;                                                                               // 222\n    return newObj;                                                                                         // 223\n  },                                                                                                       // 224\n                                                                                                           // 225\n  interopExportWildcard: function (obj, defaults) {                                                        // 226\n    var newObj = defaults({}, obj);                                                                        // 227\n    delete newObj[\"default\"];                                                                              // 228\n    return newObj;                                                                                         // 229\n  },                                                                                                       // 230\n                                                                                                           // 231\n  defaults: function (obj, defaults) {                                                                     // 232\n    Object.getOwnPropertyNames(defaults).forEach(function (key) {                                          // 233\n      var desc = Object.getOwnPropertyDescriptor(defaults, key);                                           // 234\n      if (desc && desc.configurable && typeof obj[key] === \"undefined\") {                                  // 235\n        Object.defineProperty(obj, key, desc);                                                             // 236\n      }                                                                                                    // 237\n    });                                                                                                    // 238\n                                                                                                           // 239\n    return obj;                                                                                            // 240\n  },                                                                                                       // 241\n                                                                                                           // 242\n  // es7.objectRestSpread and react (JSX)                                                                  // 243\n  \"extends\": Object.assign || (function (target) {                                                         // 244\n    for (var i = 1; i < arguments.length; i++) {                                                           // 245\n      var source = arguments[i];                                                                           // 246\n      for (var key in source) {                                                                            // 247\n        if (hasOwn.call(source, key)) {                                                                    // 248\n          target[key] = source[key];                                                                       // 249\n        }                                                                                                  // 250\n      }                                                                                                    // 251\n    }                                                                                                      // 252\n    return target;                                                                                         // 253\n  }),                                                                                                      // 254\n                                                                                                           // 255\n  // es6.destructuring                                                                                     // 256\n  objectWithoutProperties: function (obj, keys) {                                                          // 257\n    var target = {};                                                                                       // 258\n    outer: for (var i in obj) {                                                                            // 259\n      if (! hasOwn.call(obj, i)) continue;                                                                 // 260\n      for (var j = 0; j < keys.length; j++) {                                                              // 261\n        if (keys[j] === i) continue outer;                                                                 // 262\n      }                                                                                                    // 263\n      target[i] = obj[i];                                                                                  // 264\n    }                                                                                                      // 265\n    return target;                                                                                         // 266\n  },                                                                                                       // 267\n                                                                                                           // 268\n  // es6.destructuring                                                                                     // 269\n  objectDestructuringEmpty: function (obj) {                                                               // 270\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");                                  // 271\n  },                                                                                                       // 272\n                                                                                                           // 273\n  // es6.spread                                                                                            // 274\n  bind: Function.prototype.bind || (function () {                                                          // 275\n    var isCallable = function (value) { return typeof value === 'function'; };                             // 276\n    var $Object = Object;                                                                                  // 277\n    var to_string = Object.prototype.toString;                                                             // 278\n    var array_slice = Array.prototype.slice;                                                               // 279\n    var array_concat = Array.prototype.concat;                                                             // 280\n    var array_push = Array.prototype.push;                                                                 // 281\n    var max = Math.max;                                                                                    // 282\n    var Empty = function Empty() {};                                                                       // 283\n                                                                                                           // 284\n    // Copied from es5-shim.js (3ac7942).  See original for more comments.                                 // 285\n    return function bind(that) {                                                                           // 286\n      var target = this;                                                                                   // 287\n      if (!isCallable(target)) {                                                                           // 288\n        throw new TypeError('Function.prototype.bind called on incompatible ' + target);                   // 289\n      }                                                                                                    // 290\n                                                                                                           // 291\n      var args = array_slice.call(arguments, 1);                                                           // 292\n                                                                                                           // 293\n      var bound;                                                                                           // 294\n      var binder = function () {                                                                           // 295\n                                                                                                           // 296\n        if (this instanceof bound) {                                                                       // 297\n          var result = target.apply(                                                                       // 298\n            this,                                                                                          // 299\n            array_concat.call(args, array_slice.call(arguments))                                           // 300\n          );                                                                                               // 301\n          if ($Object(result) === result) {                                                                // 302\n            return result;                                                                                 // 303\n          }                                                                                                // 304\n          return this;                                                                                     // 305\n        } else {                                                                                           // 306\n          return target.apply(                                                                             // 307\n            that,                                                                                          // 308\n            array_concat.call(args, array_slice.call(arguments))                                           // 309\n          );                                                                                               // 310\n        }                                                                                                  // 311\n      };                                                                                                   // 312\n                                                                                                           // 313\n      var boundLength = max(0, target.length - args.length);                                               // 314\n                                                                                                           // 315\n      var boundArgs = [];                                                                                  // 316\n      for (var i = 0; i < boundLength; i++) {                                                              // 317\n        array_push.call(boundArgs, '$' + i);                                                               // 318\n      }                                                                                                    // 319\n                                                                                                           // 320\n      // Create a Function from source code so that it has the right `.length`.                            // 321\n      // Probably not important for Babel.  This code violates CSPs that ban                               // 322\n      // `eval`, but the browsers that need this polyfill don't have CSP!                                  // 323\n      bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\n                                                                                                           // 325\n      if (target.prototype) {                                                                              // 326\n        Empty.prototype = target.prototype;                                                                // 327\n        bound.prototype = new Empty();                                                                     // 328\n        Empty.prototype = null;                                                                            // 329\n      }                                                                                                    // 330\n                                                                                                           // 331\n      return bound;                                                                                        // 332\n    };                                                                                                     // 333\n                                                                                                           // 334\n  })(),                                                                                                    // 335\n                                                                                                           // 336\n  toConsumableArray: function (arr) {                                                                      // 337\n    if (Array.isArray(arr)) {                                                                              // 338\n      for (var i = arr.length - 1, arr2 = Array(i + 1); i >= 0; --i) {                                     // 339\n        arr2[i] = arr[i];                                                                                  // 340\n      }                                                                                                    // 341\n                                                                                                           // 342\n      return arr2;                                                                                         // 343\n    }                                                                                                      // 344\n                                                                                                           // 345\n    return Array.from(arr);                                                                                // 346\n  },                                                                                                       // 347\n                                                                                                           // 348\n  toArray: function (arr) {                                                                                // 349\n    return Array.isArray(arr) ? arr : Array.from(arr);                                                     // 350\n  },                                                                                                       // 351\n                                                                                                           // 352\n  slicedToArray: function (iterable, limit) {                                                              // 353\n    if (Array.isArray(iterable)) {                                                                         // 354\n      return iterable;                                                                                     // 355\n    }                                                                                                      // 356\n                                                                                                           // 357\n    if (iterable) {                                                                                        // 358\n      var it = iterable[iteratorSymbol]();                                                                 // 359\n      var result = [];                                                                                     // 360\n      var info;                                                                                            // 361\n                                                                                                           // 362\n      if (typeof limit !== \"number\") {                                                                     // 363\n        limit = Infinity;                                                                                  // 364\n      }                                                                                                    // 365\n                                                                                                           // 366\n      while (result.length < limit &&                                                                      // 367\n             ! (info = it.next()).done) {                                                                  // 368\n        result.push(info.value);                                                                           // 369\n      }                                                                                                    // 370\n                                                                                                           // 371\n      return result;                                                                                       // 372\n    }                                                                                                      // 373\n                                                                                                           // 374\n    throw new TypeError(                                                                                   // 375\n      \"Invalid attempt to destructure non-iterable instance\"                                               // 376\n    );                                                                                                     // 377\n  },                                                                                                       // 378\n                                                                                                           // 379\n  slice: Array.prototype.slice                                                                             // 380\n};                                                                                                         // 381\n                                                                                                           // 382\n// Use meteorInstall to install all of the above helper functions within                                   // 383\n// node_modules/babel-runtime/helpers.                                                                     // 384\nObject.keys(BabelRuntime).forEach(function (helperName) {                                                  // 385\n  var helpers = {};                                                                                        // 386\n                                                                                                           // 387\n  helpers[helperName + \".js\"] = function (require, exports, module) {                                      // 388\n    module.exports = BabelRuntime[helperName];                                                             // 389\n  };                                                                                                       // 390\n                                                                                                           // 391\n  meteorInstall({                                                                                          // 392\n    node_modules: {                                                                                        // 393\n      \"babel-runtime\": {                                                                                   // 394\n        helpers: helpers                                                                                   // 395\n      }                                                                                                    // 396\n    }                                                                                                      // 397\n  });                                                                                                      // 398\n});                                                                                                        // 399\n                                                                                                           // 400\n// Use meteorInstall to install the regenerator runtime at                                                 // 401\n// node_modules/babel-runtime/regenerator.                                                                 // 402\nmeteorInstall({                                                                                            // 403\n  node_modules: {                                                                                          // 404\n    \"babel-runtime\": {                                                                                     // 405\n      \"regenerator.js\": function (r, e, module) {                                                          // 406\n        // Note that we use the require function provided to the                                           // 407\n        // babel-runtime.js file, not the one named 'r' above.                                             // 408\n        var runtime = require(\"regenerator-runtime\");                                                      // 409\n                                                                                                           // 410\n        // If Promise.asyncApply is defined, use it to wrap calls to                                       // 411\n        // runtime.async so that the entire async function will run in its                                 // 412\n        // own Fiber, not just the code that comes after the first await.                                  // 413\n        if (typeof Promise === \"function\" &&                                                               // 414\n            typeof Promise.asyncApply === \"function\") {                                                    // 415\n          var realAsync = runtime.async;                                                                   // 416\n          runtime.async = function () {                                                                    // 417\n            return Promise.asyncApply(realAsync, runtime, arguments);                                      // 418\n          };                                                                                               // 419\n        }                                                                                                  // 420\n                                                                                                           // 421\n        module.exports = runtime;                                                                          // 422\n      }                                                                                                    // 423\n    }                                                                                                      // 424\n  }                                                                                                        // 425\n});                                                                                                        // 426\n                                                                                                           // 427\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"meteor-babel-helpers\":{\"package.json\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// ../../.0.1.12.1fuj6pb++os+web.browser+web.cordova/npm/node_modules/meteor-babel-helpers/package.json    //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nexports.name = \"meteor-babel-helpers\";                                                                     // 1\nexports.version = \"0.0.3\";                                                                                 // 2\nexports.main = \"index.js\";                                                                                 // 3\n                                                                                                           // 4\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// node_modules/meteor/babel-runtime/node_modules/meteor-babel-helpers/index.js                            //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nfunction canDefineNonEnumerableProperties() {                                                              // 1\n  var testObj = {};                                                                                        // 2\n  var testPropName = \"t\";                                                                                  // 3\n                                                                                                           // 4\n  try {                                                                                                    // 5\n    Object.defineProperty(testObj, testPropName, {                                                         // 6\n      enumerable: false,                                                                                   // 7\n      value: testObj                                                                                       // 8\n    });                                                                                                    // 9\n                                                                                                           // 10\n    for (var k in testObj) {                                                                               // 11\n      if (k === testPropName) {                                                                            // 12\n        return false;                                                                                      // 13\n      }                                                                                                    // 14\n    }                                                                                                      // 15\n  } catch (e) {                                                                                            // 16\n    return false;                                                                                          // 17\n  }                                                                                                        // 18\n                                                                                                           // 19\n  return testObj[testPropName] === testObj;                                                                // 20\n}                                                                                                          // 21\n                                                                                                           // 22\nfunction sanitizeEasy(value) {                                                                             // 23\n  return value;                                                                                            // 24\n}                                                                                                          // 25\n                                                                                                           // 26\nfunction sanitizeHard(obj) {                                                                               // 27\n  if (Array.isArray(obj)) {                                                                                // 28\n    var newObj = {};                                                                                       // 29\n    var keys = Object.keys(obj);                                                                           // 30\n    var keyCount = keys.length;                                                                            // 31\n    for (var i = 0; i < keyCount; ++i) {                                                                   // 32\n      var key = keys[i];                                                                                   // 33\n      newObj[key] = obj[key];                                                                              // 34\n    }                                                                                                      // 35\n    return newObj;                                                                                         // 36\n  }                                                                                                        // 37\n                                                                                                           // 38\n  return obj;                                                                                              // 39\n}                                                                                                          // 40\n                                                                                                           // 41\nmeteorBabelHelpers = module.exports = {                                                                    // 42\n  // Meteor-specific runtime helper for wrapping the object of for-in                                      // 43\n  // loops, so that inherited Array methods defined by es5-shim can be                                     // 44\n  // ignored in browsers where they cannot be defined as non-enumerable.                                   // 45\n  sanitizeForInObject: canDefineNonEnumerableProperties()                                                  // 46\n    ? sanitizeEasy                                                                                         // 47\n    : sanitizeHard,                                                                                        // 48\n                                                                                                           // 49\n  // Exposed so that we can test sanitizeForInObject in environments that                                  // 50\n  // support defining non-enumerable properties.                                                           // 51\n  _sanitizeForInObjectHard: sanitizeHard                                                                   // 52\n};                                                                                                         // 53\n                                                                                                           // 54\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"regenerator-runtime\":{\"package.json\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// ../../.0.1.12.1fuj6pb++os+web.browser+web.cordova/npm/node_modules/regenerator-runtime/package.json     //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nexports.name = \"regenerator-runtime\";                                                                      // 1\nexports.version = \"0.9.5\";                                                                                 // 2\nexports.main = \"runtime-module.js\";                                                                        // 3\n                                                                                                           // 4\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"runtime-module.js\":[\"./runtime\",function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// node_modules/meteor/babel-runtime/node_modules/regenerator-runtime/runtime-module.js                    //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n// This method of obtaining a reference to the global object needs to be                                   // 1\n// kept identical to the way it is obtained in runtime.js                                                  // 2\nvar g =                                                                                                    // 3\n  typeof global === \"object\" ? global :                                                                    // 4\n  typeof window === \"object\" ? window :                                                                    // 5\n  typeof self === \"object\" ? self : this;                                                                  // 6\n                                                                                                           // 7\n// Use `getOwnPropertyNames` because not all browsers support calling                                      // 8\n// `hasOwnProperty` on the global `self` object in a worker. See #183.                                     // 9\nvar hadRuntime = g.regeneratorRuntime &&                                                                   // 10\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;                                        // 11\n                                                                                                           // 12\n// Save the old regeneratorRuntime in case it needs to be restored later.                                  // 13\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;                                                       // 14\n                                                                                                           // 15\n// Force reevalutation of runtime.js.                                                                      // 16\ng.regeneratorRuntime = undefined;                                                                          // 17\n                                                                                                           // 18\nmodule.exports = require(\"./runtime\");                                                                     // 19\n                                                                                                           // 20\nif (hadRuntime) {                                                                                          // 21\n  // Restore the original runtime.                                                                         // 22\n  g.regeneratorRuntime = oldRuntime;                                                                       // 23\n} else {                                                                                                   // 24\n  // Remove the global property added by runtime.js.                                                       // 25\n  try {                                                                                                    // 26\n    delete g.regeneratorRuntime;                                                                           // 27\n  } catch(e) {                                                                                             // 28\n    g.regeneratorRuntime = undefined;                                                                      // 29\n  }                                                                                                        // 30\n}                                                                                                          // 31\n                                                                                                           // 32\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"runtime.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// node_modules/meteor/babel-runtime/node_modules/regenerator-runtime/runtime.js                           //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n/**                                                                                                        // 1\n * Copyright (c) 2014, Facebook, Inc.                                                                      // 2\n * All rights reserved.                                                                                    // 3\n *                                                                                                         // 4\n * This source code is licensed under the BSD-style license found in the                                   // 5\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An                                     // 6\n * additional grant of patent rights can be found in the PATENTS file in                                   // 7\n * the same directory.                                                                                     // 8\n */                                                                                                        // 9\n                                                                                                           // 10\n!(function(global) {                                                                                       // 11\n  \"use strict\";                                                                                            // 12\n                                                                                                           // 13\n  var hasOwn = Object.prototype.hasOwnProperty;                                                            // 14\n  var undefined; // More compressible than void 0.                                                         // 15\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};                                                // 16\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";                                                   // 17\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";                                          // 18\n                                                                                                           // 19\n  var inModule = typeof module === \"object\";                                                               // 20\n  var runtime = global.regeneratorRuntime;                                                                 // 21\n  if (runtime) {                                                                                           // 22\n    if (inModule) {                                                                                        // 23\n      // If regeneratorRuntime is defined globally and we're in a module,                                  // 24\n      // make the exports object identical to regeneratorRuntime.                                          // 25\n      module.exports = runtime;                                                                            // 26\n    }                                                                                                      // 27\n    // Don't bother evaluating the rest of this file if the runtime was                                    // 28\n    // already defined globally.                                                                           // 29\n    return;                                                                                                // 30\n  }                                                                                                        // 31\n                                                                                                           // 32\n  // Define the runtime globally (as expected by generated code) as either                                 // 33\n  // module.exports (if we're in a module) or a new, empty object.                                         // 34\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};                                    // 35\n                                                                                                           // 36\n  function wrap(innerFn, outerFn, self, tryLocsList) {                                                     // 37\n    // If outerFn provided, then outerFn.prototype instanceof Generator.                                   // 38\n    var generator = Object.create((outerFn || Generator).prototype);                                       // 39\n    var context = new Context(tryLocsList || []);                                                          // 40\n                                                                                                           // 41\n    // The ._invoke method unifies the implementations of the .next,                                       // 42\n    // .throw, and .return methods.                                                                        // 43\n    generator._invoke = makeInvokeMethod(innerFn, self, context);                                          // 44\n                                                                                                           // 45\n    return generator;                                                                                      // 46\n  }                                                                                                        // 47\n  runtime.wrap = wrap;                                                                                     // 48\n                                                                                                           // 49\n  // Try/catch helper to minimize deoptimizations. Returns a completion                                    // 50\n  // record like context.tryEntries[i].completion. This interface could                                    // 51\n  // have been (and was previously) designed to take a closure to be                                       // 52\n  // invoked without arguments, but in all the cases we care about we                                      // 53\n  // already have an existing method we want to call, so there's no need                                   // 54\n  // to create a new function object. We can even get away with assuming                                   // 55\n  // the method takes exactly one argument, since that happens to be true                                  // 56\n  // in every case, so we don't have to touch the arguments object. The                                    // 57\n  // only additional allocation required is the completion record, which                                   // 58\n  // has a stable shape and so hopefully should be cheap to allocate.                                      // 59\n  function tryCatch(fn, obj, arg) {                                                                        // 60\n    try {                                                                                                  // 61\n      return { type: \"normal\", arg: fn.call(obj, arg) };                                                   // 62\n    } catch (err) {                                                                                        // 63\n      return { type: \"throw\", arg: err };                                                                  // 64\n    }                                                                                                      // 65\n  }                                                                                                        // 66\n                                                                                                           // 67\n  var GenStateSuspendedStart = \"suspendedStart\";                                                           // 68\n  var GenStateSuspendedYield = \"suspendedYield\";                                                           // 69\n  var GenStateExecuting = \"executing\";                                                                     // 70\n  var GenStateCompleted = \"completed\";                                                                     // 71\n                                                                                                           // 72\n  // Returning this object from the innerFn has the same effect as                                         // 73\n  // breaking out of the dispatch switch statement.                                                        // 74\n  var ContinueSentinel = {};                                                                               // 75\n                                                                                                           // 76\n  // Dummy constructor functions that we use as the .constructor and                                       // 77\n  // .constructor.prototype properties for functions that return Generator                                 // 78\n  // objects. For full spec compliance, you may wish to configure your                                     // 79\n  // minifier not to mangle the names of these two functions.                                              // 80\n  function Generator() {}                                                                                  // 81\n  function GeneratorFunction() {}                                                                          // 82\n  function GeneratorFunctionPrototype() {}                                                                 // 83\n                                                                                                           // 84\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;                                     // 85\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;                               // 86\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;                                              // 87\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\";     // 88\n                                                                                                           // 89\n  // Helper for defining the .next, .throw, and .return methods of the                                     // 90\n  // Iterator interface in terms of a single ._invoke method.                                              // 91\n  function defineIteratorMethods(prototype) {                                                              // 92\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {                                                 // 93\n      prototype[method] = function(arg) {                                                                  // 94\n        return this._invoke(method, arg);                                                                  // 95\n      };                                                                                                   // 96\n    });                                                                                                    // 97\n  }                                                                                                        // 98\n                                                                                                           // 99\n  runtime.isGeneratorFunction = function(genFun) {                                                         // 100\n    var ctor = typeof genFun === \"function\" && genFun.constructor;                                         // 101\n    return ctor                                                                                            // 102\n      ? ctor === GeneratorFunction ||                                                                      // 103\n        // For the native GeneratorFunction constructor, the best we can                                   // 104\n        // do is to check its .name property.                                                              // 105\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"                                            // 106\n      : false;                                                                                             // 107\n  };                                                                                                       // 108\n                                                                                                           // 109\n  runtime.mark = function(genFun) {                                                                        // 110\n    if (Object.setPrototypeOf) {                                                                           // 111\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);                                           // 112\n    } else {                                                                                               // 113\n      genFun.__proto__ = GeneratorFunctionPrototype;                                                       // 114\n      if (!(toStringTagSymbol in genFun)) {                                                                // 115\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";                                                   // 116\n      }                                                                                                    // 117\n    }                                                                                                      // 118\n    genFun.prototype = Object.create(Gp);                                                                  // 119\n    return genFun;                                                                                         // 120\n  };                                                                                                       // 121\n                                                                                                           // 122\n  // Within the body of any async function, `await x` is transformed to                                    // 123\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test                                     // 124\n  // `value instanceof AwaitArgument` to determine if the yielded value is                                 // 125\n  // meant to be awaited. Some may consider the name of this method too                                    // 126\n  // cutesy, but they are curmudgeons.                                                                     // 127\n  runtime.awrap = function(arg) {                                                                          // 128\n    return new AwaitArgument(arg);                                                                         // 129\n  };                                                                                                       // 130\n                                                                                                           // 131\n  function AwaitArgument(arg) {                                                                            // 132\n    this.arg = arg;                                                                                        // 133\n  }                                                                                                        // 134\n                                                                                                           // 135\n  function AsyncIterator(generator) {                                                                      // 136\n    function invoke(method, arg, resolve, reject) {                                                        // 137\n      var record = tryCatch(generator[method], generator, arg);                                            // 138\n      if (record.type === \"throw\") {                                                                       // 139\n        reject(record.arg);                                                                                // 140\n      } else {                                                                                             // 141\n        var result = record.arg;                                                                           // 142\n        var value = result.value;                                                                          // 143\n        if (value instanceof AwaitArgument) {                                                              // 144\n          return Promise.resolve(value.arg).then(function(value) {                                         // 145\n            invoke(\"next\", value, resolve, reject);                                                        // 146\n          }, function(err) {                                                                               // 147\n            invoke(\"throw\", err, resolve, reject);                                                         // 148\n          });                                                                                              // 149\n        }                                                                                                  // 150\n                                                                                                           // 151\n        return Promise.resolve(value).then(function(unwrapped) {                                           // 152\n          // When a yielded Promise is resolved, its final value becomes                                   // 153\n          // the .value of the Promise<{value,done}> result for the                                        // 154\n          // current iteration. If the Promise is rejected, however, the                                   // 155\n          // result for this iteration will be rejected with the same                                      // 156\n          // reason. Note that rejections of yielded Promises are not                                      // 157\n          // thrown back into the generator function, as is the case                                       // 158\n          // when an awaited Promise is rejected. This difference in                                       // 159\n          // behavior between yield and await is important, because it                                     // 160\n          // allows the consumer to decide what to do with the yielded                                     // 161\n          // rejection (swallow it and continue, manually .throw it back                                   // 162\n          // into the generator, abandon iteration, whatever). With                                        // 163\n          // await, by contrast, there is no opportunity to examine the                                    // 164\n          // rejection reason outside the generator function, so the                                       // 165\n          // only option is to throw it from the await expression, and                                     // 166\n          // let the generator function handle the exception.                                              // 167\n          result.value = unwrapped;                                                                        // 168\n          resolve(result);                                                                                 // 169\n        }, reject);                                                                                        // 170\n      }                                                                                                    // 171\n    }                                                                                                      // 172\n                                                                                                           // 173\n    if (typeof process === \"object\" && process.domain) {                                                   // 174\n      invoke = process.domain.bind(invoke);                                                                // 175\n    }                                                                                                      // 176\n                                                                                                           // 177\n    var previousPromise;                                                                                   // 178\n                                                                                                           // 179\n    function enqueue(method, arg) {                                                                        // 180\n      function callInvokeWithMethodAndArg() {                                                              // 181\n        return new Promise(function(resolve, reject) {                                                     // 182\n          invoke(method, arg, resolve, reject);                                                            // 183\n        });                                                                                                // 184\n      }                                                                                                    // 185\n                                                                                                           // 186\n      return previousPromise =                                                                             // 187\n        // If enqueue has been called before, then we want to wait until                                   // 188\n        // all previous Promises have been resolved before calling invoke,                                 // 189\n        // so that results are always delivered in the correct order. If                                   // 190\n        // enqueue has not been called before, then it is important to                                     // 191\n        // call invoke immediately, without waiting on a callback to fire,                                 // 192\n        // so that the async generator function has the opportunity to do                                  // 193\n        // any necessary setup in a predictable way. This predictability                                   // 194\n        // is why the Promise constructor synchronously invokes its                                        // 195\n        // executor callback, and why async functions synchronously                                        // 196\n        // execute code before the first await. Since we implement simple                                  // 197\n        // async functions in terms of async generators, it is especially                                  // 198\n        // important to get this right, even though it requires care.                                      // 199\n        previousPromise ? previousPromise.then(                                                            // 200\n          callInvokeWithMethodAndArg,                                                                      // 201\n          // Avoid propagating failures to Promises returned by later                                      // 202\n          // invocations of the iterator.                                                                  // 203\n          callInvokeWithMethodAndArg                                                                       // 204\n        ) : callInvokeWithMethodAndArg();                                                                  // 205\n    }                                                                                                      // 206\n                                                                                                           // 207\n    // Define the unified helper method that is used to implement .next,                                   // 208\n    // .throw, and .return (see defineIteratorMethods).                                                    // 209\n    this._invoke = enqueue;                                                                                // 210\n  }                                                                                                        // 211\n                                                                                                           // 212\n  defineIteratorMethods(AsyncIterator.prototype);                                                          // 213\n                                                                                                           // 214\n  // Note that simple async functions are implemented on top of                                            // 215\n  // AsyncIterator objects; they just return a Promise for the value of                                    // 216\n  // the final result produced by the iterator.                                                            // 217\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {                                          // 218\n    var iter = new AsyncIterator(                                                                          // 219\n      wrap(innerFn, outerFn, self, tryLocsList)                                                            // 220\n    );                                                                                                     // 221\n                                                                                                           // 222\n    return runtime.isGeneratorFunction(outerFn)                                                            // 223\n      ? iter // If outerFn is a generator, return the full iterator.                                       // 224\n      : iter.next().then(function(result) {                                                                // 225\n          return result.done ? result.value : iter.next();                                                 // 226\n        });                                                                                                // 227\n  };                                                                                                       // 228\n                                                                                                           // 229\n  function makeInvokeMethod(innerFn, self, context) {                                                      // 230\n    var state = GenStateSuspendedStart;                                                                    // 231\n                                                                                                           // 232\n    return function invoke(method, arg) {                                                                  // 233\n      if (state === GenStateExecuting) {                                                                   // 234\n        throw new Error(\"Generator is already running\");                                                   // 235\n      }                                                                                                    // 236\n                                                                                                           // 237\n      if (state === GenStateCompleted) {                                                                   // 238\n        if (method === \"throw\") {                                                                          // 239\n          throw arg;                                                                                       // 240\n        }                                                                                                  // 241\n                                                                                                           // 242\n        // Be forgiving, per 25.3.3.3.3 of the spec:                                                       // 243\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume                       // 244\n        return doneResult();                                                                               // 245\n      }                                                                                                    // 246\n                                                                                                           // 247\n      while (true) {                                                                                       // 248\n        var delegate = context.delegate;                                                                   // 249\n        if (delegate) {                                                                                    // 250\n          if (method === \"return\" ||                                                                       // 251\n              (method === \"throw\" && delegate.iterator[method] === undefined)) {                           // 252\n            // A return or throw (when the delegate iterator has no throw                                  // 253\n            // method) always terminates the yield* loop.                                                  // 254\n            context.delegate = null;                                                                       // 255\n                                                                                                           // 256\n            // If the delegate iterator has a return method, give it a                                     // 257\n            // chance to clean up.                                                                         // 258\n            var returnMethod = delegate.iterator[\"return\"];                                                // 259\n            if (returnMethod) {                                                                            // 260\n              var record = tryCatch(returnMethod, delegate.iterator, arg);                                 // 261\n              if (record.type === \"throw\") {                                                               // 262\n                // If the return method threw an exception, let that                                       // 263\n                // exception prevail over the original return or throw.                                    // 264\n                method = \"throw\";                                                                          // 265\n                arg = record.arg;                                                                          // 266\n                continue;                                                                                  // 267\n              }                                                                                            // 268\n            }                                                                                              // 269\n                                                                                                           // 270\n            if (method === \"return\") {                                                                     // 271\n              // Continue with the outer return, now that the delegate                                     // 272\n              // iterator has been terminated.                                                             // 273\n              continue;                                                                                    // 274\n            }                                                                                              // 275\n          }                                                                                                // 276\n                                                                                                           // 277\n          var record = tryCatch(                                                                           // 278\n            delegate.iterator[method],                                                                     // 279\n            delegate.iterator,                                                                             // 280\n            arg                                                                                            // 281\n          );                                                                                               // 282\n                                                                                                           // 283\n          if (record.type === \"throw\") {                                                                   // 284\n            context.delegate = null;                                                                       // 285\n                                                                                                           // 286\n            // Like returning generator.throw(uncaught), but without the                                   // 287\n            // overhead of an extra function call.                                                         // 288\n            method = \"throw\";                                                                              // 289\n            arg = record.arg;                                                                              // 290\n            continue;                                                                                      // 291\n          }                                                                                                // 292\n                                                                                                           // 293\n          // Delegate generator ran and handled its own exceptions so                                      // 294\n          // regardless of what the method was, we continue as if it is                                    // 295\n          // \"next\" with an undefined arg.                                                                 // 296\n          method = \"next\";                                                                                 // 297\n          arg = undefined;                                                                                 // 298\n                                                                                                           // 299\n          var info = record.arg;                                                                           // 300\n          if (info.done) {                                                                                 // 301\n            context[delegate.resultName] = info.value;                                                     // 302\n            context.next = delegate.nextLoc;                                                               // 303\n          } else {                                                                                         // 304\n            state = GenStateSuspendedYield;                                                                // 305\n            return info;                                                                                   // 306\n          }                                                                                                // 307\n                                                                                                           // 308\n          context.delegate = null;                                                                         // 309\n        }                                                                                                  // 310\n                                                                                                           // 311\n        if (method === \"next\") {                                                                           // 312\n          // Setting context._sent for legacy support of Babel's                                           // 313\n          // function.sent implementation.                                                                 // 314\n          context.sent = context._sent = arg;                                                              // 315\n                                                                                                           // 316\n        } else if (method === \"throw\") {                                                                   // 317\n          if (state === GenStateSuspendedStart) {                                                          // 318\n            state = GenStateCompleted;                                                                     // 319\n            throw arg;                                                                                     // 320\n          }                                                                                                // 321\n                                                                                                           // 322\n          if (context.dispatchException(arg)) {                                                            // 323\n            // If the dispatched exception was caught by a catch block,                                    // 324\n            // then let that catch block handle the exception normally.                                    // 325\n            method = \"next\";                                                                               // 326\n            arg = undefined;                                                                               // 327\n          }                                                                                                // 328\n                                                                                                           // 329\n        } else if (method === \"return\") {                                                                  // 330\n          context.abrupt(\"return\", arg);                                                                   // 331\n        }                                                                                                  // 332\n                                                                                                           // 333\n        state = GenStateExecuting;                                                                         // 334\n                                                                                                           // 335\n        var record = tryCatch(innerFn, self, context);                                                     // 336\n        if (record.type === \"normal\") {                                                                    // 337\n          // If an exception is thrown from innerFn, we leave state ===                                    // 338\n          // GenStateExecuting and loop back for another invocation.                                       // 339\n          state = context.done                                                                             // 340\n            ? GenStateCompleted                                                                            // 341\n            : GenStateSuspendedYield;                                                                      // 342\n                                                                                                           // 343\n          var info = {                                                                                     // 344\n            value: record.arg,                                                                             // 345\n            done: context.done                                                                             // 346\n          };                                                                                               // 347\n                                                                                                           // 348\n          if (record.arg === ContinueSentinel) {                                                           // 349\n            if (context.delegate && method === \"next\") {                                                   // 350\n              // Deliberately forget the last sent value so that we don't                                  // 351\n              // accidentally pass it on to the delegate.                                                  // 352\n              arg = undefined;                                                                             // 353\n            }                                                                                              // 354\n          } else {                                                                                         // 355\n            return info;                                                                                   // 356\n          }                                                                                                // 357\n                                                                                                           // 358\n        } else if (record.type === \"throw\") {                                                              // 359\n          state = GenStateCompleted;                                                                       // 360\n          // Dispatch the exception by looping back around to the                                          // 361\n          // context.dispatchException(arg) call above.                                                    // 362\n          method = \"throw\";                                                                                // 363\n          arg = record.arg;                                                                                // 364\n        }                                                                                                  // 365\n      }                                                                                                    // 366\n    };                                                                                                     // 367\n  }                                                                                                        // 368\n                                                                                                           // 369\n  // Define Generator.prototype.{next,throw,return} in terms of the                                        // 370\n  // unified ._invoke helper method.                                                                       // 371\n  defineIteratorMethods(Gp);                                                                               // 372\n                                                                                                           // 373\n  Gp[iteratorSymbol] = function() {                                                                        // 374\n    return this;                                                                                           // 375\n  };                                                                                                       // 376\n                                                                                                           // 377\n  Gp[toStringTagSymbol] = \"Generator\";                                                                     // 378\n                                                                                                           // 379\n  Gp.toString = function() {                                                                               // 380\n    return \"[object Generator]\";                                                                           // 381\n  };                                                                                                       // 382\n                                                                                                           // 383\n  function pushTryEntry(locs) {                                                                            // 384\n    var entry = { tryLoc: locs[0] };                                                                       // 385\n                                                                                                           // 386\n    if (1 in locs) {                                                                                       // 387\n      entry.catchLoc = locs[1];                                                                            // 388\n    }                                                                                                      // 389\n                                                                                                           // 390\n    if (2 in locs) {                                                                                       // 391\n      entry.finallyLoc = locs[2];                                                                          // 392\n      entry.afterLoc = locs[3];                                                                            // 393\n    }                                                                                                      // 394\n                                                                                                           // 395\n    this.tryEntries.push(entry);                                                                           // 396\n  }                                                                                                        // 397\n                                                                                                           // 398\n  function resetTryEntry(entry) {                                                                          // 399\n    var record = entry.completion || {};                                                                   // 400\n    record.type = \"normal\";                                                                                // 401\n    delete record.arg;                                                                                     // 402\n    entry.completion = record;                                                                             // 403\n  }                                                                                                        // 404\n                                                                                                           // 405\n  function Context(tryLocsList) {                                                                          // 406\n    // The root entry object (effectively a try statement without a catch                                  // 407\n    // or a finally block) gives us a place to store values thrown from                                    // 408\n    // locations where there is no enclosing try statement.                                                // 409\n    this.tryEntries = [{ tryLoc: \"root\" }];                                                                // 410\n    tryLocsList.forEach(pushTryEntry, this);                                                               // 411\n    this.reset(true);                                                                                      // 412\n  }                                                                                                        // 413\n                                                                                                           // 414\n  runtime.keys = function(object) {                                                                        // 415\n    var keys = [];                                                                                         // 416\n    for (var key in object) {                                                                              // 417\n      keys.push(key);                                                                                      // 418\n    }                                                                                                      // 419\n    keys.reverse();                                                                                        // 420\n                                                                                                           // 421\n    // Rather than returning an object with a next method, we keep                                         // 422\n    // things simple and return the next function itself.                                                  // 423\n    return function next() {                                                                               // 424\n      while (keys.length) {                                                                                // 425\n        var key = keys.pop();                                                                              // 426\n        if (key in object) {                                                                               // 427\n          next.value = key;                                                                                // 428\n          next.done = false;                                                                               // 429\n          return next;                                                                                     // 430\n        }                                                                                                  // 431\n      }                                                                                                    // 432\n                                                                                                           // 433\n      // To avoid creating an additional object, we just hang the .value                                   // 434\n      // and .done properties off the next function object itself. This                                    // 435\n      // also ensures that the minifier will not anonymize the function.                                   // 436\n      next.done = true;                                                                                    // 437\n      return next;                                                                                         // 438\n    };                                                                                                     // 439\n  };                                                                                                       // 440\n                                                                                                           // 441\n  function values(iterable) {                                                                              // 442\n    if (iterable) {                                                                                        // 443\n      var iteratorMethod = iterable[iteratorSymbol];                                                       // 444\n      if (iteratorMethod) {                                                                                // 445\n        return iteratorMethod.call(iterable);                                                              // 446\n      }                                                                                                    // 447\n                                                                                                           // 448\n      if (typeof iterable.next === \"function\") {                                                           // 449\n        return iterable;                                                                                   // 450\n      }                                                                                                    // 451\n                                                                                                           // 452\n      if (!isNaN(iterable.length)) {                                                                       // 453\n        var i = -1, next = function next() {                                                               // 454\n          while (++i < iterable.length) {                                                                  // 455\n            if (hasOwn.call(iterable, i)) {                                                                // 456\n              next.value = iterable[i];                                                                    // 457\n              next.done = false;                                                                           // 458\n              return next;                                                                                 // 459\n            }                                                                                              // 460\n          }                                                                                                // 461\n                                                                                                           // 462\n          next.value = undefined;                                                                          // 463\n          next.done = true;                                                                                // 464\n                                                                                                           // 465\n          return next;                                                                                     // 466\n        };                                                                                                 // 467\n                                                                                                           // 468\n        return next.next = next;                                                                           // 469\n      }                                                                                                    // 470\n    }                                                                                                      // 471\n                                                                                                           // 472\n    // Return an iterator with no values.                                                                  // 473\n    return { next: doneResult };                                                                           // 474\n  }                                                                                                        // 475\n  runtime.values = values;                                                                                 // 476\n                                                                                                           // 477\n  function doneResult() {                                                                                  // 478\n    return { value: undefined, done: true };                                                               // 479\n  }                                                                                                        // 480\n                                                                                                           // 481\n  Context.prototype = {                                                                                    // 482\n    constructor: Context,                                                                                  // 483\n                                                                                                           // 484\n    reset: function(skipTempReset) {                                                                       // 485\n      this.prev = 0;                                                                                       // 486\n      this.next = 0;                                                                                       // 487\n      // Resetting context._sent for legacy support of Babel's                                             // 488\n      // function.sent implementation.                                                                     // 489\n      this.sent = this._sent = undefined;                                                                  // 490\n      this.done = false;                                                                                   // 491\n      this.delegate = null;                                                                                // 492\n                                                                                                           // 493\n      this.tryEntries.forEach(resetTryEntry);                                                              // 494\n                                                                                                           // 495\n      if (!skipTempReset) {                                                                                // 496\n        for (var name in this) {                                                                           // 497\n          // Not sure about the optimal order of these conditions:                                         // 498\n          if (name.charAt(0) === \"t\" &&                                                                    // 499\n              hasOwn.call(this, name) &&                                                                   // 500\n              !isNaN(+name.slice(1))) {                                                                    // 501\n            this[name] = undefined;                                                                        // 502\n          }                                                                                                // 503\n        }                                                                                                  // 504\n      }                                                                                                    // 505\n    },                                                                                                     // 506\n                                                                                                           // 507\n    stop: function() {                                                                                     // 508\n      this.done = true;                                                                                    // 509\n                                                                                                           // 510\n      var rootEntry = this.tryEntries[0];                                                                  // 511\n      var rootRecord = rootEntry.completion;                                                               // 512\n      if (rootRecord.type === \"throw\") {                                                                   // 513\n        throw rootRecord.arg;                                                                              // 514\n      }                                                                                                    // 515\n                                                                                                           // 516\n      return this.rval;                                                                                    // 517\n    },                                                                                                     // 518\n                                                                                                           // 519\n    dispatchException: function(exception) {                                                               // 520\n      if (this.done) {                                                                                     // 521\n        throw exception;                                                                                   // 522\n      }                                                                                                    // 523\n                                                                                                           // 524\n      var context = this;                                                                                  // 525\n      function handle(loc, caught) {                                                                       // 526\n        record.type = \"throw\";                                                                             // 527\n        record.arg = exception;                                                                            // 528\n        context.next = loc;                                                                                // 529\n        return !!caught;                                                                                   // 530\n      }                                                                                                    // 531\n                                                                                                           // 532\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {                                              // 533\n        var entry = this.tryEntries[i];                                                                    // 534\n        var record = entry.completion;                                                                     // 535\n                                                                                                           // 536\n        if (entry.tryLoc === \"root\") {                                                                     // 537\n          // Exception thrown outside of any try block that could handle                                   // 538\n          // it, so set the completion value of the entire function to                                     // 539\n          // throw the exception.                                                                          // 540\n          return handle(\"end\");                                                                            // 541\n        }                                                                                                  // 542\n                                                                                                           // 543\n        if (entry.tryLoc <= this.prev) {                                                                   // 544\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");                                                   // 545\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");                                               // 546\n                                                                                                           // 547\n          if (hasCatch && hasFinally) {                                                                    // 548\n            if (this.prev < entry.catchLoc) {                                                              // 549\n              return handle(entry.catchLoc, true);                                                         // 550\n            } else if (this.prev < entry.finallyLoc) {                                                     // 551\n              return handle(entry.finallyLoc);                                                             // 552\n            }                                                                                              // 553\n                                                                                                           // 554\n          } else if (hasCatch) {                                                                           // 555\n            if (this.prev < entry.catchLoc) {                                                              // 556\n              return handle(entry.catchLoc, true);                                                         // 557\n            }                                                                                              // 558\n                                                                                                           // 559\n          } else if (hasFinally) {                                                                         // 560\n            if (this.prev < entry.finallyLoc) {                                                            // 561\n              return handle(entry.finallyLoc);                                                             // 562\n            }                                                                                              // 563\n                                                                                                           // 564\n          } else {                                                                                         // 565\n            throw new Error(\"try statement without catch or finally\");                                     // 566\n          }                                                                                                // 567\n        }                                                                                                  // 568\n      }                                                                                                    // 569\n    },                                                                                                     // 570\n                                                                                                           // 571\n    abrupt: function(type, arg) {                                                                          // 572\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {                                              // 573\n        var entry = this.tryEntries[i];                                                                    // 574\n        if (entry.tryLoc <= this.prev &&                                                                   // 575\n            hasOwn.call(entry, \"finallyLoc\") &&                                                            // 576\n            this.prev < entry.finallyLoc) {                                                                // 577\n          var finallyEntry = entry;                                                                        // 578\n          break;                                                                                           // 579\n        }                                                                                                  // 580\n      }                                                                                                    // 581\n                                                                                                           // 582\n      if (finallyEntry &&                                                                                  // 583\n          (type === \"break\" ||                                                                             // 584\n           type === \"continue\") &&                                                                         // 585\n          finallyEntry.tryLoc <= arg &&                                                                    // 586\n          arg <= finallyEntry.finallyLoc) {                                                                // 587\n        // Ignore the finally entry if control is not jumping to a                                         // 588\n        // location outside the try/catch block.                                                           // 589\n        finallyEntry = null;                                                                               // 590\n      }                                                                                                    // 591\n                                                                                                           // 592\n      var record = finallyEntry ? finallyEntry.completion : {};                                            // 593\n      record.type = type;                                                                                  // 594\n      record.arg = arg;                                                                                    // 595\n                                                                                                           // 596\n      if (finallyEntry) {                                                                                  // 597\n        this.next = finallyEntry.finallyLoc;                                                               // 598\n      } else {                                                                                             // 599\n        this.complete(record);                                                                             // 600\n      }                                                                                                    // 601\n                                                                                                           // 602\n      return ContinueSentinel;                                                                             // 603\n    },                                                                                                     // 604\n                                                                                                           // 605\n    complete: function(record, afterLoc) {                                                                 // 606\n      if (record.type === \"throw\") {                                                                       // 607\n        throw record.arg;                                                                                  // 608\n      }                                                                                                    // 609\n                                                                                                           // 610\n      if (record.type === \"break\" ||                                                                       // 611\n          record.type === \"continue\") {                                                                    // 612\n        this.next = record.arg;                                                                            // 613\n      } else if (record.type === \"return\") {                                                               // 614\n        this.rval = record.arg;                                                                            // 615\n        this.next = \"end\";                                                                                 // 616\n      } else if (record.type === \"normal\" && afterLoc) {                                                   // 617\n        this.next = afterLoc;                                                                              // 618\n      }                                                                                                    // 619\n    },                                                                                                     // 620\n                                                                                                           // 621\n    finish: function(finallyLoc) {                                                                         // 622\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {                                              // 623\n        var entry = this.tryEntries[i];                                                                    // 624\n        if (entry.finallyLoc === finallyLoc) {                                                             // 625\n          this.complete(entry.completion, entry.afterLoc);                                                 // 626\n          resetTryEntry(entry);                                                                            // 627\n          return ContinueSentinel;                                                                         // 628\n        }                                                                                                  // 629\n      }                                                                                                    // 630\n    },                                                                                                     // 631\n                                                                                                           // 632\n    \"catch\": function(tryLoc) {                                                                            // 633\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {                                              // 634\n        var entry = this.tryEntries[i];                                                                    // 635\n        if (entry.tryLoc === tryLoc) {                                                                     // 636\n          var record = entry.completion;                                                                   // 637\n          if (record.type === \"throw\") {                                                                   // 638\n            var thrown = record.arg;                                                                       // 639\n            resetTryEntry(entry);                                                                          // 640\n          }                                                                                                // 641\n          return thrown;                                                                                   // 642\n        }                                                                                                  // 643\n      }                                                                                                    // 644\n                                                                                                           // 645\n      // The context.catch method must only be called with a location                                      // 646\n      // argument that corresponds to a known catch block.                                                 // 647\n      throw new Error(\"illegal catch attempt\");                                                            // 648\n    },                                                                                                     // 649\n                                                                                                           // 650\n    delegateYield: function(iterable, resultName, nextLoc) {                                               // 651\n      this.delegate = {                                                                                    // 652\n        iterator: values(iterable),                                                                        // 653\n        resultName: resultName,                                                                            // 654\n        nextLoc: nextLoc                                                                                   // 655\n      };                                                                                                   // 656\n                                                                                                           // 657\n      return ContinueSentinel;                                                                             // 658\n    }                                                                                                      // 659\n  };                                                                                                       // 660\n})(                                                                                                        // 661\n  // Among the various tricks for obtaining a reference to the global                                      // 662\n  // object, this seems to be the most reliable technique that does not                                    // 663\n  // use indirect eval (which violates Content Security Policy).                                           // 664\n  typeof global === \"object\" ? global :                                                                    // 665\n  typeof window === \"object\" ? window :                                                                    // 666\n  typeof self === \"object\" ? self : this                                                                   // 667\n);                                                                                                         // 668\n                                                                                                           // 669\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}},{\"extensions\":[\".js\",\".json\"]});\nvar exports = require(\"./node_modules/meteor/babel-runtime/babel-runtime.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['babel-runtime'] = exports, {\n  meteorBabelHelpers: meteorBabelHelpers\n});\n\n})();\n","servePath":"/packages/babel-runtime.js"}]