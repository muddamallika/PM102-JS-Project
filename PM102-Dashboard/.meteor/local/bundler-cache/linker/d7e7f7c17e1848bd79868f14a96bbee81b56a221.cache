[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Random = Package.random.Random;\nvar EJSON = Package.ejson.EJSON;\nvar _ = Package.underscore._;\nvar Retry = Package.retry.Retry;\nvar MongoID = Package['mongo-id'].MongoID;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar DDPCommon = Package['ddp-common'].DDPCommon;\nvar DDP = Package['ddp-client'].DDP;\nvar WebApp = Package.webapp.WebApp;\nvar main = Package.webapp.main;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar RoutePolicy = Package.routepolicy.RoutePolicy;\nvar Hook = Package['callback-hook'].Hook;\nvar LocalCollection = Package.minimongo.LocalCollection;\nvar Minimongo = Package.minimongo.Minimongo;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar Symbol = Package['ecmascript-runtime'].Symbol;\nvar Map = Package['ecmascript-runtime'].Map;\nvar Set = Package['ecmascript-runtime'].Set;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar StreamServer, DDPServer, Server;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"ddp-server\":{\"stream_server.js\":function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-server/stream_server.js                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar url = Npm.require('url');                                                                                        // 1\n                                                                                                                     //\n// By default, we use the permessage-deflate extension with default                                                  // 3\n// configuration. If $SERVER_WEBSOCKET_COMPRESSION is set, then it must be valid                                     // 4\n// JSON. If it represents a falsey value, then we do not use permessage-deflate                                      // 5\n// at all; otherwise, the JSON value is used as an argument to deflate's                                             // 6\n// configure method; see                                                                                             // 7\n// https://github.com/faye/permessage-deflate-node/blob/master/README.md                                             // 8\n//                                                                                                                   // 9\n// (We do this in an _.once instead of at startup, because we don't want to                                          // 10\n// crash the tool during isopacket load if your JSON doesn't parse. This is only                                     // 11\n// a problem because the tool has to load the DDP server code just in order to                                       // 12\n// be a DDP client; see https://github.com/meteor/meteor/issues/3452 .)                                              // 13\nvar websocketExtensions = _.once(function () {                                                                       // 14\n  var extensions = [];                                                                                               // 15\n                                                                                                                     //\n  var websocketCompressionConfig = process.env.SERVER_WEBSOCKET_COMPRESSION ? JSON.parse(process.env.SERVER_WEBSOCKET_COMPRESSION) : {};\n  if (websocketCompressionConfig) {                                                                                  // 19\n    extensions.push(Npm.require('permessage-deflate').configure(websocketCompressionConfig));                        // 20\n  }                                                                                                                  // 23\n                                                                                                                     //\n  return extensions;                                                                                                 // 25\n});                                                                                                                  // 26\n                                                                                                                     //\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || \"\";                                               // 28\n                                                                                                                     //\nStreamServer = function StreamServer() {                                                                             // 30\n  var self = this;                                                                                                   // 31\n  self.registration_callbacks = [];                                                                                  // 32\n  self.open_sockets = [];                                                                                            // 33\n                                                                                                                     //\n  // Because we are installing directly onto WebApp.httpServer instead of using                                      // 35\n  // WebApp.app, we have to process the path prefix ourselves.                                                       // 36\n  self.prefix = pathPrefix + '/sockjs';                                                                              // 37\n  RoutePolicy.declare(self.prefix + '/', 'network');                                                                 // 38\n                                                                                                                     //\n  // set up sockjs                                                                                                   // 40\n  var sockjs = Npm.require('sockjs');                                                                                // 41\n  var serverOptions = {                                                                                              // 42\n    prefix: self.prefix,                                                                                             // 43\n    log: function () {                                                                                               // 44\n      function log() {}                                                                                              // 44\n                                                                                                                     //\n      return log;                                                                                                    // 44\n    }(),                                                                                                             // 44\n    // this is the default, but we code it explicitly because we depend                                              // 45\n    // on it in stream_client:HEARTBEAT_TIMEOUT                                                                      // 46\n    heartbeat_delay: 45000,                                                                                          // 47\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU                                      // 48\n    // bound for that much time, SockJS might not notice that the user has                                           // 49\n    // reconnected because the timer (of disconnect_delay ms) can fire before                                        // 50\n    // SockJS processes the new connection. Eventually we'll fix this by not                                         // 51\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which                                      // 52\n    // converts to Unix sockets) but for now, raise the delay.                                                       // 53\n    disconnect_delay: 60 * 1000,                                                                                     // 54\n    // Set the USE_JSESSIONID environment variable to enable setting the                                             // 55\n    // JSESSIONID cookie. This is useful for setting up proxies with                                                 // 56\n    // session affinity.                                                                                             // 57\n    jsessionid: !!process.env.USE_JSESSIONID                                                                         // 58\n  };                                                                                                                 // 42\n                                                                                                                     //\n  // If you know your server environment (eg, proxies) will prevent websockets                                       // 61\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,                                              // 62\n  // browsers) will not waste time attempting to use them.                                                           // 63\n  // (Your server will still have a /websocket endpoint.)                                                            // 64\n  if (process.env.DISABLE_WEBSOCKETS) {                                                                              // 65\n    serverOptions.websocket = false;                                                                                 // 66\n  } else {                                                                                                           // 67\n    serverOptions.faye_server_options = {                                                                            // 68\n      extensions: websocketExtensions()                                                                              // 69\n    };                                                                                                               // 68\n  }                                                                                                                  // 71\n                                                                                                                     //\n  self.server = sockjs.createServer(serverOptions);                                                                  // 73\n                                                                                                                     //\n  // Install the sockjs handlers, but we want to keep around our own particular                                      // 75\n  // request handler that adjusts idle timeouts while we have an outstanding                                         // 76\n  // request.  This compensates for the fact that sockjs removes all listeners                                       // 77\n  // for \"request\" to add its own.                                                                                   // 78\n  WebApp.httpServer.removeListener('request', WebApp._timeoutAdjustmentRequestCallback);                             // 79\n  self.server.installHandlers(WebApp.httpServer);                                                                    // 81\n  WebApp.httpServer.addListener('request', WebApp._timeoutAdjustmentRequestCallback);                                // 82\n                                                                                                                     //\n  // Support the /websocket endpoint                                                                                 // 85\n  self._redirectWebsocketEndpoint();                                                                                 // 86\n                                                                                                                     //\n  self.server.on('connection', function (socket) {                                                                   // 88\n    socket.send = function (data) {                                                                                  // 89\n      socket.write(data);                                                                                            // 90\n    };                                                                                                               // 91\n    socket.on('close', function () {                                                                                 // 92\n      self.open_sockets = _.without(self.open_sockets, socket);                                                      // 93\n    });                                                                                                              // 94\n    self.open_sockets.push(socket);                                                                                  // 95\n                                                                                                                     //\n    // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which                                              // 97\n    // will force old clients to reload. Remove this once we're not                                                  // 98\n    // concerned about people upgrading from a pre-0.7.0 release. Also,                                              // 99\n    // remove the clause in the client that ignores the welcome message                                              // 100\n    // (livedata_connection.js)                                                                                      // 101\n    socket.send(JSON.stringify({ server_id: \"0\" }));                                                                 // 102\n                                                                                                                     //\n    // call all our callbacks when we get a new socket. they will do the                                             // 104\n    // work of setting up handlers and such for specific messages.                                                   // 105\n    _.each(self.registration_callbacks, function (callback) {                                                        // 106\n      callback(socket);                                                                                              // 107\n    });                                                                                                              // 108\n  });                                                                                                                // 109\n};                                                                                                                   // 111\n                                                                                                                     //\n_.extend(StreamServer.prototype, {                                                                                   // 113\n  // call my callback when a new socket connects.                                                                    // 114\n  // also call it for all current connections.                                                                       // 115\n  register: function () {                                                                                            // 116\n    function register(callback) {                                                                                    // 116\n      var self = this;                                                                                               // 117\n      self.registration_callbacks.push(callback);                                                                    // 118\n      _.each(self.all_sockets(), function (socket) {                                                                 // 119\n        callback(socket);                                                                                            // 120\n      });                                                                                                            // 121\n    }                                                                                                                // 122\n                                                                                                                     //\n    return register;                                                                                                 // 116\n  }(),                                                                                                               // 116\n                                                                                                                     //\n  // get a list of all sockets                                                                                       // 124\n  all_sockets: function () {                                                                                         // 125\n    function all_sockets() {                                                                                         // 125\n      var self = this;                                                                                               // 126\n      return _.values(self.open_sockets);                                                                            // 127\n    }                                                                                                                // 128\n                                                                                                                     //\n    return all_sockets;                                                                                              // 125\n  }(),                                                                                                               // 125\n                                                                                                                     //\n  // Redirect /websocket to /sockjs/websocket in order to not expose                                                 // 130\n  // sockjs to clients that want to use raw websockets                                                               // 131\n  _redirectWebsocketEndpoint: function () {                                                                          // 132\n    function _redirectWebsocketEndpoint() {                                                                          // 132\n      var self = this;                                                                                               // 133\n      // Unfortunately we can't use a connect middleware here since                                                  // 134\n      // sockjs installs itself prior to all existing listeners                                                      // 135\n      // (meaning prior to any connect middlewares) so we need to take                                               // 136\n      // an approach similar to overshadowListeners in                                                               // 137\n      // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee        // 138\n      _.each(['request', 'upgrade'], function (event) {                                                              // 139\n        var httpServer = WebApp.httpServer;                                                                          // 140\n        var oldHttpServerListeners = httpServer.listeners(event).slice(0);                                           // 141\n        httpServer.removeAllListeners(event);                                                                        // 142\n                                                                                                                     //\n        // request and upgrade have different arguments passed but                                                   // 144\n        // we only care about the first one which is always request                                                  // 145\n        var newListener = function () {                                                                              // 146\n          function newListener(request /*, moreArguments */) {                                                       // 146\n            // Store arguments for use within the closure below                                                      // 147\n            var args = arguments;                                                                                    // 148\n                                                                                                                     //\n            // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while                                    // 150\n            // preserving query string.                                                                              // 151\n            var parsedUrl = url.parse(request.url);                                                                  // 152\n            if (parsedUrl.pathname === pathPrefix + '/websocket' || parsedUrl.pathname === pathPrefix + '/websocket/') {\n              parsedUrl.pathname = self.prefix + '/websocket';                                                       // 155\n              request.url = url.format(parsedUrl);                                                                   // 156\n            }                                                                                                        // 157\n            _.each(oldHttpServerListeners, function (oldListener) {                                                  // 158\n              oldListener.apply(httpServer, args);                                                                   // 159\n            });                                                                                                      // 160\n          }                                                                                                          // 161\n                                                                                                                     //\n          return newListener;                                                                                        // 146\n        }();                                                                                                         // 146\n        httpServer.addListener(event, newListener);                                                                  // 162\n      });                                                                                                            // 163\n    }                                                                                                                // 164\n                                                                                                                     //\n    return _redirectWebsocketEndpoint;                                                                               // 132\n  }()                                                                                                                // 132\n});                                                                                                                  // 113\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"livedata_server.js\":[\"babel-runtime/helpers/typeof\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-server/livedata_server.js                                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});                        //\nDDPServer = {};                                                                                                      // 1\n                                                                                                                     //\nvar Fiber = Npm.require('fibers');                                                                                   // 3\n                                                                                                                     //\n// This file contains classes:                                                                                       // 5\n// * Session - The server's connection to a single DDP client                                                        // 6\n// * Subscription - A single subscription for a single client                                                        // 7\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.                                          // 8\n//                                                                                                                   // 9\n// Session and Subscription are file scope. For now, until we freeze                                                 // 10\n// the interface, Server is package scope (in the future it should be                                                // 11\n// exported.)                                                                                                        // 12\n                                                                                                                     //\n// Represents a single document in a SessionCollectionView                                                           // 14\nvar SessionDocumentView = function SessionDocumentView() {                                                           // 15\n  var self = this;                                                                                                   // 16\n  self.existsIn = {}; // set of subscriptionHandle                                                                   // 17\n  self.dataByKey = {}; // key-> [ {subscriptionHandle, value} by precedence]                                         // 18\n};                                                                                                                   // 19\n                                                                                                                     //\nDDPServer._SessionDocumentView = SessionDocumentView;                                                                // 21\n                                                                                                                     //\n_.extend(SessionDocumentView.prototype, {                                                                            // 24\n                                                                                                                     //\n  getFields: function () {                                                                                           // 26\n    function getFields() {                                                                                           // 26\n      var self = this;                                                                                               // 27\n      var ret = {};                                                                                                  // 28\n      _.each(self.dataByKey, function (precedenceList, key) {                                                        // 29\n        ret[key] = precedenceList[0].value;                                                                          // 30\n      });                                                                                                            // 31\n      return ret;                                                                                                    // 32\n    }                                                                                                                // 33\n                                                                                                                     //\n    return getFields;                                                                                                // 26\n  }(),                                                                                                               // 26\n                                                                                                                     //\n  clearField: function () {                                                                                          // 35\n    function clearField(subscriptionHandle, key, changeCollector) {                                                  // 35\n      var self = this;                                                                                               // 36\n      // Publish API ignores _id if present in fields                                                                // 37\n      if (key === \"_id\") return;                                                                                     // 38\n      var precedenceList = self.dataByKey[key];                                                                      // 40\n                                                                                                                     //\n      // It's okay to clear fields that didn't exist. No need to throw                                               // 42\n      // an error.                                                                                                   // 43\n      if (!precedenceList) return;                                                                                   // 44\n                                                                                                                     //\n      var removedValue = undefined;                                                                                  // 47\n      for (var i = 0; i < precedenceList.length; i++) {                                                              // 48\n        var precedence = precedenceList[i];                                                                          // 49\n        if (precedence.subscriptionHandle === subscriptionHandle) {                                                  // 50\n          // The view's value can only change if this subscription is the one that                                   // 51\n          // used to have precedence.                                                                                // 52\n          if (i === 0) removedValue = precedence.value;                                                              // 53\n          precedenceList.splice(i, 1);                                                                               // 55\n          break;                                                                                                     // 56\n        }                                                                                                            // 57\n      }                                                                                                              // 58\n      if (_.isEmpty(precedenceList)) {                                                                               // 59\n        delete self.dataByKey[key];                                                                                  // 60\n        changeCollector[key] = undefined;                                                                            // 61\n      } else if (removedValue !== undefined && !EJSON.equals(removedValue, precedenceList[0].value)) {               // 62\n        changeCollector[key] = precedenceList[0].value;                                                              // 64\n      }                                                                                                              // 65\n    }                                                                                                                // 66\n                                                                                                                     //\n    return clearField;                                                                                               // 35\n  }(),                                                                                                               // 35\n                                                                                                                     //\n  changeField: function () {                                                                                         // 68\n    function changeField(subscriptionHandle, key, value, changeCollector, isAdd) {                                   // 68\n      var self = this;                                                                                               // 70\n      // Publish API ignores _id if present in fields                                                                // 71\n      if (key === \"_id\") return;                                                                                     // 72\n                                                                                                                     //\n      // Don't share state with the data passed in by the user.                                                      // 75\n      value = EJSON.clone(value);                                                                                    // 76\n                                                                                                                     //\n      if (!_.has(self.dataByKey, key)) {                                                                             // 78\n        self.dataByKey[key] = [{ subscriptionHandle: subscriptionHandle,                                             // 79\n          value: value }];                                                                                           // 80\n        changeCollector[key] = value;                                                                                // 81\n        return;                                                                                                      // 82\n      }                                                                                                              // 83\n      var precedenceList = self.dataByKey[key];                                                                      // 84\n      var elt;                                                                                                       // 85\n      if (!isAdd) {                                                                                                  // 86\n        elt = _.find(precedenceList, function (precedence) {                                                         // 87\n          return precedence.subscriptionHandle === subscriptionHandle;                                               // 88\n        });                                                                                                          // 89\n      }                                                                                                              // 90\n                                                                                                                     //\n      if (elt) {                                                                                                     // 92\n        if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {                                          // 93\n          // this subscription is changing the value of this field.                                                  // 94\n          changeCollector[key] = value;                                                                              // 95\n        }                                                                                                            // 96\n        elt.value = value;                                                                                           // 97\n      } else {                                                                                                       // 98\n        // this subscription is newly caring about this field                                                        // 99\n        precedenceList.push({ subscriptionHandle: subscriptionHandle, value: value });                               // 100\n      }                                                                                                              // 101\n    }                                                                                                                // 103\n                                                                                                                     //\n    return changeField;                                                                                              // 68\n  }()                                                                                                                // 68\n});                                                                                                                  // 24\n                                                                                                                     //\n/**                                                                                                                  // 106\n * Represents a client's view of a single collection                                                                 //\n * @param {String} collectionName Name of the collection it represents                                               //\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed                     //\n * @class SessionCollectionView                                                                                      //\n */                                                                                                                  //\nvar SessionCollectionView = function SessionCollectionView(collectionName, sessionCallbacks) {                       // 112\n  var self = this;                                                                                                   // 113\n  self.collectionName = collectionName;                                                                              // 114\n  self.documents = {};                                                                                               // 115\n  self.callbacks = sessionCallbacks;                                                                                 // 116\n};                                                                                                                   // 117\n                                                                                                                     //\nDDPServer._SessionCollectionView = SessionCollectionView;                                                            // 119\n                                                                                                                     //\n_.extend(SessionCollectionView.prototype, {                                                                          // 122\n                                                                                                                     //\n  isEmpty: function () {                                                                                             // 124\n    function isEmpty() {                                                                                             // 124\n      var self = this;                                                                                               // 125\n      return _.isEmpty(self.documents);                                                                              // 126\n    }                                                                                                                // 127\n                                                                                                                     //\n    return isEmpty;                                                                                                  // 124\n  }(),                                                                                                               // 124\n                                                                                                                     //\n  diff: function () {                                                                                                // 129\n    function diff(previous) {                                                                                        // 129\n      var self = this;                                                                                               // 130\n      DiffSequence.diffObjects(previous.documents, self.documents, {                                                 // 131\n        both: _.bind(self.diffDocument, self),                                                                       // 132\n                                                                                                                     //\n        rightOnly: function () {                                                                                     // 134\n          function rightOnly(id, nowDV) {                                                                            // 134\n            self.callbacks.added(self.collectionName, id, nowDV.getFields());                                        // 135\n          }                                                                                                          // 136\n                                                                                                                     //\n          return rightOnly;                                                                                          // 134\n        }(),                                                                                                         // 134\n                                                                                                                     //\n        leftOnly: function () {                                                                                      // 138\n          function leftOnly(id, prevDV) {                                                                            // 138\n            self.callbacks.removed(self.collectionName, id);                                                         // 139\n          }                                                                                                          // 140\n                                                                                                                     //\n          return leftOnly;                                                                                           // 138\n        }()                                                                                                          // 138\n      });                                                                                                            // 131\n    }                                                                                                                // 142\n                                                                                                                     //\n    return diff;                                                                                                     // 129\n  }(),                                                                                                               // 129\n                                                                                                                     //\n  diffDocument: function () {                                                                                        // 144\n    function diffDocument(id, prevDV, nowDV) {                                                                       // 144\n      var self = this;                                                                                               // 145\n      var fields = {};                                                                                               // 146\n      DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {                                              // 147\n        both: function () {                                                                                          // 148\n          function both(key, prev, now) {                                                                            // 148\n            if (!EJSON.equals(prev, now)) fields[key] = now;                                                         // 149\n          }                                                                                                          // 151\n                                                                                                                     //\n          return both;                                                                                               // 148\n        }(),                                                                                                         // 148\n        rightOnly: function () {                                                                                     // 152\n          function rightOnly(key, now) {                                                                             // 152\n            fields[key] = now;                                                                                       // 153\n          }                                                                                                          // 154\n                                                                                                                     //\n          return rightOnly;                                                                                          // 152\n        }(),                                                                                                         // 152\n        leftOnly: function () {                                                                                      // 155\n          function leftOnly(key, prev) {                                                                             // 155\n            fields[key] = undefined;                                                                                 // 156\n          }                                                                                                          // 157\n                                                                                                                     //\n          return leftOnly;                                                                                           // 155\n        }()                                                                                                          // 155\n      });                                                                                                            // 147\n      self.callbacks.changed(self.collectionName, id, fields);                                                       // 159\n    }                                                                                                                // 160\n                                                                                                                     //\n    return diffDocument;                                                                                             // 144\n  }(),                                                                                                               // 144\n                                                                                                                     //\n  added: function () {                                                                                               // 162\n    function added(subscriptionHandle, id, fields) {                                                                 // 162\n      var self = this;                                                                                               // 163\n      var docView = self.documents[id];                                                                              // 164\n      var added = false;                                                                                             // 165\n      if (!docView) {                                                                                                // 166\n        added = true;                                                                                                // 167\n        docView = new SessionDocumentView();                                                                         // 168\n        self.documents[id] = docView;                                                                                // 169\n      }                                                                                                              // 170\n      docView.existsIn[subscriptionHandle] = true;                                                                   // 171\n      var changeCollector = {};                                                                                      // 172\n      _.each(fields, function (value, key) {                                                                         // 173\n        docView.changeField(subscriptionHandle, key, value, changeCollector, true);                                  // 174\n      });                                                                                                            // 176\n      if (added) self.callbacks.added(self.collectionName, id, changeCollector);else self.callbacks.changed(self.collectionName, id, changeCollector);\n    }                                                                                                                // 181\n                                                                                                                     //\n    return added;                                                                                                    // 162\n  }(),                                                                                                               // 162\n                                                                                                                     //\n  changed: function () {                                                                                             // 183\n    function changed(subscriptionHandle, id, _changed) {                                                             // 183\n      var self = this;                                                                                               // 184\n      var changedResult = {};                                                                                        // 185\n      var docView = self.documents[id];                                                                              // 186\n      if (!docView) throw new Error(\"Could not find element with id \" + id + \" to change\");                          // 187\n      _.each(_changed, function (value, key) {                                                                       // 189\n        if (value === undefined) docView.clearField(subscriptionHandle, key, changedResult);else docView.changeField(subscriptionHandle, key, value, changedResult);\n      });                                                                                                            // 194\n      self.callbacks.changed(self.collectionName, id, changedResult);                                                // 195\n    }                                                                                                                // 196\n                                                                                                                     //\n    return changed;                                                                                                  // 183\n  }(),                                                                                                               // 183\n                                                                                                                     //\n  removed: function () {                                                                                             // 198\n    function removed(subscriptionHandle, id) {                                                                       // 198\n      var self = this;                                                                                               // 199\n      var docView = self.documents[id];                                                                              // 200\n      if (!docView) {                                                                                                // 201\n        var err = new Error(\"Removed nonexistent document \" + id);                                                   // 202\n        throw err;                                                                                                   // 203\n      }                                                                                                              // 204\n      delete docView.existsIn[subscriptionHandle];                                                                   // 205\n      if (_.isEmpty(docView.existsIn)) {                                                                             // 206\n        // it is gone from everyone                                                                                  // 207\n        self.callbacks.removed(self.collectionName, id);                                                             // 208\n        delete self.documents[id];                                                                                   // 209\n      } else {                                                                                                       // 210\n        var changed = {};                                                                                            // 211\n        // remove this subscription from every precedence list                                                       // 212\n        // and record the changes                                                                                    // 213\n        _.each(docView.dataByKey, function (precedenceList, key) {                                                   // 214\n          docView.clearField(subscriptionHandle, key, changed);                                                      // 215\n        });                                                                                                          // 216\n                                                                                                                     //\n        self.callbacks.changed(self.collectionName, id, changed);                                                    // 218\n      }                                                                                                              // 219\n    }                                                                                                                // 220\n                                                                                                                     //\n    return removed;                                                                                                  // 198\n  }()                                                                                                                // 198\n});                                                                                                                  // 122\n                                                                                                                     //\n/******************************************************************************/                                     // 223\n/* Session                                                                    */                                     // 224\n/******************************************************************************/                                     // 225\n                                                                                                                     //\nvar Session = function Session(server, version, socket, options) {                                                   // 227\n  var self = this;                                                                                                   // 228\n  self.id = Random.id();                                                                                             // 229\n                                                                                                                     //\n  self.server = server;                                                                                              // 231\n  self.version = version;                                                                                            // 232\n                                                                                                                     //\n  self.initialized = false;                                                                                          // 234\n  self.socket = socket;                                                                                              // 235\n                                                                                                                     //\n  // set to null when the session is destroyed. multiple places below                                                // 237\n  // use this to determine if the session is alive or not.                                                           // 238\n  self.inQueue = new Meteor._DoubleEndedQueue();                                                                     // 239\n                                                                                                                     //\n  self.blocked = false;                                                                                              // 241\n  self.workerRunning = false;                                                                                        // 242\n                                                                                                                     //\n  // Sub objects for active subscriptions                                                                            // 244\n  self._namedSubs = {};                                                                                              // 245\n  self._universalSubs = [];                                                                                          // 246\n                                                                                                                     //\n  self.userId = null;                                                                                                // 248\n                                                                                                                     //\n  self.collectionViews = {};                                                                                         // 250\n                                                                                                                     //\n  // Set this to false to not send messages when collectionViews are                                                 // 252\n  // modified. This is done when rerunning subs in _setUserId and those messages                                     // 253\n  // are calculated via a diff instead.                                                                              // 254\n  self._isSending = true;                                                                                            // 255\n                                                                                                                     //\n  // If this is true, don't start a newly-created universal publisher on this                                        // 257\n  // session. The session will take care of starting it when appropriate.                                            // 258\n  self._dontStartNewUniversalSubs = false;                                                                           // 259\n                                                                                                                     //\n  // when we are rerunning subscriptions, any ready messages                                                         // 261\n  // we want to buffer up for when we are done rerunning subscriptions                                               // 262\n  self._pendingReady = [];                                                                                           // 263\n                                                                                                                     //\n  // List of callbacks to call when this connection is closed.                                                       // 265\n  self._closeCallbacks = [];                                                                                         // 266\n                                                                                                                     //\n  // XXX HACK: If a sockjs connection, save off the URL. This is                                                     // 269\n  // temporary and will go away in the near future.                                                                  // 270\n  self._socketUrl = socket.url;                                                                                      // 271\n                                                                                                                     //\n  // Allow tests to disable responding to pings.                                                                     // 273\n  self._respondToPings = options.respondToPings;                                                                     // 274\n                                                                                                                     //\n  // This object is the public interface to the session. In the public                                               // 276\n  // API, it is called the `connection` object.  Internally we call it                                               // 277\n  // a `connectionHandle` to avoid ambiguity.                                                                        // 278\n  self.connectionHandle = {                                                                                          // 279\n    id: self.id,                                                                                                     // 280\n    close: function () {                                                                                             // 281\n      function close() {                                                                                             // 281\n        self.close();                                                                                                // 282\n      }                                                                                                              // 283\n                                                                                                                     //\n      return close;                                                                                                  // 281\n    }(),                                                                                                             // 281\n    onClose: function () {                                                                                           // 284\n      function onClose(fn) {                                                                                         // 284\n        var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");                                          // 285\n        if (self.inQueue) {                                                                                          // 286\n          self._closeCallbacks.push(cb);                                                                             // 287\n        } else {                                                                                                     // 288\n          // if we're already closed, call the callback.                                                             // 289\n          Meteor.defer(cb);                                                                                          // 290\n        }                                                                                                            // 291\n      }                                                                                                              // 292\n                                                                                                                     //\n      return onClose;                                                                                                // 284\n    }(),                                                                                                             // 284\n    clientAddress: self._clientAddress(),                                                                            // 293\n    httpHeaders: self.socket.headers                                                                                 // 294\n  };                                                                                                                 // 279\n                                                                                                                     //\n  self.send({ msg: 'connected', session: self.id });                                                                 // 297\n                                                                                                                     //\n  // On initial connect, spin up all the universal publishers.                                                       // 299\n  Fiber(function () {                                                                                                // 300\n    self.startUniversalSubs();                                                                                       // 301\n  }).run();                                                                                                          // 302\n                                                                                                                     //\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {                                                       // 304\n    self.heartbeat = new DDPCommon.Heartbeat({                                                                       // 305\n      heartbeatInterval: options.heartbeatInterval,                                                                  // 306\n      heartbeatTimeout: options.heartbeatTimeout,                                                                    // 307\n      onTimeout: function () {                                                                                       // 308\n        function onTimeout() {                                                                                       // 308\n          self.close();                                                                                              // 309\n        }                                                                                                            // 310\n                                                                                                                     //\n        return onTimeout;                                                                                            // 308\n      }(),                                                                                                           // 308\n      sendPing: function () {                                                                                        // 311\n        function sendPing() {                                                                                        // 311\n          self.send({ msg: 'ping' });                                                                                // 312\n        }                                                                                                            // 313\n                                                                                                                     //\n        return sendPing;                                                                                             // 311\n      }()                                                                                                            // 311\n    });                                                                                                              // 305\n    self.heartbeat.start();                                                                                          // 315\n  }                                                                                                                  // 316\n                                                                                                                     //\n  Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"sessions\", 1);                               // 318\n};                                                                                                                   // 320\n                                                                                                                     //\n_.extend(Session.prototype, {                                                                                        // 322\n                                                                                                                     //\n  sendReady: function () {                                                                                           // 324\n    function sendReady(subscriptionIds) {                                                                            // 324\n      var self = this;                                                                                               // 325\n      if (self._isSending) self.send({ msg: \"ready\", subs: subscriptionIds });else {                                 // 326\n        _.each(subscriptionIds, function (subscriptionId) {                                                          // 329\n          self._pendingReady.push(subscriptionId);                                                                   // 330\n        });                                                                                                          // 331\n      }                                                                                                              // 332\n    }                                                                                                                // 333\n                                                                                                                     //\n    return sendReady;                                                                                                // 324\n  }(),                                                                                                               // 324\n                                                                                                                     //\n  sendAdded: function () {                                                                                           // 335\n    function sendAdded(collectionName, id, fields) {                                                                 // 335\n      var self = this;                                                                                               // 336\n      if (self._isSending) self.send({ msg: \"added\", collection: collectionName, id: id, fields: fields });          // 337\n    }                                                                                                                // 339\n                                                                                                                     //\n    return sendAdded;                                                                                                // 335\n  }(),                                                                                                               // 335\n                                                                                                                     //\n  sendChanged: function () {                                                                                         // 341\n    function sendChanged(collectionName, id, fields) {                                                               // 341\n      var self = this;                                                                                               // 342\n      if (_.isEmpty(fields)) return;                                                                                 // 343\n                                                                                                                     //\n      if (self._isSending) {                                                                                         // 346\n        self.send({                                                                                                  // 347\n          msg: \"changed\",                                                                                            // 348\n          collection: collectionName,                                                                                // 349\n          id: id,                                                                                                    // 350\n          fields: fields                                                                                             // 351\n        });                                                                                                          // 347\n      }                                                                                                              // 353\n    }                                                                                                                // 354\n                                                                                                                     //\n    return sendChanged;                                                                                              // 341\n  }(),                                                                                                               // 341\n                                                                                                                     //\n  sendRemoved: function () {                                                                                         // 356\n    function sendRemoved(collectionName, id) {                                                                       // 356\n      var self = this;                                                                                               // 357\n      if (self._isSending) self.send({ msg: \"removed\", collection: collectionName, id: id });                        // 358\n    }                                                                                                                // 360\n                                                                                                                     //\n    return sendRemoved;                                                                                              // 356\n  }(),                                                                                                               // 356\n                                                                                                                     //\n  getSendCallbacks: function () {                                                                                    // 362\n    function getSendCallbacks() {                                                                                    // 362\n      var self = this;                                                                                               // 363\n      return {                                                                                                       // 364\n        added: _.bind(self.sendAdded, self),                                                                         // 365\n        changed: _.bind(self.sendChanged, self),                                                                     // 366\n        removed: _.bind(self.sendRemoved, self)                                                                      // 367\n      };                                                                                                             // 364\n    }                                                                                                                // 369\n                                                                                                                     //\n    return getSendCallbacks;                                                                                         // 362\n  }(),                                                                                                               // 362\n                                                                                                                     //\n  getCollectionView: function () {                                                                                   // 371\n    function getCollectionView(collectionName) {                                                                     // 371\n      var self = this;                                                                                               // 372\n      if (_.has(self.collectionViews, collectionName)) {                                                             // 373\n        return self.collectionViews[collectionName];                                                                 // 374\n      }                                                                                                              // 375\n      var ret = new SessionCollectionView(collectionName, self.getSendCallbacks());                                  // 376\n      self.collectionViews[collectionName] = ret;                                                                    // 378\n      return ret;                                                                                                    // 379\n    }                                                                                                                // 380\n                                                                                                                     //\n    return getCollectionView;                                                                                        // 371\n  }(),                                                                                                               // 371\n                                                                                                                     //\n  added: function () {                                                                                               // 382\n    function added(subscriptionHandle, collectionName, id, fields) {                                                 // 382\n      var self = this;                                                                                               // 383\n      var view = self.getCollectionView(collectionName);                                                             // 384\n      view.added(subscriptionHandle, id, fields);                                                                    // 385\n    }                                                                                                                // 386\n                                                                                                                     //\n    return added;                                                                                                    // 382\n  }(),                                                                                                               // 382\n                                                                                                                     //\n  removed: function () {                                                                                             // 388\n    function removed(subscriptionHandle, collectionName, id) {                                                       // 388\n      var self = this;                                                                                               // 389\n      var view = self.getCollectionView(collectionName);                                                             // 390\n      view.removed(subscriptionHandle, id);                                                                          // 391\n      if (view.isEmpty()) {                                                                                          // 392\n        delete self.collectionViews[collectionName];                                                                 // 393\n      }                                                                                                              // 394\n    }                                                                                                                // 395\n                                                                                                                     //\n    return removed;                                                                                                  // 388\n  }(),                                                                                                               // 388\n                                                                                                                     //\n  changed: function () {                                                                                             // 397\n    function changed(subscriptionHandle, collectionName, id, fields) {                                               // 397\n      var self = this;                                                                                               // 398\n      var view = self.getCollectionView(collectionName);                                                             // 399\n      view.changed(subscriptionHandle, id, fields);                                                                  // 400\n    }                                                                                                                // 401\n                                                                                                                     //\n    return changed;                                                                                                  // 397\n  }(),                                                                                                               // 397\n                                                                                                                     //\n  startUniversalSubs: function () {                                                                                  // 403\n    function startUniversalSubs() {                                                                                  // 403\n      var self = this;                                                                                               // 404\n      // Make a shallow copy of the set of universal handlers and start them. If                                     // 405\n      // additional universal publishers start while we're running them (due to                                      // 406\n      // yielding), they will run separately as part of Server.publish.                                              // 407\n      var handlers = _.clone(self.server.universal_publish_handlers);                                                // 408\n      _.each(handlers, function (handler) {                                                                          // 409\n        self._startSubscription(handler);                                                                            // 410\n      });                                                                                                            // 411\n    }                                                                                                                // 412\n                                                                                                                     //\n    return startUniversalSubs;                                                                                       // 403\n  }(),                                                                                                               // 403\n                                                                                                                     //\n  // Destroy this session and unregister it at the server.                                                           // 414\n  close: function () {                                                                                               // 415\n    function close() {                                                                                               // 415\n      var self = this;                                                                                               // 416\n                                                                                                                     //\n      // Destroy this session, even if it's not registered at the                                                    // 418\n      // server. Stop all processing and tear everything down. If a socket                                           // 419\n      // was attached, close it.                                                                                     // 420\n                                                                                                                     //\n      // Already destroyed.                                                                                          // 422\n      if (!self.inQueue) return;                                                                                     // 423\n                                                                                                                     //\n      // Drop the merge box data immediately.                                                                        // 426\n      self.inQueue = null;                                                                                           // 427\n      self.collectionViews = {};                                                                                     // 428\n                                                                                                                     //\n      if (self.heartbeat) {                                                                                          // 430\n        self.heartbeat.stop();                                                                                       // 431\n        self.heartbeat = null;                                                                                       // 432\n      }                                                                                                              // 433\n                                                                                                                     //\n      if (self.socket) {                                                                                             // 435\n        self.socket.close();                                                                                         // 436\n        self.socket._meteorSession = null;                                                                           // 437\n      }                                                                                                              // 438\n                                                                                                                     //\n      Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"sessions\", -1);                          // 440\n                                                                                                                     //\n      Meteor.defer(function () {                                                                                     // 443\n        // stop callbacks can yield, so we defer this on close.                                                      // 444\n        // sub._isDeactivated() detects that we set inQueue to null and                                              // 445\n        // treats it as semi-deactivated (it will ignore incoming callbacks, etc).                                   // 446\n        self._deactivateAllSubscriptions();                                                                          // 447\n                                                                                                                     //\n        // Defer calling the close callbacks, so that the caller closing                                             // 449\n        // the session isn't waiting for all the callbacks to complete.                                              // 450\n        _.each(self._closeCallbacks, function (callback) {                                                           // 451\n          callback();                                                                                                // 452\n        });                                                                                                          // 453\n      });                                                                                                            // 454\n                                                                                                                     //\n      // Unregister the session.                                                                                     // 456\n      self.server._removeSession(self);                                                                              // 457\n    }                                                                                                                // 458\n                                                                                                                     //\n    return close;                                                                                                    // 415\n  }(),                                                                                                               // 415\n                                                                                                                     //\n  // Send a message (doing nothing if no socket is connected right now.)                                             // 460\n  // It should be a JSON object (it will be stringified.)                                                            // 461\n  send: function () {                                                                                                // 462\n    function send(msg) {                                                                                             // 462\n      var self = this;                                                                                               // 463\n      if (self.socket) {                                                                                             // 464\n        if (Meteor._printSentDDP) Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));                            // 465\n        self.socket.send(DDPCommon.stringifyDDP(msg));                                                               // 467\n      }                                                                                                              // 468\n    }                                                                                                                // 469\n                                                                                                                     //\n    return send;                                                                                                     // 462\n  }(),                                                                                                               // 462\n                                                                                                                     //\n  // Send a connection error.                                                                                        // 471\n  sendError: function () {                                                                                           // 472\n    function sendError(reason, offendingMessage) {                                                                   // 472\n      var self = this;                                                                                               // 473\n      var msg = { msg: 'error', reason: reason };                                                                    // 474\n      if (offendingMessage) msg.offendingMessage = offendingMessage;                                                 // 475\n      self.send(msg);                                                                                                // 477\n    }                                                                                                                // 478\n                                                                                                                     //\n    return sendError;                                                                                                // 472\n  }(),                                                                                                               // 472\n                                                                                                                     //\n  // Process 'msg' as an incoming message. (But as a guard against                                                   // 480\n  // race conditions during reconnection, ignore the message if                                                      // 481\n  // 'socket' is not the currently connected socket.)                                                                // 482\n  //                                                                                                                 // 483\n  // We run the messages from the client one at a time, in the order                                                 // 484\n  // given by the client. The message handler is passed an idempotent                                                // 485\n  // function 'unblock' which it may call to allow other messages to                                                 // 486\n  // begin running in parallel in another fiber (for example, a method                                               // 487\n  // that wants to yield.) Otherwise, it is automatically unblocked                                                  // 488\n  // when it returns.                                                                                                // 489\n  //                                                                                                                 // 490\n  // Actually, we don't have to 'totally order' the messages in this                                                 // 491\n  // way, but it's the easiest thing that's correct. (unsub needs to                                                 // 492\n  // be ordered against sub, methods need to be ordered against each                                                 // 493\n  // other.)                                                                                                         // 494\n  processMessage: function () {                                                                                      // 495\n    function processMessage(msg_in) {                                                                                // 495\n      var self = this;                                                                                               // 496\n      if (!self.inQueue) // we have been destroyed.                                                                  // 497\n        return;                                                                                                      // 498\n                                                                                                                     //\n      // Respond to ping and pong messages immediately without queuing.                                              // 500\n      // If the negotiated DDP version is \"pre1\" which didn't support                                                // 501\n      // pings, preserve the \"pre1\" behavior of responding with a \"bad                                               // 502\n      // request\" for the unknown messages.                                                                          // 503\n      //                                                                                                             // 504\n      // Fibers are needed because heartbeat uses Meteor.setTimeout, which                                           // 505\n      // needs a Fiber. We could actually use regular setTimeout and avoid                                           // 506\n      // these new fibers, but it is easier to just make everything use                                              // 507\n      // Meteor.setTimeout and not think too hard.                                                                   // 508\n      //                                                                                                             // 509\n      // Any message counts as receiving a pong, as it demonstrates that                                             // 510\n      // the client is still alive.                                                                                  // 511\n      if (self.heartbeat) {                                                                                          // 512\n        Fiber(function () {                                                                                          // 513\n          self.heartbeat.messageReceived();                                                                          // 514\n        }).run();                                                                                                    // 515\n      }                                                                                                              // 516\n                                                                                                                     //\n      if (self.version !== 'pre1' && msg_in.msg === 'ping') {                                                        // 518\n        if (self._respondToPings) self.send({ msg: \"pong\", id: msg_in.id });                                         // 519\n        return;                                                                                                      // 521\n      }                                                                                                              // 522\n      if (self.version !== 'pre1' && msg_in.msg === 'pong') {                                                        // 523\n        // Since everything is a pong, nothing to do                                                                 // 524\n        return;                                                                                                      // 525\n      }                                                                                                              // 526\n                                                                                                                     //\n      self.inQueue.push(msg_in);                                                                                     // 528\n      if (self.workerRunning) return;                                                                                // 529\n      self.workerRunning = true;                                                                                     // 531\n                                                                                                                     //\n      var processNext = function () {                                                                                // 533\n        function processNext() {                                                                                     // 533\n          var msg = self.inQueue && self.inQueue.shift();                                                            // 534\n          if (!msg) {                                                                                                // 535\n            self.workerRunning = false;                                                                              // 536\n            return;                                                                                                  // 537\n          }                                                                                                          // 538\n                                                                                                                     //\n          Fiber(function () {                                                                                        // 540\n            var blocked = true;                                                                                      // 541\n                                                                                                                     //\n            var unblock = function () {                                                                              // 543\n              function unblock() {                                                                                   // 543\n                if (!blocked) return; // idempotent                                                                  // 544\n                blocked = false;                                                                                     // 546\n                processNext();                                                                                       // 547\n              }                                                                                                      // 548\n                                                                                                                     //\n              return unblock;                                                                                        // 543\n            }();                                                                                                     // 543\n                                                                                                                     //\n            if (_.has(self.protocol_handlers, msg.msg)) self.protocol_handlers[msg.msg].call(self, msg, unblock);else self.sendError('Bad request', msg);\n            unblock(); // in case the handler didn't already do it                                                   // 554\n          }).run();                                                                                                  // 555\n        }                                                                                                            // 556\n                                                                                                                     //\n        return processNext;                                                                                          // 533\n      }();                                                                                                           // 533\n                                                                                                                     //\n      processNext();                                                                                                 // 558\n    }                                                                                                                // 559\n                                                                                                                     //\n    return processMessage;                                                                                           // 495\n  }(),                                                                                                               // 495\n                                                                                                                     //\n  protocol_handlers: {                                                                                               // 561\n    sub: function () {                                                                                               // 562\n      function sub(msg) {                                                                                            // 562\n        var self = this;                                                                                             // 563\n                                                                                                                     //\n        // reject malformed messages                                                                                 // 565\n        if (typeof msg.id !== \"string\" || typeof msg.name !== \"string\" || 'params' in msg && !(msg.params instanceof Array)) {\n          self.sendError(\"Malformed subscription\", msg);                                                             // 569\n          return;                                                                                                    // 570\n        }                                                                                                            // 571\n                                                                                                                     //\n        if (!self.server.publish_handlers[msg.name]) {                                                               // 573\n          self.send({                                                                                                // 574\n            msg: 'nosub', id: msg.id,                                                                                // 575\n            error: new Meteor.Error(404, \"Subscription '\" + msg.name + \"' not found\") });                            // 576\n          return;                                                                                                    // 577\n        }                                                                                                            // 578\n                                                                                                                     //\n        if (_.has(self._namedSubs, msg.id))                                                                          // 580\n          // subs are idempotent, or rather, they are ignored if a sub                                               // 581\n          // with that id already exists. this is important during                                                   // 582\n          // reconnect.                                                                                              // 583\n          return;                                                                                                    // 584\n                                                                                                                     //\n        // XXX It'd be much better if we had generic hooks where any package can                                     // 586\n        // hook into subscription handling, but in the mean while we special case                                    // 587\n        // ddp-rate-limiter package. This is also done for weak requirements to                                      // 588\n        // add the ddp-rate-limiter package in case we don't have Accounts. A                                        // 589\n        // user trying to use the ddp-rate-limiter must explicitly require it.                                       // 590\n        if (Package['ddp-rate-limiter']) {                                                                           // 591\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;                                           // 592\n          var rateLimiterInput = {                                                                                   // 593\n            userId: self.userId,                                                                                     // 594\n            clientAddress: self.connectionHandle.clientAddress,                                                      // 595\n            type: \"subscription\",                                                                                    // 596\n            name: msg.name,                                                                                          // 597\n            connectionId: self.id                                                                                    // 598\n          };                                                                                                         // 593\n                                                                                                                     //\n          DDPRateLimiter._increment(rateLimiterInput);                                                               // 601\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);                                             // 602\n          if (!rateLimitResult.allowed) {                                                                            // 603\n            self.send({                                                                                              // 604\n              msg: 'nosub', id: msg.id,                                                                              // 605\n              error: new Meteor.Error('too-many-requests', DDPRateLimiter.getErrorMessage(rateLimitResult), { timeToReset: rateLimitResult.timeToReset })\n            });                                                                                                      // 604\n            return;                                                                                                  // 611\n          }                                                                                                          // 612\n        }                                                                                                            // 613\n                                                                                                                     //\n        var handler = self.server.publish_handlers[msg.name];                                                        // 615\n                                                                                                                     //\n        self._startSubscription(handler, msg.id, msg.params, msg.name);                                              // 617\n      }                                                                                                              // 619\n                                                                                                                     //\n      return sub;                                                                                                    // 562\n    }(),                                                                                                             // 562\n                                                                                                                     //\n    unsub: function () {                                                                                             // 621\n      function unsub(msg) {                                                                                          // 621\n        var self = this;                                                                                             // 622\n                                                                                                                     //\n        self._stopSubscription(msg.id);                                                                              // 624\n      }                                                                                                              // 625\n                                                                                                                     //\n      return unsub;                                                                                                  // 621\n    }(),                                                                                                             // 621\n                                                                                                                     //\n    method: function () {                                                                                            // 627\n      function method(msg, unblock) {                                                                                // 627\n        var self = this;                                                                                             // 628\n                                                                                                                     //\n        // reject malformed messages                                                                                 // 630\n        // For now, we silently ignore unknown attributes,                                                           // 631\n        // for forwards compatibility.                                                                               // 632\n        if (typeof msg.id !== \"string\" || typeof msg.method !== \"string\" || 'params' in msg && !(msg.params instanceof Array) || 'randomSeed' in msg && typeof msg.randomSeed !== \"string\") {\n          self.sendError(\"Malformed method invocation\", msg);                                                        // 637\n          return;                                                                                                    // 638\n        }                                                                                                            // 639\n                                                                                                                     //\n        var randomSeed = msg.randomSeed || null;                                                                     // 641\n                                                                                                                     //\n        // set up to mark the method as satisfied once all observers                                                 // 643\n        // (and subscriptions) have reacted to any writes that were                                                  // 644\n        // done.                                                                                                     // 645\n        var fence = new DDPServer._WriteFence();                                                                     // 646\n        fence.onAllCommitted(function () {                                                                           // 647\n          // Retire the fence so that future writes are allowed.                                                     // 648\n          // This means that callbacks like timers are free to use                                                   // 649\n          // the fence, and if they fire before it's armed (for                                                      // 650\n          // example, because the method waits for them) their                                                       // 651\n          // writes will be included in the fence.                                                                   // 652\n          fence.retire();                                                                                            // 653\n          self.send({                                                                                                // 654\n            msg: 'updated', methods: [msg.id] });                                                                    // 655\n        });                                                                                                          // 656\n                                                                                                                     //\n        // find the handler                                                                                          // 658\n        var handler = self.server.method_handlers[msg.method];                                                       // 659\n        if (!handler) {                                                                                              // 660\n          self.send({                                                                                                // 661\n            msg: 'result', id: msg.id,                                                                               // 662\n            error: new Meteor.Error(404, \"Method '\" + msg.method + \"' not found\") });                                // 663\n          fence.arm();                                                                                               // 664\n          return;                                                                                                    // 665\n        }                                                                                                            // 666\n                                                                                                                     //\n        var setUserId = function () {                                                                                // 668\n          function setUserId(userId) {                                                                               // 668\n            self._setUserId(userId);                                                                                 // 669\n          }                                                                                                          // 670\n                                                                                                                     //\n          return setUserId;                                                                                          // 668\n        }();                                                                                                         // 668\n                                                                                                                     //\n        var invocation = new DDPCommon.MethodInvocation({                                                            // 672\n          isSimulation: false,                                                                                       // 673\n          userId: self.userId,                                                                                       // 674\n          setUserId: setUserId,                                                                                      // 675\n          unblock: unblock,                                                                                          // 676\n          connection: self.connectionHandle,                                                                         // 677\n          randomSeed: randomSeed                                                                                     // 678\n        });                                                                                                          // 672\n                                                                                                                     //\n        var promise = new Promise(function (resolve, reject) {                                                       // 681\n          // XXX It'd be better if we could hook into method handlers better but                                     // 682\n          // for now, we need to check if the ddp-rate-limiter exists since we                                       // 683\n          // have a weak requirement for the ddp-rate-limiter package to be added                                    // 684\n          // to our application.                                                                                     // 685\n          if (Package['ddp-rate-limiter']) {                                                                         // 686\n            var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;                                         // 687\n            var rateLimiterInput = {                                                                                 // 688\n              userId: self.userId,                                                                                   // 689\n              clientAddress: self.connectionHandle.clientAddress,                                                    // 690\n              type: \"method\",                                                                                        // 691\n              name: msg.method,                                                                                      // 692\n              connectionId: self.id                                                                                  // 693\n            };                                                                                                       // 688\n            DDPRateLimiter._increment(rateLimiterInput);                                                             // 695\n            var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);                                           // 696\n            if (!rateLimitResult.allowed) {                                                                          // 697\n              reject(new Meteor.Error(\"too-many-requests\", DDPRateLimiter.getErrorMessage(rateLimitResult), { timeToReset: rateLimitResult.timeToReset }));\n              return;                                                                                                // 703\n            }                                                                                                        // 704\n          }                                                                                                          // 705\n                                                                                                                     //\n          resolve(DDPServer._CurrentWriteFence.withValue(fence, function () {                                        // 707\n            return DDP._CurrentInvocation.withValue(invocation, function () {                                        // 709\n              return maybeAuditArgumentChecks(handler, invocation, msg.params, \"call to '\" + msg.method + \"'\");      // 711\n            });                                                                                                      // 711\n          }));                                                                                                       // 709\n        });                                                                                                          // 717\n                                                                                                                     //\n        function finish() {                                                                                          // 719\n          fence.arm();                                                                                               // 720\n          unblock();                                                                                                 // 721\n        }                                                                                                            // 722\n                                                                                                                     //\n        var payload = {                                                                                              // 724\n          msg: \"result\",                                                                                             // 725\n          id: msg.id                                                                                                 // 726\n        };                                                                                                           // 724\n                                                                                                                     //\n        promise.then(function (result) {                                                                             // 729\n          finish();                                                                                                  // 730\n          if (result !== undefined) {                                                                                // 731\n            payload.result = result;                                                                                 // 732\n          }                                                                                                          // 733\n          self.send(payload);                                                                                        // 734\n        }, function (exception) {                                                                                    // 735\n          finish();                                                                                                  // 736\n          payload.error = wrapInternalException(exception, \"while invoking method '\" + msg.method + \"'\");            // 737\n          self.send(payload);                                                                                        // 741\n        });                                                                                                          // 742\n      }                                                                                                              // 743\n                                                                                                                     //\n      return method;                                                                                                 // 627\n    }()                                                                                                              // 627\n  },                                                                                                                 // 561\n                                                                                                                     //\n  _eachSub: function () {                                                                                            // 746\n    function _eachSub(f) {                                                                                           // 746\n      var self = this;                                                                                               // 747\n      _.each(self._namedSubs, f);                                                                                    // 748\n      _.each(self._universalSubs, f);                                                                                // 749\n    }                                                                                                                // 750\n                                                                                                                     //\n    return _eachSub;                                                                                                 // 746\n  }(),                                                                                                               // 746\n                                                                                                                     //\n  _diffCollectionViews: function () {                                                                                // 752\n    function _diffCollectionViews(beforeCVs) {                                                                       // 752\n      var self = this;                                                                                               // 753\n      DiffSequence.diffObjects(beforeCVs, self.collectionViews, {                                                    // 754\n        both: function () {                                                                                          // 755\n          function both(collectionName, leftValue, rightValue) {                                                     // 755\n            rightValue.diff(leftValue);                                                                              // 756\n          }                                                                                                          // 757\n                                                                                                                     //\n          return both;                                                                                               // 755\n        }(),                                                                                                         // 755\n        rightOnly: function () {                                                                                     // 758\n          function rightOnly(collectionName, rightValue) {                                                           // 758\n            _.each(rightValue.documents, function (docView, id) {                                                    // 759\n              self.sendAdded(collectionName, id, docView.getFields());                                               // 760\n            });                                                                                                      // 761\n          }                                                                                                          // 762\n                                                                                                                     //\n          return rightOnly;                                                                                          // 758\n        }(),                                                                                                         // 758\n        leftOnly: function () {                                                                                      // 763\n          function leftOnly(collectionName, leftValue) {                                                             // 763\n            _.each(leftValue.documents, function (doc, id) {                                                         // 764\n              self.sendRemoved(collectionName, id);                                                                  // 765\n            });                                                                                                      // 766\n          }                                                                                                          // 767\n                                                                                                                     //\n          return leftOnly;                                                                                           // 763\n        }()                                                                                                          // 763\n      });                                                                                                            // 754\n    }                                                                                                                // 769\n                                                                                                                     //\n    return _diffCollectionViews;                                                                                     // 752\n  }(),                                                                                                               // 752\n                                                                                                                     //\n  // Sets the current user id in all appropriate contexts and reruns                                                 // 771\n  // all subscriptions                                                                                               // 772\n  _setUserId: function () {                                                                                          // 773\n    function _setUserId(userId) {                                                                                    // 773\n      var self = this;                                                                                               // 774\n                                                                                                                     //\n      if (userId !== null && typeof userId !== \"string\") throw new Error(\"setUserId must be called on string or null, not \" + (typeof userId === \"undefined\" ? \"undefined\" : _typeof(userId)));\n                                                                                                                     //\n      // Prevent newly-created universal subscriptions from being added to our                                       // 780\n      // session; they will be found below when we call startUniversalSubs.                                          // 781\n      //                                                                                                             // 782\n      // (We don't have to worry about named subscriptions, because we only add                                      // 783\n      // them when we process a 'sub' message. We are currently processing a                                         // 784\n      // 'method' message, and the method did not unblock, because it is illegal                                     // 785\n      // to call setUserId after unblock. Thus we cannot be concurrently adding a                                    // 786\n      // new named subscription.)                                                                                    // 787\n      self._dontStartNewUniversalSubs = true;                                                                        // 788\n                                                                                                                     //\n      // Prevent current subs from updating our collectionViews and call their                                       // 790\n      // stop callbacks. This may yield.                                                                             // 791\n      self._eachSub(function (sub) {                                                                                 // 792\n        sub._deactivate();                                                                                           // 793\n      });                                                                                                            // 794\n                                                                                                                     //\n      // All subs should now be deactivated. Stop sending messages to the client,                                    // 796\n      // save the state of the published collections, reset to an empty view, and                                    // 797\n      // update the userId.                                                                                          // 798\n      self._isSending = false;                                                                                       // 799\n      var beforeCVs = self.collectionViews;                                                                          // 800\n      self.collectionViews = {};                                                                                     // 801\n      self.userId = userId;                                                                                          // 802\n                                                                                                                     //\n      // Save the old named subs, and reset to having no subscriptions.                                              // 804\n      var oldNamedSubs = self._namedSubs;                                                                            // 805\n      self._namedSubs = {};                                                                                          // 806\n      self._universalSubs = [];                                                                                      // 807\n                                                                                                                     //\n      _.each(oldNamedSubs, function (sub, subscriptionId) {                                                          // 809\n        self._namedSubs[subscriptionId] = sub._recreate();                                                           // 810\n        // nb: if the handler throws or calls this.error(), it will in fact                                          // 811\n        // immediately send its 'nosub'. This is OK, though.                                                         // 812\n        self._namedSubs[subscriptionId]._runHandler();                                                               // 813\n      });                                                                                                            // 814\n                                                                                                                     //\n      // Allow newly-created universal subs to be started on our connection in                                       // 816\n      // parallel with the ones we're spinning up here, and spin up universal                                        // 817\n      // subs.                                                                                                       // 818\n      self._dontStartNewUniversalSubs = false;                                                                       // 819\n      self.startUniversalSubs();                                                                                     // 820\n                                                                                                                     //\n      // Start sending messages again, beginning with the diff from the previous                                     // 822\n      // state of the world to the current state. No yields are allowed during                                       // 823\n      // this diff, so that other changes cannot interleave.                                                         // 824\n      Meteor._noYieldsAllowed(function () {                                                                          // 825\n        self._isSending = true;                                                                                      // 826\n        self._diffCollectionViews(beforeCVs);                                                                        // 827\n        if (!_.isEmpty(self._pendingReady)) {                                                                        // 828\n          self.sendReady(self._pendingReady);                                                                        // 829\n          self._pendingReady = [];                                                                                   // 830\n        }                                                                                                            // 831\n      });                                                                                                            // 832\n    }                                                                                                                // 833\n                                                                                                                     //\n    return _setUserId;                                                                                               // 773\n  }(),                                                                                                               // 773\n                                                                                                                     //\n  _startSubscription: function () {                                                                                  // 835\n    function _startSubscription(handler, subId, params, name) {                                                      // 835\n      var self = this;                                                                                               // 836\n                                                                                                                     //\n      var sub = new Subscription(self, handler, subId, params, name);                                                // 838\n      if (subId) self._namedSubs[subId] = sub;else self._universalSubs.push(sub);                                    // 840\n                                                                                                                     //\n      sub._runHandler();                                                                                             // 845\n    }                                                                                                                // 846\n                                                                                                                     //\n    return _startSubscription;                                                                                       // 835\n  }(),                                                                                                               // 835\n                                                                                                                     //\n  // tear down specified subscription                                                                                // 848\n  _stopSubscription: function () {                                                                                   // 849\n    function _stopSubscription(subId, error) {                                                                       // 849\n      var self = this;                                                                                               // 850\n                                                                                                                     //\n      var subName = null;                                                                                            // 852\n                                                                                                                     //\n      if (subId && self._namedSubs[subId]) {                                                                         // 854\n        subName = self._namedSubs[subId]._name;                                                                      // 855\n        self._namedSubs[subId]._removeAllDocuments();                                                                // 856\n        self._namedSubs[subId]._deactivate();                                                                        // 857\n        delete self._namedSubs[subId];                                                                               // 858\n      }                                                                                                              // 859\n                                                                                                                     //\n      var response = { msg: 'nosub', id: subId };                                                                    // 861\n                                                                                                                     //\n      if (error) {                                                                                                   // 863\n        response.error = wrapInternalException(error, subName ? \"from sub \" + subName + \" id \" + subId : \"from sub id \" + subId);\n      }                                                                                                              // 868\n                                                                                                                     //\n      self.send(response);                                                                                           // 870\n    }                                                                                                                // 871\n                                                                                                                     //\n    return _stopSubscription;                                                                                        // 849\n  }(),                                                                                                               // 849\n                                                                                                                     //\n  // tear down all subscriptions. Note that this does NOT send removed or nosub                                      // 873\n  // messages, since we assume the client is gone.                                                                   // 874\n  _deactivateAllSubscriptions: function () {                                                                         // 875\n    function _deactivateAllSubscriptions() {                                                                         // 875\n      var self = this;                                                                                               // 876\n                                                                                                                     //\n      _.each(self._namedSubs, function (sub, id) {                                                                   // 878\n        sub._deactivate();                                                                                           // 879\n      });                                                                                                            // 880\n      self._namedSubs = {};                                                                                          // 881\n                                                                                                                     //\n      _.each(self._universalSubs, function (sub) {                                                                   // 883\n        sub._deactivate();                                                                                           // 884\n      });                                                                                                            // 885\n      self._universalSubs = [];                                                                                      // 886\n    }                                                                                                                // 887\n                                                                                                                     //\n    return _deactivateAllSubscriptions;                                                                              // 875\n  }(),                                                                                                               // 875\n                                                                                                                     //\n  // Determine the remote client's IP address, based on the                                                          // 889\n  // HTTP_FORWARDED_COUNT environment variable representing how many                                                 // 890\n  // proxies the server is behind.                                                                                   // 891\n  _clientAddress: function () {                                                                                      // 892\n    function _clientAddress() {                                                                                      // 892\n      var self = this;                                                                                               // 893\n                                                                                                                     //\n      // For the reported client address for a connection to be correct,                                             // 895\n      // the developer must set the HTTP_FORWARDED_COUNT environment                                                 // 896\n      // variable to an integer representing the number of hops they                                                 // 897\n      // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the                                             // 898\n      // server is behind one proxy.                                                                                 // 899\n      //                                                                                                             // 900\n      // This could be computed once at startup instead of every time.                                               // 901\n      var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;                                   // 902\n                                                                                                                     //\n      if (httpForwardedCount === 0) return self.socket.remoteAddress;                                                // 904\n                                                                                                                     //\n      var forwardedFor = self.socket.headers[\"x-forwarded-for\"];                                                     // 907\n      if (!_.isString(forwardedFor)) return null;                                                                    // 908\n      forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);                                                           // 910\n                                                                                                                     //\n      // Typically the first value in the `x-forwarded-for` header is                                                // 912\n      // the original IP address of the client connecting to the first                                               // 913\n      // proxy.  However, the end user can easily spoof the header, in                                               // 914\n      // which case the first value(s) will be the fake IP address from                                              // 915\n      // the user pretending to be a proxy reporting the original IP                                                 // 916\n      // address value.  By counting HTTP_FORWARDED_COUNT back from the                                              // 917\n      // end of the list, we ensure that we get the IP address being                                                 // 918\n      // reported by *our* first proxy.                                                                              // 919\n                                                                                                                     //\n      if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length) return null;                           // 921\n                                                                                                                     //\n      return forwardedFor[forwardedFor.length - httpForwardedCount];                                                 // 924\n    }                                                                                                                // 925\n                                                                                                                     //\n    return _clientAddress;                                                                                           // 892\n  }()                                                                                                                // 892\n});                                                                                                                  // 322\n                                                                                                                     //\n/******************************************************************************/                                     // 928\n/* Subscription                                                               */                                     // 929\n/******************************************************************************/                                     // 930\n                                                                                                                     //\n// ctor for a sub handle: the input to each publish function                                                         // 932\n                                                                                                                     //\n// Instance name is this because it's usually referred to as this inside a                                           // 934\n// publish                                                                                                           // 935\n/**                                                                                                                  // 936\n * @summary The server's side of a subscription                                                                      //\n * @class Subscription                                                                                               //\n * @instanceName this                                                                                                //\n */                                                                                                                  //\nvar Subscription = function Subscription(session, handler, subscriptionId, params, name) {                           // 941\n  var self = this;                                                                                                   // 943\n  self._session = session; // type is Session                                                                        // 944\n                                                                                                                     //\n  /**                                                                                                                // 946\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server                                                                                                   //\n   * @name  connection                                                                                               //\n   * @memberOf Subscription                                                                                          //\n   * @instance                                                                                                       //\n   */                                                                                                                //\n  self.connection = session.connectionHandle; // public API object                                                   // 953\n                                                                                                                     //\n  self._handler = handler;                                                                                           // 955\n                                                                                                                     //\n  // my subscription ID (generated by client, undefined for universal subs).                                         // 957\n  self._subscriptionId = subscriptionId;                                                                             // 958\n  // undefined for universal subs                                                                                    // 959\n  self._name = name;                                                                                                 // 960\n                                                                                                                     //\n  self._params = params || [];                                                                                       // 962\n                                                                                                                     //\n  // Only named subscriptions have IDs, but we need some sort of string                                              // 964\n  // internally to keep track of all subscriptions inside                                                            // 965\n  // SessionDocumentViews. We use this subscriptionHandle for that.                                                  // 966\n  if (self._subscriptionId) {                                                                                        // 967\n    self._subscriptionHandle = 'N' + self._subscriptionId;                                                           // 968\n  } else {                                                                                                           // 969\n    self._subscriptionHandle = 'U' + Random.id();                                                                    // 970\n  }                                                                                                                  // 971\n                                                                                                                     //\n  // has _deactivate been called?                                                                                    // 973\n  self._deactivated = false;                                                                                         // 974\n                                                                                                                     //\n  // stop callbacks to g/c this sub.  called w/ zero arguments.                                                      // 976\n  self._stopCallbacks = [];                                                                                          // 977\n                                                                                                                     //\n  // the set of (collection, documentid) that this subscription has                                                  // 979\n  // an opinion about                                                                                                // 980\n  self._documents = {};                                                                                              // 981\n                                                                                                                     //\n  // remember if we are ready.                                                                                       // 983\n  self._ready = false;                                                                                               // 984\n                                                                                                                     //\n  // Part of the public API: the user of this sub.                                                                   // 986\n                                                                                                                     //\n  /**                                                                                                                // 988\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.   //\n   * @locus Server                                                                                                   //\n   * @memberOf Subscription                                                                                          //\n   * @name  userId                                                                                                   //\n   * @instance                                                                                                       //\n   */                                                                                                                //\n  self.userId = session.userId;                                                                                      // 995\n                                                                                                                     //\n  // For now, the id filter is going to default to                                                                   // 997\n  // the to/from DDP methods on MongoID, to                                                                          // 998\n  // specifically deal with mongo/minimongo ObjectIds.                                                               // 999\n                                                                                                                     //\n  // Later, you will be able to make this be \"raw\"                                                                   // 1001\n  // if you want to publish a collection that you know                                                               // 1002\n  // just has strings for keys and no funny business, to                                                             // 1003\n  // a ddp consumer that isn't minimongo                                                                             // 1004\n                                                                                                                     //\n  self._idFilter = {                                                                                                 // 1006\n    idStringify: MongoID.idStringify,                                                                                // 1007\n    idParse: MongoID.idParse                                                                                         // 1008\n  };                                                                                                                 // 1006\n                                                                                                                     //\n  Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"subscriptions\", 1);                          // 1011\n};                                                                                                                   // 1013\n                                                                                                                     //\n_.extend(Subscription.prototype, {                                                                                   // 1015\n  _runHandler: function () {                                                                                         // 1016\n    function _runHandler() {                                                                                         // 1016\n      // XXX should we unblock() here? Either before running the publish                                             // 1017\n      // function, or before running _publishCursor.                                                                 // 1018\n      //                                                                                                             // 1019\n      // Right now, each publish function blocks all future publishes and                                            // 1020\n      // methods waiting on data from Mongo (or whatever else the function                                           // 1021\n      // blocks on). This probably slows page load in common cases.                                                  // 1022\n                                                                                                                     //\n      var self = this;                                                                                               // 1024\n      try {                                                                                                          // 1025\n        var res = maybeAuditArgumentChecks(self._handler, self, EJSON.clone(self._params),                           // 1026\n        // It's OK that this would look weird for universal subscriptions,                                           // 1028\n        // because they have no arguments so there can never be an                                                   // 1029\n        // audit-argument-checks failure.                                                                            // 1030\n        \"publisher '\" + self._name + \"'\");                                                                           // 1031\n      } catch (e) {                                                                                                  // 1032\n        self.error(e);                                                                                               // 1033\n        return;                                                                                                      // 1034\n      }                                                                                                              // 1035\n                                                                                                                     //\n      // Did the handler call this.error or this.stop?                                                               // 1037\n      if (self._isDeactivated()) return;                                                                             // 1038\n                                                                                                                     //\n      self._publishHandlerResult(res);                                                                               // 1041\n    }                                                                                                                // 1042\n                                                                                                                     //\n    return _runHandler;                                                                                              // 1016\n  }(),                                                                                                               // 1016\n                                                                                                                     //\n  _publishHandlerResult: function () {                                                                               // 1044\n    function _publishHandlerResult(res) {                                                                            // 1044\n      // SPECIAL CASE: Instead of writing their own callbacks that invoke                                            // 1045\n      // this.added/changed/ready/etc, the user can just return a collection                                         // 1046\n      // cursor or array of cursors from the publish function; we call their                                         // 1047\n      // _publishCursor method which starts observing the cursor and publishes the                                   // 1048\n      // results. Note that _publishCursor does NOT call ready().                                                    // 1049\n      //                                                                                                             // 1050\n      // XXX This uses an undocumented interface which only the Mongo cursor                                         // 1051\n      // interface publishes. Should we make this interface public and encourage                                     // 1052\n      // users to implement it themselves? Arguably, it's unnecessary; users can                                     // 1053\n      // already write their own functions like                                                                      // 1054\n      //   var publishMyReactiveThingy = function (name, handler) {                                                  // 1055\n      //     Meteor.publish(name, function () {                                                                      // 1056\n      //       var reactiveThingy = handler();                                                                       // 1057\n      //       reactiveThingy.publishMe();                                                                           // 1058\n      //     });                                                                                                     // 1059\n      //   };                                                                                                        // 1060\n                                                                                                                     //\n      var self = this;                                                                                               // 1062\n      var isCursor = function () {                                                                                   // 1063\n        function isCursor(c) {                                                                                       // 1063\n          return c && c._publishCursor;                                                                              // 1064\n        }                                                                                                            // 1065\n                                                                                                                     //\n        return isCursor;                                                                                             // 1063\n      }();                                                                                                           // 1063\n      if (isCursor(res)) {                                                                                           // 1066\n        try {                                                                                                        // 1067\n          res._publishCursor(self);                                                                                  // 1068\n        } catch (e) {                                                                                                // 1069\n          self.error(e);                                                                                             // 1070\n          return;                                                                                                    // 1071\n        }                                                                                                            // 1072\n        // _publishCursor only returns after the initial added callbacks have run.                                   // 1073\n        // mark subscription as ready.                                                                               // 1074\n        self.ready();                                                                                                // 1075\n      } else if (_.isArray(res)) {                                                                                   // 1076\n        // check all the elements are cursors                                                                        // 1077\n        if (!_.all(res, isCursor)) {                                                                                 // 1078\n          self.error(new Error(\"Publish function returned an array of non-Cursors\"));                                // 1079\n          return;                                                                                                    // 1080\n        }                                                                                                            // 1081\n        // find duplicate collection names                                                                           // 1082\n        // XXX we should support overlapping cursors, but that would require the                                     // 1083\n        // merge box to allow overlap within a subscription                                                          // 1084\n        var collectionNames = {};                                                                                    // 1085\n        for (var i = 0; i < res.length; ++i) {                                                                       // 1086\n          var collectionName = res[i]._getCollectionName();                                                          // 1087\n          if (_.has(collectionNames, collectionName)) {                                                              // 1088\n            self.error(new Error(\"Publish function returned multiple cursors for collection \" + collectionName));    // 1089\n            return;                                                                                                  // 1092\n          }                                                                                                          // 1093\n          collectionNames[collectionName] = true;                                                                    // 1094\n        };                                                                                                           // 1095\n                                                                                                                     //\n        try {                                                                                                        // 1097\n          _.each(res, function (cur) {                                                                               // 1098\n            cur._publishCursor(self);                                                                                // 1099\n          });                                                                                                        // 1100\n        } catch (e) {                                                                                                // 1101\n          self.error(e);                                                                                             // 1102\n          return;                                                                                                    // 1103\n        }                                                                                                            // 1104\n        self.ready();                                                                                                // 1105\n      } else if (res) {                                                                                              // 1106\n        // truthy values other than cursors or arrays are probably a                                                 // 1107\n        // user mistake (possible returning a Mongo document via, say,                                               // 1108\n        // `coll.findOne()`).                                                                                        // 1109\n        self.error(new Error(\"Publish function can only return a Cursor or \" + \"an array of Cursors\"));              // 1110\n      }                                                                                                              // 1112\n    }                                                                                                                // 1113\n                                                                                                                     //\n    return _publishHandlerResult;                                                                                    // 1044\n  }(),                                                                                                               // 1044\n                                                                                                                     //\n  // This calls all stop callbacks and prevents the handler from updating any                                        // 1115\n  // SessionCollectionViews further. It's used when the user unsubscribes or                                         // 1116\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send                                            // 1117\n  // removed messages for the published objects; if that is necessary, call                                          // 1118\n  // _removeAllDocuments first.                                                                                      // 1119\n  _deactivate: function () {                                                                                         // 1120\n    function _deactivate() {                                                                                         // 1120\n      var self = this;                                                                                               // 1121\n      if (self._deactivated) return;                                                                                 // 1122\n      self._deactivated = true;                                                                                      // 1124\n      self._callStopCallbacks();                                                                                     // 1125\n      Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"subscriptions\", -1);                     // 1126\n    }                                                                                                                // 1128\n                                                                                                                     //\n    return _deactivate;                                                                                              // 1120\n  }(),                                                                                                               // 1120\n                                                                                                                     //\n  _callStopCallbacks: function () {                                                                                  // 1130\n    function _callStopCallbacks() {                                                                                  // 1130\n      var self = this;                                                                                               // 1131\n      // tell listeners, so they can clean up                                                                        // 1132\n      var callbacks = self._stopCallbacks;                                                                           // 1133\n      self._stopCallbacks = [];                                                                                      // 1134\n      _.each(callbacks, function (callback) {                                                                        // 1135\n        callback();                                                                                                  // 1136\n      });                                                                                                            // 1137\n    }                                                                                                                // 1138\n                                                                                                                     //\n    return _callStopCallbacks;                                                                                       // 1130\n  }(),                                                                                                               // 1130\n                                                                                                                     //\n  // Send remove messages for every document.                                                                        // 1140\n  _removeAllDocuments: function () {                                                                                 // 1141\n    function _removeAllDocuments() {                                                                                 // 1141\n      var self = this;                                                                                               // 1142\n      Meteor._noYieldsAllowed(function () {                                                                          // 1143\n        _.each(self._documents, function (collectionDocs, collectionName) {                                          // 1144\n          // Iterate over _.keys instead of the dictionary itself, since we'll be                                    // 1145\n          // mutating it.                                                                                            // 1146\n          _.each(_.keys(collectionDocs), function (strId) {                                                          // 1147\n            self.removed(collectionName, self._idFilter.idParse(strId));                                             // 1148\n          });                                                                                                        // 1149\n        });                                                                                                          // 1150\n      });                                                                                                            // 1151\n    }                                                                                                                // 1152\n                                                                                                                     //\n    return _removeAllDocuments;                                                                                      // 1141\n  }(),                                                                                                               // 1141\n                                                                                                                     //\n  // Returns a new Subscription for the same session with the same                                                   // 1154\n  // initial creation parameters. This isn't a clone: it doesn't have                                                // 1155\n  // the same _documents cache, stopped state or callbacks; may have a                                               // 1156\n  // different _subscriptionHandle, and gets its userId from the                                                     // 1157\n  // session, not from this object.                                                                                  // 1158\n  _recreate: function () {                                                                                           // 1159\n    function _recreate() {                                                                                           // 1159\n      var self = this;                                                                                               // 1160\n      return new Subscription(self._session, self._handler, self._subscriptionId, self._params, self._name);         // 1161\n    }                                                                                                                // 1164\n                                                                                                                     //\n    return _recreate;                                                                                                // 1159\n  }(),                                                                                                               // 1159\n                                                                                                                     //\n  /**                                                                                                                // 1166\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server                                                                                                   //\n   * @param {Error} error The error to pass to the client.                                                           //\n   * @instance                                                                                                       //\n   * @memberOf Subscription                                                                                          //\n   */                                                                                                                //\n  error: function () {                                                                                               // 1173\n    function error(_error) {                                                                                         // 1173\n      var self = this;                                                                                               // 1174\n      if (self._isDeactivated()) return;                                                                             // 1175\n      self._session._stopSubscription(self._subscriptionId, _error);                                                 // 1177\n    }                                                                                                                // 1178\n                                                                                                                     //\n    return error;                                                                                                    // 1173\n  }(),                                                                                                               // 1173\n                                                                                                                     //\n  // Note that while our DDP client will notice that you've called stop() on the                                     // 1180\n  // server (and clean up its _subscriptions table) we don't actually provide a                                      // 1181\n  // mechanism for an app to notice this (the subscribe onError callback only                                        // 1182\n  // triggers if there is an error).                                                                                 // 1183\n                                                                                                                     //\n  /**                                                                                                                // 1185\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server                                                                                                   //\n   * @instance                                                                                                       //\n   * @memberOf Subscription                                                                                          //\n   */                                                                                                                //\n  stop: function () {                                                                                                // 1191\n    function stop() {                                                                                                // 1191\n      var self = this;                                                                                               // 1192\n      if (self._isDeactivated()) return;                                                                             // 1193\n      self._session._stopSubscription(self._subscriptionId);                                                         // 1195\n    }                                                                                                                // 1196\n                                                                                                                     //\n    return stop;                                                                                                     // 1191\n  }(),                                                                                                               // 1191\n                                                                                                                     //\n  /**                                                                                                                // 1198\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server                                                                                                   //\n   * @memberOf Subscription                                                                                          //\n   * @instance                                                                                                       //\n   * @param {Function} func The callback function                                                                    //\n   */                                                                                                                //\n  onStop: function () {                                                                                              // 1205\n    function onStop(callback) {                                                                                      // 1205\n      var self = this;                                                                                               // 1206\n      if (self._isDeactivated()) callback();else self._stopCallbacks.push(callback);                                 // 1207\n    }                                                                                                                // 1211\n                                                                                                                     //\n    return onStop;                                                                                                   // 1205\n  }(),                                                                                                               // 1205\n                                                                                                                     //\n  // This returns true if the sub has been deactivated, *OR* if the session was                                      // 1213\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't                                           // 1214\n  // happened yet.                                                                                                   // 1215\n  _isDeactivated: function () {                                                                                      // 1216\n    function _isDeactivated() {                                                                                      // 1216\n      var self = this;                                                                                               // 1217\n      return self._deactivated || self._session.inQueue === null;                                                    // 1218\n    }                                                                                                                // 1219\n                                                                                                                     //\n    return _isDeactivated;                                                                                           // 1216\n  }(),                                                                                                               // 1216\n                                                                                                                     //\n  /**                                                                                                                // 1221\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server                                                                                                   //\n   * @memberOf Subscription                                                                                          //\n   * @instance                                                                                                       //\n   * @param {String} collection The name of the collection that contains the new document.                           //\n   * @param {String} id The new document's ID.                                                                       //\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.                      //\n   */                                                                                                                //\n  added: function () {                                                                                               // 1230\n    function added(collectionName, id, fields) {                                                                     // 1230\n      var self = this;                                                                                               // 1231\n      if (self._isDeactivated()) return;                                                                             // 1232\n      id = self._idFilter.idStringify(id);                                                                           // 1234\n      Meteor._ensure(self._documents, collectionName)[id] = true;                                                    // 1235\n      self._session.added(self._subscriptionHandle, collectionName, id, fields);                                     // 1236\n    }                                                                                                                // 1237\n                                                                                                                     //\n    return added;                                                                                                    // 1230\n  }(),                                                                                                               // 1230\n                                                                                                                     //\n  /**                                                                                                                // 1239\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server                                                                                                   //\n   * @memberOf Subscription                                                                                          //\n   * @instance                                                                                                       //\n   * @param {String} collection The name of the collection that contains the changed document.                       //\n   * @param {String} id The changed document's ID.                                                                   //\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */                                                                                                                //\n  changed: function () {                                                                                             // 1248\n    function changed(collectionName, id, fields) {                                                                   // 1248\n      var self = this;                                                                                               // 1249\n      if (self._isDeactivated()) return;                                                                             // 1250\n      id = self._idFilter.idStringify(id);                                                                           // 1252\n      self._session.changed(self._subscriptionHandle, collectionName, id, fields);                                   // 1253\n    }                                                                                                                // 1254\n                                                                                                                     //\n    return changed;                                                                                                  // 1248\n  }(),                                                                                                               // 1248\n                                                                                                                     //\n  /**                                                                                                                // 1256\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server                                                                                                   //\n   * @memberOf Subscription                                                                                          //\n   * @instance                                                                                                       //\n   * @param {String} collection The name of the collection that the document has been removed from.                  //\n   * @param {String} id The ID of the document that has been removed.                                                //\n   */                                                                                                                //\n  removed: function () {                                                                                             // 1264\n    function removed(collectionName, id) {                                                                           // 1264\n      var self = this;                                                                                               // 1265\n      if (self._isDeactivated()) return;                                                                             // 1266\n      id = self._idFilter.idStringify(id);                                                                           // 1268\n      // We don't bother to delete sets of things in a collection if the                                             // 1269\n      // collection is empty.  It could break _removeAllDocuments.                                                   // 1270\n      delete self._documents[collectionName][id];                                                                    // 1271\n      self._session.removed(self._subscriptionHandle, collectionName, id);                                           // 1272\n    }                                                                                                                // 1273\n                                                                                                                     //\n    return removed;                                                                                                  // 1264\n  }(),                                                                                                               // 1264\n                                                                                                                     //\n  /**                                                                                                                // 1275\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server                                                                                                   //\n   * @memberOf Subscription                                                                                          //\n   * @instance                                                                                                       //\n   */                                                                                                                //\n  ready: function () {                                                                                               // 1281\n    function ready() {                                                                                               // 1281\n      var self = this;                                                                                               // 1282\n      if (self._isDeactivated()) return;                                                                             // 1283\n      if (!self._subscriptionId) return; // unnecessary but ignored for universal sub                                // 1285\n      if (!self._ready) {                                                                                            // 1287\n        self._session.sendReady([self._subscriptionId]);                                                             // 1288\n        self._ready = true;                                                                                          // 1289\n      }                                                                                                              // 1290\n    }                                                                                                                // 1291\n                                                                                                                     //\n    return ready;                                                                                                    // 1281\n  }()                                                                                                                // 1281\n});                                                                                                                  // 1015\n                                                                                                                     //\n/******************************************************************************/                                     // 1294\n/* Server                                                                     */                                     // 1295\n/******************************************************************************/                                     // 1296\n                                                                                                                     //\nServer = function Server(options) {                                                                                  // 1298\n  var self = this;                                                                                                   // 1299\n                                                                                                                     //\n  // The default heartbeat interval is 30 seconds on the server and 35                                               // 1301\n  // seconds on the client.  Since the client doesn't need to send a                                                 // 1302\n  // ping as long as it is receiving pings, this means that pings                                                    // 1303\n  // normally go from the server to the client.                                                                      // 1304\n  //                                                                                                                 // 1305\n  // Note: Troposphere depends on the ability to mutate                                                              // 1306\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.                                          // 1307\n  self.options = _.defaults(options || {}, {                                                                         // 1308\n    heartbeatInterval: 15000,                                                                                        // 1309\n    heartbeatTimeout: 15000,                                                                                         // 1310\n    // For testing, allow responding to pings to be disabled.                                                        // 1311\n    respondToPings: true                                                                                             // 1312\n  });                                                                                                                // 1308\n                                                                                                                     //\n  // Map of callbacks to call when a new connection comes in to the                                                  // 1315\n  // server and completes DDP version negotiation. Use an object instead                                             // 1316\n  // of an array so we can safely remove one from the list while                                                     // 1317\n  // iterating over it.                                                                                              // 1318\n  self.onConnectionHook = new Hook({                                                                                 // 1319\n    debugPrintExceptions: \"onConnection callback\"                                                                    // 1320\n  });                                                                                                                // 1319\n                                                                                                                     //\n  self.publish_handlers = {};                                                                                        // 1323\n  self.universal_publish_handlers = [];                                                                              // 1324\n                                                                                                                     //\n  self.method_handlers = {};                                                                                         // 1326\n                                                                                                                     //\n  self.sessions = {}; // map from id to session                                                                      // 1328\n                                                                                                                     //\n  self.stream_server = new StreamServer();                                                                           // 1330\n                                                                                                                     //\n  self.stream_server.register(function (socket) {                                                                    // 1332\n    // socket implements the SockJSConnection interface                                                              // 1333\n    socket._meteorSession = null;                                                                                    // 1334\n                                                                                                                     //\n    var sendError = function sendError(reason, offendingMessage) {                                                   // 1336\n      var msg = { msg: 'error', reason: reason };                                                                    // 1337\n      if (offendingMessage) msg.offendingMessage = offendingMessage;                                                 // 1338\n      socket.send(DDPCommon.stringifyDDP(msg));                                                                      // 1340\n    };                                                                                                               // 1341\n                                                                                                                     //\n    socket.on('data', function (raw_msg) {                                                                           // 1343\n      if (Meteor._printReceivedDDP) {                                                                                // 1344\n        Meteor._debug(\"Received DDP\", raw_msg);                                                                      // 1345\n      }                                                                                                              // 1346\n      try {                                                                                                          // 1347\n        try {                                                                                                        // 1348\n          var msg = DDPCommon.parseDDP(raw_msg);                                                                     // 1349\n        } catch (err) {                                                                                              // 1350\n          sendError('Parse error');                                                                                  // 1351\n          return;                                                                                                    // 1352\n        }                                                                                                            // 1353\n        if (msg === null || !msg.msg) {                                                                              // 1354\n          sendError('Bad request', msg);                                                                             // 1355\n          return;                                                                                                    // 1356\n        }                                                                                                            // 1357\n                                                                                                                     //\n        if (msg.msg === 'connect') {                                                                                 // 1359\n          if (socket._meteorSession) {                                                                               // 1360\n            sendError(\"Already connected\", msg);                                                                     // 1361\n            return;                                                                                                  // 1362\n          }                                                                                                          // 1363\n          Fiber(function () {                                                                                        // 1364\n            self._handleConnect(socket, msg);                                                                        // 1365\n          }).run();                                                                                                  // 1366\n          return;                                                                                                    // 1367\n        }                                                                                                            // 1368\n                                                                                                                     //\n        if (!socket._meteorSession) {                                                                                // 1370\n          sendError('Must connect first', msg);                                                                      // 1371\n          return;                                                                                                    // 1372\n        }                                                                                                            // 1373\n        socket._meteorSession.processMessage(msg);                                                                   // 1374\n      } catch (e) {                                                                                                  // 1375\n        // XXX print stack nicely                                                                                    // 1376\n        Meteor._debug(\"Internal exception while processing message\", msg, e.message, e.stack);                       // 1377\n      }                                                                                                              // 1379\n    });                                                                                                              // 1380\n                                                                                                                     //\n    socket.on('close', function () {                                                                                 // 1382\n      if (socket._meteorSession) {                                                                                   // 1383\n        Fiber(function () {                                                                                          // 1384\n          socket._meteorSession.close();                                                                             // 1385\n        }).run();                                                                                                    // 1386\n      }                                                                                                              // 1387\n    });                                                                                                              // 1388\n  });                                                                                                                // 1389\n};                                                                                                                   // 1390\n                                                                                                                     //\n_.extend(Server.prototype, {                                                                                         // 1392\n                                                                                                                     //\n  /**                                                                                                                // 1394\n   * @summary Register a callback to be called when a new DDP connection is made to the server.                      //\n   * @locus Server                                                                                                   //\n   * @param {function} callback The function to call when a new DDP connection is established.                       //\n   * @memberOf Meteor                                                                                                //\n   * @importFromPackage meteor                                                                                       //\n   */                                                                                                                //\n  onConnection: function () {                                                                                        // 1401\n    function onConnection(fn) {                                                                                      // 1401\n      var self = this;                                                                                               // 1402\n      return self.onConnectionHook.register(fn);                                                                     // 1403\n    }                                                                                                                // 1404\n                                                                                                                     //\n    return onConnection;                                                                                             // 1401\n  }(),                                                                                                               // 1401\n                                                                                                                     //\n  _handleConnect: function () {                                                                                      // 1406\n    function _handleConnect(socket, msg) {                                                                           // 1406\n      var self = this;                                                                                               // 1407\n                                                                                                                     //\n      // The connect message must specify a version and an array of supported                                        // 1409\n      // versions, and it must claim to support what it is proposing.                                                // 1410\n      if (!(typeof msg.version === 'string' && _.isArray(msg.support) && _.all(msg.support, _.isString) && _.contains(msg.support, msg.version))) {\n        socket.send(DDPCommon.stringifyDDP({ msg: 'failed',                                                          // 1415\n          version: DDPCommon.SUPPORTED_DDP_VERSIONS[0] }));                                                          // 1416\n        socket.close();                                                                                              // 1417\n        return;                                                                                                      // 1418\n      }                                                                                                              // 1419\n                                                                                                                     //\n      // In the future, handle session resumption: something like:                                                   // 1421\n      //  socket._meteorSession = self.sessions[msg.session]                                                         // 1422\n      var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);                                 // 1423\n                                                                                                                     //\n      if (msg.version !== version) {                                                                                 // 1425\n        // The best version to use (according to the client's stated preferences)                                    // 1426\n        // is not the one the client is trying to use. Inform them about the best                                    // 1427\n        // version to use.                                                                                           // 1428\n        socket.send(DDPCommon.stringifyDDP({ msg: 'failed', version: version }));                                    // 1429\n        socket.close();                                                                                              // 1430\n        return;                                                                                                      // 1431\n      }                                                                                                              // 1432\n                                                                                                                     //\n      // Yay, version matches! Create a new session.                                                                 // 1434\n      // Note: Troposphere depends on the ability to mutate                                                          // 1435\n      // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.                                      // 1436\n      socket._meteorSession = new Session(self, version, socket, self.options);                                      // 1437\n      self.sessions[socket._meteorSession.id] = socket._meteorSession;                                               // 1438\n      self.onConnectionHook.each(function (callback) {                                                               // 1439\n        if (socket._meteorSession) callback(socket._meteorSession.connectionHandle);                                 // 1440\n        return true;                                                                                                 // 1442\n      });                                                                                                            // 1443\n    }                                                                                                                // 1444\n                                                                                                                     //\n    return _handleConnect;                                                                                           // 1406\n  }(),                                                                                                               // 1406\n  /**                                                                                                                // 1445\n   * Register a publish handler function.                                                                            //\n   *                                                                                                                 //\n   * @param name {String} identifier for query                                                                       //\n   * @param handler {Function} publish handler                                                                       //\n   * @param options {Object}                                                                                         //\n   *                                                                                                                 //\n   * Server will call handler function on each new subscription,                                                     //\n   * either when receiving DDP sub message for a named subscription, or on                                           //\n   * DDP connect for a universal subscription.                                                                       //\n   *                                                                                                                 //\n   * If name is null, this will be a subscription that is                                                            //\n   * automatically established and permanently on for all connected                                                  //\n   * client, instead of a subscription that can be turned on and off                                                 //\n   * with subscribe().                                                                                               //\n   *                                                                                                                 //\n   * options to contain:                                                                                             //\n   *  - (mostly internal) is_auto: true if generated automatically                                                   //\n   *    from an autopublish hook. this is for cosmetic purposes only                                                 //\n   *    (it lets us determine whether to print a warning suggesting                                                  //\n   *    that you turn off autopublish.)                                                                              //\n   */                                                                                                                //\n                                                                                                                     //\n  /**                                                                                                                // 1468\n   * @summary Publish a record set.                                                                                  //\n   * @memberOf Meteor                                                                                                //\n   * @importFromPackage meteor                                                                                       //\n   * @locus Server                                                                                                   //\n   * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */                                                                                                                //\n  publish: function () {                                                                                             // 1476\n    function publish(name, handler, options) {                                                                       // 1476\n      var self = this;                                                                                               // 1477\n                                                                                                                     //\n      if (!_.isObject(name)) {                                                                                       // 1479\n        options = options || {};                                                                                     // 1480\n                                                                                                                     //\n        if (name && name in self.publish_handlers) {                                                                 // 1482\n          Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");                                          // 1483\n          return;                                                                                                    // 1484\n        }                                                                                                            // 1485\n                                                                                                                     //\n        if (Package.autopublish && !options.is_auto) {                                                               // 1487\n          // They have autopublish on, yet they're trying to manually                                                // 1488\n          // picking stuff to publish. They probably should turn off                                                 // 1489\n          // autopublish. (This check isn't perfect -- if you create a                                               // 1490\n          // publish before you turn on autopublish, it won't catch                                                  // 1491\n          // it. But this will definitely handle the simple case where                                               // 1492\n          // you've added the autopublish package to your app, and are                                               // 1493\n          // calling publish from your app code.)                                                                    // 1494\n          if (!self.warned_about_autopublish) {                                                                      // 1495\n            self.warned_about_autopublish = true;                                                                    // 1496\n            Meteor._debug(\"** You've set up some data subscriptions with Meteor.publish(), but\\n\" + \"** you still have autopublish turned on. Because autopublish is still\\n\" + \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" + \"** will still be sent to all clients.\\n\" + \"**\\n\" + \"** Turn off autopublish by removing the autopublish package:\\n\" + \"**\\n\" + \"**   $ meteor remove autopublish\\n\" + \"**\\n\" + \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" + \"** for each collection that you want clients to see.\\n\");\n          }                                                                                                          // 1509\n        }                                                                                                            // 1510\n                                                                                                                     //\n        if (name) self.publish_handlers[name] = handler;else {                                                       // 1512\n          self.universal_publish_handlers.push(handler);                                                             // 1515\n          // Spin up the new publisher on any existing session too. Run each                                         // 1516\n          // session's subscription in a new Fiber, so that there's no change for                                    // 1517\n          // self.sessions to change while we're running this loop.                                                  // 1518\n          _.each(self.sessions, function (session) {                                                                 // 1519\n            if (!session._dontStartNewUniversalSubs) {                                                               // 1520\n              Fiber(function () {                                                                                    // 1521\n                session._startSubscription(handler);                                                                 // 1522\n              }).run();                                                                                              // 1523\n            }                                                                                                        // 1524\n          });                                                                                                        // 1525\n        }                                                                                                            // 1526\n      } else {                                                                                                       // 1527\n        _.each(name, function (value, key) {                                                                         // 1529\n          self.publish(key, value, {});                                                                              // 1530\n        });                                                                                                          // 1531\n      }                                                                                                              // 1532\n    }                                                                                                                // 1533\n                                                                                                                     //\n    return publish;                                                                                                  // 1476\n  }(),                                                                                                               // 1476\n                                                                                                                     //\n  _removeSession: function () {                                                                                      // 1535\n    function _removeSession(session) {                                                                               // 1535\n      var self = this;                                                                                               // 1536\n      if (self.sessions[session.id]) {                                                                               // 1537\n        delete self.sessions[session.id];                                                                            // 1538\n      }                                                                                                              // 1539\n    }                                                                                                                // 1540\n                                                                                                                     //\n    return _removeSession;                                                                                           // 1535\n  }(),                                                                                                               // 1535\n                                                                                                                     //\n  /**                                                                                                                // 1542\n   * @summary Defines functions that can be invoked over the network by clients.                                     //\n   * @locus Anywhere                                                                                                 //\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.                        //\n   * @memberOf Meteor                                                                                                //\n   * @importFromPackage meteor                                                                                       //\n   */                                                                                                                //\n  methods: function () {                                                                                             // 1549\n    function methods(_methods) {                                                                                     // 1549\n      var self = this;                                                                                               // 1550\n      _.each(_methods, function (func, name) {                                                                       // 1551\n        if (typeof func !== 'function') throw new Error(\"Method '\" + name + \"' must be a function\");                 // 1552\n        if (self.method_handlers[name]) throw new Error(\"A method named '\" + name + \"' is already defined\");         // 1554\n        self.method_handlers[name] = func;                                                                           // 1556\n      });                                                                                                            // 1557\n    }                                                                                                                // 1558\n                                                                                                                     //\n    return methods;                                                                                                  // 1549\n  }(),                                                                                                               // 1549\n                                                                                                                     //\n  call: function () {                                                                                                // 1560\n    function call(name /*, arguments */) {                                                                           // 1560\n      // if it's a function, the last argument is the result callback,                                               // 1561\n      // not a parameter to the remote method.                                                                       // 1562\n      var args = Array.prototype.slice.call(arguments, 1);                                                           // 1563\n      if (args.length && typeof args[args.length - 1] === \"function\") var callback = args.pop();                     // 1564\n      return this.apply(name, args, callback);                                                                       // 1566\n    }                                                                                                                // 1567\n                                                                                                                     //\n    return call;                                                                                                     // 1560\n  }(),                                                                                                               // 1560\n                                                                                                                     //\n  // @param options {Optional Object}                                                                                // 1569\n  // @param callback {Optional Function}                                                                             // 1570\n  apply: function () {                                                                                               // 1571\n    function apply(name, args, options, callback) {                                                                  // 1571\n      var self = this;                                                                                               // 1572\n                                                                                                                     //\n      // We were passed 3 arguments. They may be either (name, args, options)                                        // 1574\n      // or (name, args, callback)                                                                                   // 1575\n      if (!callback && typeof options === 'function') {                                                              // 1576\n        callback = options;                                                                                          // 1577\n        options = {};                                                                                                // 1578\n      }                                                                                                              // 1579\n      options = options || {};                                                                                       // 1580\n                                                                                                                     //\n      if (callback)                                                                                                  // 1582\n        // It's not really necessary to do this, since we immediately                                                // 1583\n        // run the callback in this fiber before returning, but we do it                                             // 1584\n        // anyway for regularity.                                                                                    // 1585\n        // XXX improve error message (and how we report it)                                                          // 1586\n        callback = Meteor.bindEnvironment(callback, \"delivering result of invoking '\" + name + \"'\");                 // 1587\n                                                                                                                     //\n      // Run the handler                                                                                             // 1592\n      var handler = self.method_handlers[name];                                                                      // 1593\n      var exception;                                                                                                 // 1594\n      if (!handler) {                                                                                                // 1595\n        exception = new Meteor.Error(404, \"Method '\" + name + \"' not found\");                                        // 1596\n      } else {                                                                                                       // 1597\n        // If this is a method call from within another method, get the                                              // 1598\n        // user state from the outer method, otherwise don't allow                                                   // 1599\n        // setUserId to be called                                                                                    // 1600\n        var userId = null;                                                                                           // 1601\n        var setUserId = function () {                                                                                // 1602\n          function setUserId() {                                                                                     // 1602\n            throw new Error(\"Can't call setUserId on a server initiated method call\");                               // 1603\n          }                                                                                                          // 1604\n                                                                                                                     //\n          return setUserId;                                                                                          // 1602\n        }();                                                                                                         // 1602\n        var connection = null;                                                                                       // 1605\n        var currentInvocation = DDP._CurrentInvocation.get();                                                        // 1606\n        if (currentInvocation) {                                                                                     // 1607\n          userId = currentInvocation.userId;                                                                         // 1608\n          setUserId = function () {                                                                                  // 1609\n            function setUserId(userId) {                                                                             // 1609\n              currentInvocation.setUserId(userId);                                                                   // 1610\n            }                                                                                                        // 1611\n                                                                                                                     //\n            return setUserId;                                                                                        // 1609\n          }();                                                                                                       // 1609\n          connection = currentInvocation.connection;                                                                 // 1612\n        }                                                                                                            // 1613\n                                                                                                                     //\n        var invocation = new DDPCommon.MethodInvocation({                                                            // 1615\n          isSimulation: false,                                                                                       // 1616\n          userId: userId,                                                                                            // 1617\n          setUserId: setUserId,                                                                                      // 1618\n          connection: connection,                                                                                    // 1619\n          randomSeed: DDPCommon.makeRpcSeed(currentInvocation, name)                                                 // 1620\n        });                                                                                                          // 1615\n        try {                                                                                                        // 1622\n          var result = DDP._CurrentInvocation.withValue(invocation, function () {                                    // 1623\n            return maybeAuditArgumentChecks(handler, invocation, EJSON.clone(args), \"internal call to '\" + name + \"'\");\n          });                                                                                                        // 1627\n          result = EJSON.clone(result);                                                                              // 1628\n        } catch (e) {                                                                                                // 1629\n          exception = e;                                                                                             // 1630\n        }                                                                                                            // 1631\n      }                                                                                                              // 1632\n                                                                                                                     //\n      // Return the result in whichever way the caller asked for it. Note that we                                    // 1634\n      // do NOT block on the write fence in an analogous way to how the client                                       // 1635\n      // blocks on the relevant data being visible, so you are NOT guaranteed that                                   // 1636\n      // cursor observe callbacks have fired when your callback is invoked. (We                                      // 1637\n      // can change this if there's a real use case.)                                                                // 1638\n      if (callback) {                                                                                                // 1639\n        callback(exception, result);                                                                                 // 1640\n        return undefined;                                                                                            // 1641\n      }                                                                                                              // 1642\n      if (exception) throw exception;                                                                                // 1643\n      return result;                                                                                                 // 1645\n    }                                                                                                                // 1646\n                                                                                                                     //\n    return apply;                                                                                                    // 1571\n  }(),                                                                                                               // 1571\n                                                                                                                     //\n  _urlForSession: function () {                                                                                      // 1648\n    function _urlForSession(sessionId) {                                                                             // 1648\n      var self = this;                                                                                               // 1649\n      var session = self.sessions[sessionId];                                                                        // 1650\n      if (session) return session._socketUrl;else return null;                                                       // 1651\n    }                                                                                                                // 1655\n                                                                                                                     //\n    return _urlForSession;                                                                                           // 1648\n  }()                                                                                                                // 1648\n});                                                                                                                  // 1392\n                                                                                                                     //\nvar calculateVersion = function calculateVersion(clientSupportedVersions, serverSupportedVersions) {                 // 1658\n  var correctVersion = _.find(clientSupportedVersions, function (version) {                                          // 1660\n    return _.contains(serverSupportedVersions, version);                                                             // 1661\n  });                                                                                                                // 1662\n  if (!correctVersion) {                                                                                             // 1663\n    correctVersion = serverSupportedVersions[0];                                                                     // 1664\n  }                                                                                                                  // 1665\n  return correctVersion;                                                                                             // 1666\n};                                                                                                                   // 1667\n                                                                                                                     //\nDDPServer._calculateVersion = calculateVersion;                                                                      // 1669\n                                                                                                                     //\n// \"blind\" exceptions other than those that were deliberately thrown to signal                                       // 1672\n// errors to the client                                                                                              // 1673\nvar wrapInternalException = function wrapInternalException(exception, context) {                                     // 1674\n  if (!exception || exception instanceof Meteor.Error) return exception;                                             // 1675\n                                                                                                                     //\n  // tests can set the 'expected' flag on an exception so it won't go to the                                         // 1678\n  // server log                                                                                                      // 1679\n  if (!exception.expected) {                                                                                         // 1680\n    Meteor._debug(\"Exception \" + context, exception.stack);                                                          // 1681\n    if (exception.sanitizedError) {                                                                                  // 1682\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError.message);                   // 1683\n      Meteor._debug();                                                                                               // 1684\n    }                                                                                                                // 1685\n  }                                                                                                                  // 1686\n                                                                                                                     //\n  // Did the error contain more details that could have been useful if caught in                                     // 1688\n  // server code (or if thrown from non-client-originated code), but also                                            // 1689\n  // provided a \"sanitized\" version with more context than 500 Internal server                                       // 1690\n  // error? Use that.                                                                                                // 1691\n  if (exception.sanitizedError) {                                                                                    // 1692\n    if (exception.sanitizedError instanceof Meteor.Error) return exception.sanitizedError;                           // 1693\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" + \"is not a Meteor.Error; ignoring\");  // 1695\n  }                                                                                                                  // 1697\n                                                                                                                     //\n  return new Meteor.Error(500, \"Internal server error\");                                                             // 1699\n};                                                                                                                   // 1700\n                                                                                                                     //\n// Audit argument checks, if the audit-argument-checks package exists (it is a                                       // 1703\n// weak dependency of this package).                                                                                 // 1704\nvar maybeAuditArgumentChecks = function maybeAuditArgumentChecks(f, context, args, description) {                    // 1705\n  args = args || [];                                                                                                 // 1706\n  if (Package['audit-argument-checks']) {                                                                            // 1707\n    return Match._failIfArgumentsAreNotAllChecked(f, context, args, description);                                    // 1708\n  }                                                                                                                  // 1710\n  return f.apply(context, args);                                                                                     // 1711\n};                                                                                                                   // 1712\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"writefence.js\":function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-server/writefence.js                                                                                 //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar path = Npm.require('path');                                                                                      // 1\nvar Future = Npm.require(path.join('fibers', 'future'));                                                             // 2\n                                                                                                                     //\n// A write fence collects a group of writes, and provides a callback                                                 // 4\n// when all of the writes are fully committed and propagated (all                                                    // 5\n// observers have been notified of the write and acknowledged it.)                                                   // 6\n//                                                                                                                   // 7\nDDPServer._WriteFence = function () {                                                                                // 8\n  var self = this;                                                                                                   // 9\n                                                                                                                     //\n  self.armed = false;                                                                                                // 11\n  self.fired = false;                                                                                                // 12\n  self.retired = false;                                                                                              // 13\n  self.outstanding_writes = 0;                                                                                       // 14\n  self.before_fire_callbacks = [];                                                                                   // 15\n  self.completion_callbacks = [];                                                                                    // 16\n};                                                                                                                   // 17\n                                                                                                                     //\n// The current write fence. When there is a current write fence, code                                                // 19\n// that writes to databases should register their writes with it using                                               // 20\n// beginWrite().                                                                                                     // 21\n//                                                                                                                   // 22\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable();                                                     // 23\n                                                                                                                     //\n_.extend(DDPServer._WriteFence.prototype, {                                                                          // 25\n  // Start tracking a write, and return an object to represent it. The                                               // 26\n  // object has a single method, committed(). This method should be                                                  // 27\n  // called when the write is fully committed and propagated. You can                                                // 28\n  // continue to add writes to the WriteFence up until it is triggered                                               // 29\n  // (calls its callbacks because all writes have committed.)                                                        // 30\n  beginWrite: function () {                                                                                          // 31\n    function beginWrite() {                                                                                          // 31\n      var self = this;                                                                                               // 32\n                                                                                                                     //\n      if (self.retired) return { committed: function () {                                                            // 34\n          function committed() {}                                                                                    // 35\n                                                                                                                     //\n          return committed;                                                                                          // 35\n        }() };                                                                                                       // 35\n                                                                                                                     //\n      if (self.fired) throw new Error(\"fence has already activated -- too late to add writes\");                      // 37\n                                                                                                                     //\n      self.outstanding_writes++;                                                                                     // 40\n      var _committed = false;                                                                                        // 41\n      return {                                                                                                       // 42\n        committed: function () {                                                                                     // 43\n          function committed() {                                                                                     // 43\n            if (_committed) throw new Error(\"committed called twice on the same write\");                             // 44\n            _committed = true;                                                                                       // 46\n            self.outstanding_writes--;                                                                               // 47\n            self._maybeFire();                                                                                       // 48\n          }                                                                                                          // 49\n                                                                                                                     //\n          return committed;                                                                                          // 43\n        }()                                                                                                          // 43\n      };                                                                                                             // 42\n    }                                                                                                                // 51\n                                                                                                                     //\n    return beginWrite;                                                                                               // 31\n  }(),                                                                                                               // 31\n                                                                                                                     //\n  // Arm the fence. Once the fence is armed, and there are no more                                                   // 53\n  // uncommitted writes, it will activate.                                                                           // 54\n  arm: function () {                                                                                                 // 55\n    function arm() {                                                                                                 // 55\n      var self = this;                                                                                               // 56\n      if (self === DDPServer._CurrentWriteFence.get()) throw Error(\"Can't arm the current fence\");                   // 57\n      self.armed = true;                                                                                             // 59\n      self._maybeFire();                                                                                             // 60\n    }                                                                                                                // 61\n                                                                                                                     //\n    return arm;                                                                                                      // 55\n  }(),                                                                                                               // 55\n                                                                                                                     //\n  // Register a function to be called once before firing the fence.                                                  // 63\n  // Callback function can add new writes to the fence, in which case                                                // 64\n  // it won't fire until those writes are done as well.                                                              // 65\n  onBeforeFire: function () {                                                                                        // 66\n    function onBeforeFire(func) {                                                                                    // 66\n      var self = this;                                                                                               // 67\n      if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");             // 68\n      self.before_fire_callbacks.push(func);                                                                         // 71\n    }                                                                                                                // 72\n                                                                                                                     //\n    return onBeforeFire;                                                                                             // 66\n  }(),                                                                                                               // 66\n                                                                                                                     //\n  // Register a function to be called when the fence fires.                                                          // 74\n  onAllCommitted: function () {                                                                                      // 75\n    function onAllCommitted(func) {                                                                                  // 75\n      var self = this;                                                                                               // 76\n      if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");             // 77\n      self.completion_callbacks.push(func);                                                                          // 80\n    }                                                                                                                // 81\n                                                                                                                     //\n    return onAllCommitted;                                                                                           // 75\n  }(),                                                                                                               // 75\n                                                                                                                     //\n  // Convenience function. Arms the fence, then blocks until it fires.                                               // 83\n  armAndWait: function () {                                                                                          // 84\n    function armAndWait() {                                                                                          // 84\n      var self = this;                                                                                               // 85\n      var future = new Future();                                                                                     // 86\n      self.onAllCommitted(function () {                                                                              // 87\n        future['return']();                                                                                          // 88\n      });                                                                                                            // 89\n      self.arm();                                                                                                    // 90\n      future.wait();                                                                                                 // 91\n    }                                                                                                                // 92\n                                                                                                                     //\n    return armAndWait;                                                                                               // 84\n  }(),                                                                                                               // 84\n                                                                                                                     //\n  _maybeFire: function () {                                                                                          // 94\n    function _maybeFire() {                                                                                          // 94\n      var self = this;                                                                                               // 95\n      if (self.fired) throw new Error(\"write fence already activated?\");                                             // 96\n      if (self.armed && !self.outstanding_writes) {                                                                  // 98\n        var invokeCallback = function () {                                                                           // 98\n          function invokeCallback(func) {                                                                            // 99\n            try {                                                                                                    // 100\n              func(self);                                                                                            // 101\n            } catch (err) {                                                                                          // 102\n              Meteor._debug(\"exception in write fence callback:\", err);                                              // 103\n            }                                                                                                        // 104\n          }                                                                                                          // 105\n                                                                                                                     //\n          return invokeCallback;                                                                                     // 98\n        }();                                                                                                         // 98\n                                                                                                                     //\n        self.outstanding_writes++;                                                                                   // 107\n        while (self.before_fire_callbacks.length > 0) {                                                              // 108\n          var callbacks = self.before_fire_callbacks;                                                                // 109\n          self.before_fire_callbacks = [];                                                                           // 110\n          _.each(callbacks, invokeCallback);                                                                         // 111\n        }                                                                                                            // 112\n        self.outstanding_writes--;                                                                                   // 113\n                                                                                                                     //\n        if (!self.outstanding_writes) {                                                                              // 115\n          self.fired = true;                                                                                         // 116\n          var callbacks = self.completion_callbacks;                                                                 // 117\n          self.completion_callbacks = [];                                                                            // 118\n          _.each(callbacks, invokeCallback);                                                                         // 119\n        }                                                                                                            // 120\n      }                                                                                                              // 121\n    }                                                                                                                // 122\n                                                                                                                     //\n    return _maybeFire;                                                                                               // 94\n  }(),                                                                                                               // 94\n                                                                                                                     //\n  // Deactivate this fence so that adding more writes has no effect.                                                 // 124\n  // The fence must have already fired.                                                                              // 125\n  retire: function () {                                                                                              // 126\n    function retire() {                                                                                              // 126\n      var self = this;                                                                                               // 127\n      if (!self.fired) throw new Error(\"Can't retire a fence that hasn't fired.\");                                   // 128\n      self.retired = true;                                                                                           // 130\n    }                                                                                                                // 131\n                                                                                                                     //\n    return retire;                                                                                                   // 126\n  }()                                                                                                                // 126\n});                                                                                                                  // 25\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"crossbar.js\":function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-server/crossbar.js                                                                                   //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// A \"crossbar\" is a class that provides structured notification registration.                                       // 1\n// See _match for the definition of how a notification matches a trigger.                                            // 2\n// All notifications and triggers must have a string key named 'collection'.                                         // 3\n                                                                                                                     //\nDDPServer._Crossbar = function (options) {                                                                           // 5\n  var self = this;                                                                                                   // 6\n  options = options || {};                                                                                           // 7\n                                                                                                                     //\n  self.nextId = 1;                                                                                                   // 9\n  // map from collection name (string) -> listener id -> object. each object has                                     // 10\n  // keys 'trigger', 'callback'.  As a hack, the empty string means \"no                                              // 11\n  // collection\".                                                                                                    // 12\n  self.listenersByCollection = {};                                                                                   // 13\n  self.factPackage = options.factPackage || \"livedata\";                                                              // 14\n  self.factName = options.factName || null;                                                                          // 15\n};                                                                                                                   // 16\n                                                                                                                     //\n_.extend(DDPServer._Crossbar.prototype, {                                                                            // 18\n  // msg is a trigger or a notification                                                                              // 19\n  _collectionForMessage: function () {                                                                               // 20\n    function _collectionForMessage(msg) {                                                                            // 20\n      var self = this;                                                                                               // 21\n      if (!_.has(msg, 'collection')) {                                                                               // 22\n        return '';                                                                                                   // 23\n      } else if (typeof msg.collection === 'string') {                                                               // 24\n        if (msg.collection === '') throw Error(\"Message has empty collection!\");                                     // 25\n        return msg.collection;                                                                                       // 27\n      } else {                                                                                                       // 28\n        throw Error(\"Message has non-string collection!\");                                                           // 29\n      }                                                                                                              // 30\n    }                                                                                                                // 31\n                                                                                                                     //\n    return _collectionForMessage;                                                                                    // 20\n  }(),                                                                                                               // 20\n                                                                                                                     //\n  // Listen for notification that match 'trigger'. A notification                                                    // 33\n  // matches if it has the key-value pairs in trigger as a                                                           // 34\n  // subset. When a notification matches, call 'callback', passing                                                   // 35\n  // the actual notification.                                                                                        // 36\n  //                                                                                                                 // 37\n  // Returns a listen handle, which is an object with a method                                                       // 38\n  // stop(). Call stop() to stop listening.                                                                          // 39\n  //                                                                                                                 // 40\n  // XXX It should be legal to call fire() from inside a listen()                                                    // 41\n  // callback?                                                                                                       // 42\n  listen: function () {                                                                                              // 43\n    function listen(trigger, callback) {                                                                             // 43\n      var self = this;                                                                                               // 44\n      var id = self.nextId++;                                                                                        // 45\n                                                                                                                     //\n      var collection = self._collectionForMessage(trigger);                                                          // 47\n      var record = { trigger: EJSON.clone(trigger), callback: callback };                                            // 48\n      if (!_.has(self.listenersByCollection, collection)) {                                                          // 49\n        self.listenersByCollection[collection] = {};                                                                 // 50\n      }                                                                                                              // 51\n      self.listenersByCollection[collection][id] = record;                                                           // 52\n                                                                                                                     //\n      if (self.factName && Package.facts) {                                                                          // 54\n        Package.facts.Facts.incrementServerFact(self.factPackage, self.factName, 1);                                 // 55\n      }                                                                                                              // 57\n                                                                                                                     //\n      return {                                                                                                       // 59\n        stop: function () {                                                                                          // 60\n          function stop() {                                                                                          // 60\n            if (self.factName && Package.facts) {                                                                    // 61\n              Package.facts.Facts.incrementServerFact(self.factPackage, self.factName, -1);                          // 62\n            }                                                                                                        // 64\n            delete self.listenersByCollection[collection][id];                                                       // 65\n            if (_.isEmpty(self.listenersByCollection[collection])) {                                                 // 66\n              delete self.listenersByCollection[collection];                                                         // 67\n            }                                                                                                        // 68\n          }                                                                                                          // 69\n                                                                                                                     //\n          return stop;                                                                                               // 60\n        }()                                                                                                          // 60\n      };                                                                                                             // 59\n    }                                                                                                                // 71\n                                                                                                                     //\n    return listen;                                                                                                   // 43\n  }(),                                                                                                               // 43\n                                                                                                                     //\n  // Fire the provided 'notification' (an object whose attribute                                                     // 73\n  // values are all JSON-compatibile) -- inform all matching listeners                                               // 74\n  // (registered with listen()).                                                                                     // 75\n  //                                                                                                                 // 76\n  // If fire() is called inside a write fence, then each of the                                                      // 77\n  // listener callbacks will be called inside the write fence as well.                                               // 78\n  //                                                                                                                 // 79\n  // The listeners may be invoked in parallel, rather than serially.                                                 // 80\n  fire: function () {                                                                                                // 81\n    function fire(notification) {                                                                                    // 81\n      var self = this;                                                                                               // 82\n                                                                                                                     //\n      var collection = self._collectionForMessage(notification);                                                     // 84\n                                                                                                                     //\n      if (!_.has(self.listenersByCollection, collection)) {                                                          // 86\n        return;                                                                                                      // 87\n      }                                                                                                              // 88\n                                                                                                                     //\n      var listenersForCollection = self.listenersByCollection[collection];                                           // 90\n      var callbackIds = [];                                                                                          // 91\n      _.each(listenersForCollection, function (l, id) {                                                              // 92\n        if (self._matches(notification, l.trigger)) {                                                                // 93\n          callbackIds.push(id);                                                                                      // 94\n        }                                                                                                            // 95\n      });                                                                                                            // 96\n                                                                                                                     //\n      // Listener callbacks can yield, so we need to first find all the ones that                                    // 98\n      // match in a single iteration over self.listenersByCollection (which can't                                    // 99\n      // be mutated during this iteration), and then invoke the matching                                             // 100\n      // callbacks, checking before each call to ensure they haven't stopped.                                        // 101\n      // Note that we don't have to check that                                                                       // 102\n      // self.listenersByCollection[collection] still === listenersForCollection,                                    // 103\n      // because the only way that stops being true is if listenersForCollection                                     // 104\n      // first gets reduced down to the empty object (and then never gets                                            // 105\n      // increased again).                                                                                           // 106\n      _.each(callbackIds, function (id) {                                                                            // 107\n        if (_.has(listenersForCollection, id)) {                                                                     // 108\n          listenersForCollection[id].callback(notification);                                                         // 109\n        }                                                                                                            // 110\n      });                                                                                                            // 111\n    }                                                                                                                // 112\n                                                                                                                     //\n    return fire;                                                                                                     // 81\n  }(),                                                                                                               // 81\n                                                                                                                     //\n  // A notification matches a trigger if all keys that exist in both are equal.                                      // 114\n  //                                                                                                                 // 115\n  // Examples:                                                                                                       // 116\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}                                                                // 117\n  //    (a non-targeted write to a collection matches a                                                              // 118\n  //     non-targeted query)                                                                                         // 119\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}                                                       // 120\n  //    (a targeted write to a collection matches a non-targeted query)                                              // 121\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}                                                       // 122\n  //    (a non-targeted write to a collection matches a                                                              // 123\n  //     targeted query)                                                                                             // 124\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}                                              // 125\n  //    (a targeted write to a collection matches a targeted query targeted                                          // 126\n  //     at the same document)                                                                                       // 127\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}                                       // 128\n  //    (a targeted write to a collection does not match a targeted query                                            // 129\n  //     targeted at a different document)                                                                           // 130\n  _matches: function () {                                                                                            // 131\n    function _matches(notification, trigger) {                                                                       // 131\n      // Most notifications that use the crossbar have a string `collection` and                                     // 132\n      // maybe an `id` that is a string or ObjectID. We're already dividing up                                       // 133\n      // triggers by collection, but let's fast-track \"nope, different ID\" (and                                      // 134\n      // avoid the overly generic EJSON.equals). This makes a noticeable                                             // 135\n      // performance difference; see https://github.com/meteor/meteor/pull/3697                                      // 136\n      if (typeof notification.id === 'string' && typeof trigger.id === 'string' && notification.id !== trigger.id) {\n        return false;                                                                                                // 140\n      }                                                                                                              // 141\n      if (notification.id instanceof MongoID.ObjectID && trigger.id instanceof MongoID.ObjectID && !notification.id.equals(trigger.id)) {\n        return false;                                                                                                // 145\n      }                                                                                                              // 146\n                                                                                                                     //\n      return _.all(trigger, function (triggerValue, key) {                                                           // 148\n        return !_.has(notification, key) || EJSON.equals(triggerValue, notification[key]);                           // 149\n      });                                                                                                            // 151\n    }                                                                                                                // 152\n                                                                                                                     //\n    return _matches;                                                                                                 // 131\n  }()                                                                                                                // 131\n});                                                                                                                  // 18\n                                                                                                                     //\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to                                      // 155\n// implement write fence notifications. Listener callbacks on this crossbar                                          // 156\n// should call beginWrite on the current write fence before they return, if they                                     // 157\n// want to delay the write fence from firing (ie, the DDP method-data-updated                                        // 158\n// message from being sent).                                                                                         // 159\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({                                                          // 160\n  factName: \"invalidation-crossbar-listeners\"                                                                        // 161\n});                                                                                                                  // 160\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"server_convenience.js\":function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-server/server_convenience.js                                                                         //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nif (process.env.DDP_DEFAULT_CONNECTION_URL) {                                                                        // 1\n  __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL = process.env.DDP_DEFAULT_CONNECTION_URL;                     // 2\n}                                                                                                                    // 4\n                                                                                                                     //\nMeteor.server = new Server();                                                                                        // 6\n                                                                                                                     //\nMeteor.refresh = function (notification) {                                                                           // 8\n  DDPServer._InvalidationCrossbar.fire(notification);                                                                // 9\n};                                                                                                                   // 10\n                                                                                                                     //\n// Proxy the public methods of Meteor.server so they can                                                             // 12\n// be called directly on Meteor.                                                                                     // 13\n_.each(['publish', 'methods', 'call', 'apply', 'onConnection'], function (name) {                                    // 14\n  Meteor[name] = _.bind(Meteor.server[name], Meteor.server);                                                         // 16\n});                                                                                                                  // 17\n                                                                                                                     //\n// Meteor.server used to be called Meteor.default_server. Provide                                                    // 19\n// backcompat as a courtesy even though it was never documented.                                                     // 20\n// XXX COMPAT WITH 0.6.4                                                                                             // 21\nMeteor.default_server = Meteor.server;                                                                               // 22\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\"extensions\":[\".js\",\".json\"]});\nrequire(\"./node_modules/meteor/ddp-server/stream_server.js\");\nrequire(\"./node_modules/meteor/ddp-server/livedata_server.js\");\nrequire(\"./node_modules/meteor/ddp-server/writefence.js\");\nrequire(\"./node_modules/meteor/ddp-server/crossbar.js\");\nrequire(\"./node_modules/meteor/ddp-server/server_convenience.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['ddp-server'] = {}, {\n  DDPServer: DDPServer\n});\n\n})();\n","servePath":"/packages/ddp-server.js","sourceMap":{"version":3,"sources":["/packages/ddp-server/stream_server.js","/packages/ddp-server/livedata_server.js","/packages/ddp-server/writefence.js","/packages/ddp-server/crossbar.js","/packages/ddp-server/server_convenience.js"],"names":["url","Npm","require","websocketExtensions","_","once","extensions","websocketCompressionConfig","process","env","SERVER_WEBSOCKET_COMPRESSION","JSON","parse","push","configure","pathPrefix","__meteor_runtime_config__","ROOT_URL_PATH_PREFIX","StreamServer","self","registration_callbacks","open_sockets","prefix","RoutePolicy","declare","sockjs","serverOptions","log","heartbeat_delay","disconnect_delay","jsessionid","USE_JSESSIONID","DISABLE_WEBSOCKETS","websocket","faye_server_options","server","createServer","WebApp","httpServer","removeListener","_timeoutAdjustmentRequestCallback","installHandlers","addListener","_redirectWebsocketEndpoint","on","socket","send","data","write","without","stringify","server_id","each","callback","extend","prototype","register","all_sockets","values","event","oldHttpServerListeners","listeners","slice","removeAllListeners","newListener","request","args","arguments","parsedUrl","pathname","format","oldListener","apply","DDPServer","Fiber","SessionDocumentView","existsIn","dataByKey","_SessionDocumentView","getFields","ret","precedenceList","key","value","clearField","subscriptionHandle","changeCollector","removedValue","undefined","i","length","precedence","splice","isEmpty","EJSON","equals","changeField","isAdd","clone","has","elt","find","SessionCollectionView","collectionName","sessionCallbacks","documents","callbacks","_SessionCollectionView","diff","previous","DiffSequence","diffObjects","both","bind","diffDocument","rightOnly","id","nowDV","added","leftOnly","prevDV","removed","fields","prev","now","changed","docView","changedResult","Error","err","Session","version","options","Random","initialized","inQueue","Meteor","_DoubleEndedQueue","blocked","workerRunning","_namedSubs","_universalSubs","userId","collectionViews","_isSending","_dontStartNewUniversalSubs","_pendingReady","_closeCallbacks","_socketUrl","_respondToPings","respondToPings","connectionHandle","close","onClose","fn","cb","bindEnvironment","defer","clientAddress","_clientAddress","httpHeaders","headers","msg","session","startUniversalSubs","run","heartbeatInterval","heartbeat","DDPCommon","Heartbeat","heartbeatTimeout","onTimeout","sendPing","start","Package","facts","Facts","incrementServerFact","sendReady","subscriptionIds","subs","subscriptionId","sendAdded","collection","sendChanged","sendRemoved","getSendCallbacks","getCollectionView","view","handlers","universal_publish_handlers","handler","_startSubscription","stop","_meteorSession","_deactivateAllSubscriptions","_removeSession","_printSentDDP","_debug","stringifyDDP","sendError","reason","offendingMessage","processMessage","msg_in","messageReceived","processNext","shift","unblock","protocol_handlers","call","sub","name","params","Array","publish_handlers","error","DDPRateLimiter","rateLimiterInput","type","connectionId","_increment","rateLimitResult","_check","allowed","getErrorMessage","timeToReset","unsub","_stopSubscription","method","randomSeed","fence","_WriteFence","onAllCommitted","retire","methods","method_handlers","arm","setUserId","_setUserId","invocation","MethodInvocation","isSimulation","connection","promise","Promise","resolve","reject","_CurrentWriteFence","withValue","DDP","_CurrentInvocation","maybeAuditArgumentChecks","finish","payload","then","result","exception","wrapInternalException","_eachSub","f","_diffCollectionViews","beforeCVs","leftValue","rightValue","doc","_deactivate","oldNamedSubs","_recreate","_runHandler","_noYieldsAllowed","subId","Subscription","subName","_name","_removeAllDocuments","response","httpForwardedCount","parseInt","remoteAddress","forwardedFor","isString","trim","split","_session","_handler","_subscriptionId","_params","_subscriptionHandle","_deactivated","_stopCallbacks","_documents","_ready","_idFilter","idStringify","MongoID","idParse","res","e","_isDeactivated","_publishHandlerResult","isCursor","c","_publishCursor","ready","isArray","all","collectionNames","_getCollectionName","cur","_callStopCallbacks","collectionDocs","keys","strId","onStop","_ensure","Server","defaults","onConnectionHook","Hook","debugPrintExceptions","sessions","stream_server","raw_msg","_printReceivedDDP","parseDDP","_handleConnect","message","stack","onConnection","support","contains","SUPPORTED_DDP_VERSIONS","calculateVersion","publish","isObject","autopublish","is_auto","warned_about_autopublish","func","pop","currentInvocation","get","makeRpcSeed","_urlForSession","sessionId","clientSupportedVersions","serverSupportedVersions","correctVersion","_calculateVersion","context","expected","sanitizedError","description","Match","_failIfArgumentsAreNotAllChecked","path","Future","join","armed","fired","retired","outstanding_writes","before_fire_callbacks","completion_callbacks","EnvironmentVariable","beginWrite","committed","_maybeFire","onBeforeFire","armAndWait","future","wait","invokeCallback","_Crossbar","nextId","listenersByCollection","factPackage","factName","_collectionForMessage","listen","trigger","record","fire","notification","listenersForCollection","callbackIds","l","_matches","ObjectID","triggerValue","_InvalidationCrossbar","DDP_DEFAULT_CONNECTION_URL","refresh","default_server"],"mappings":"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","file":"/packages/ddp-server.js","sourcesContent":["var url = Npm.require('url');\n\n// By default, we use the permessage-deflate extension with default\n// configuration. If $SERVER_WEBSOCKET_COMPRESSION is set, then it must be valid\n// JSON. If it represents a falsey value, then we do not use permessage-deflate\n// at all; otherwise, the JSON value is used as an argument to deflate's\n// configure method; see\n// https://github.com/faye/permessage-deflate-node/blob/master/README.md\n//\n// (We do this in an _.once instead of at startup, because we don't want to\n// crash the tool during isopacket load if your JSON doesn't parse. This is only\n// a problem because the tool has to load the DDP server code just in order to\n// be a DDP client; see https://github.com/meteor/meteor/issues/3452 .)\nvar websocketExtensions = _.once(function () {\n  var extensions = [];\n\n  var websocketCompressionConfig = process.env.SERVER_WEBSOCKET_COMPRESSION\n        ? JSON.parse(process.env.SERVER_WEBSOCKET_COMPRESSION) : {};\n  if (websocketCompressionConfig) {\n    extensions.push(Npm.require('permessage-deflate').configure(\n      websocketCompressionConfig\n    ));\n  }\n\n  return extensions;\n});\n\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX ||  \"\";\n\nStreamServer = function () {\n  var self = this;\n  self.registration_callbacks = [];\n  self.open_sockets = [];\n\n  // Because we are installing directly onto WebApp.httpServer instead of using\n  // WebApp.app, we have to process the path prefix ourselves.\n  self.prefix = pathPrefix + '/sockjs';\n  RoutePolicy.declare(self.prefix + '/', 'network');\n\n  // set up sockjs\n  var sockjs = Npm.require('sockjs');\n  var serverOptions = {\n    prefix: self.prefix,\n    log: function() {},\n    // this is the default, but we code it explicitly because we depend\n    // on it in stream_client:HEARTBEAT_TIMEOUT\n    heartbeat_delay: 45000,\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU\n    // bound for that much time, SockJS might not notice that the user has\n    // reconnected because the timer (of disconnect_delay ms) can fire before\n    // SockJS processes the new connection. Eventually we'll fix this by not\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which\n    // converts to Unix sockets) but for now, raise the delay.\n    disconnect_delay: 60 * 1000,\n    // Set the USE_JSESSIONID environment variable to enable setting the\n    // JSESSIONID cookie. This is useful for setting up proxies with\n    // session affinity.\n    jsessionid: !!process.env.USE_JSESSIONID\n  };\n\n  // If you know your server environment (eg, proxies) will prevent websockets\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,\n  // browsers) will not waste time attempting to use them.\n  // (Your server will still have a /websocket endpoint.)\n  if (process.env.DISABLE_WEBSOCKETS) {\n    serverOptions.websocket = false;\n  } else {\n    serverOptions.faye_server_options = {\n      extensions: websocketExtensions()\n    };\n  }\n\n  self.server = sockjs.createServer(serverOptions);\n\n  // Install the sockjs handlers, but we want to keep around our own particular\n  // request handler that adjusts idle timeouts while we have an outstanding\n  // request.  This compensates for the fact that sockjs removes all listeners\n  // for \"request\" to add its own.\n  WebApp.httpServer.removeListener(\n    'request', WebApp._timeoutAdjustmentRequestCallback);\n  self.server.installHandlers(WebApp.httpServer);\n  WebApp.httpServer.addListener(\n    'request', WebApp._timeoutAdjustmentRequestCallback);\n\n  // Support the /websocket endpoint\n  self._redirectWebsocketEndpoint();\n\n  self.server.on('connection', function (socket) {\n    socket.send = function (data) {\n      socket.write(data);\n    };\n    socket.on('close', function () {\n      self.open_sockets = _.without(self.open_sockets, socket);\n    });\n    self.open_sockets.push(socket);\n\n    // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which\n    // will force old clients to reload. Remove this once we're not\n    // concerned about people upgrading from a pre-0.7.0 release. Also,\n    // remove the clause in the client that ignores the welcome message\n    // (livedata_connection.js)\n    socket.send(JSON.stringify({server_id: \"0\"}));\n\n    // call all our callbacks when we get a new socket. they will do the\n    // work of setting up handlers and such for specific messages.\n    _.each(self.registration_callbacks, function (callback) {\n      callback(socket);\n    });\n  });\n\n};\n\n_.extend(StreamServer.prototype, {\n  // call my callback when a new socket connects.\n  // also call it for all current connections.\n  register: function (callback) {\n    var self = this;\n    self.registration_callbacks.push(callback);\n    _.each(self.all_sockets(), function (socket) {\n      callback(socket);\n    });\n  },\n\n  // get a list of all sockets\n  all_sockets: function () {\n    var self = this;\n    return _.values(self.open_sockets);\n  },\n\n  // Redirect /websocket to /sockjs/websocket in order to not expose\n  // sockjs to clients that want to use raw websockets\n  _redirectWebsocketEndpoint: function() {\n    var self = this;\n    // Unfortunately we can't use a connect middleware here since\n    // sockjs installs itself prior to all existing listeners\n    // (meaning prior to any connect middlewares) so we need to take\n    // an approach similar to overshadowListeners in\n    // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee\n    _.each(['request', 'upgrade'], function(event) {\n      var httpServer = WebApp.httpServer;\n      var oldHttpServerListeners = httpServer.listeners(event).slice(0);\n      httpServer.removeAllListeners(event);\n\n      // request and upgrade have different arguments passed but\n      // we only care about the first one which is always request\n      var newListener = function(request /*, moreArguments */) {\n        // Store arguments for use within the closure below\n        var args = arguments;\n\n        // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while\n        // preserving query string.\n        var parsedUrl = url.parse(request.url);\n        if (parsedUrl.pathname === pathPrefix + '/websocket' ||\n            parsedUrl.pathname === pathPrefix + '/websocket/') {\n          parsedUrl.pathname = self.prefix + '/websocket';\n          request.url = url.format(parsedUrl);\n        }\n        _.each(oldHttpServerListeners, function(oldListener) {\n          oldListener.apply(httpServer, args);\n        });\n      };\n      httpServer.addListener(event, newListener);\n    });\n  }\n});\n","DDPServer = {};\n\nvar Fiber = Npm.require('fibers');\n\n// This file contains classes:\n// * Session - The server's connection to a single DDP client\n// * Subscription - A single subscription for a single client\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.\n//\n// Session and Subscription are file scope. For now, until we freeze\n// the interface, Server is package scope (in the future it should be\n// exported.)\n\n// Represents a single document in a SessionCollectionView\nvar SessionDocumentView = function () {\n  var self = this;\n  self.existsIn = {}; // set of subscriptionHandle\n  self.dataByKey = {}; // key-> [ {subscriptionHandle, value} by precedence]\n};\n\nDDPServer._SessionDocumentView = SessionDocumentView;\n\n\n_.extend(SessionDocumentView.prototype, {\n\n  getFields: function () {\n    var self = this;\n    var ret = {};\n    _.each(self.dataByKey, function (precedenceList, key) {\n      ret[key] = precedenceList[0].value;\n    });\n    return ret;\n  },\n\n  clearField: function (subscriptionHandle, key, changeCollector) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\")\n      return;\n    var precedenceList = self.dataByKey[key];\n\n    // It's okay to clear fields that didn't exist. No need to throw\n    // an error.\n    if (!precedenceList)\n      return;\n\n    var removedValue = undefined;\n    for (var i = 0; i < precedenceList.length; i++) {\n      var precedence = precedenceList[i];\n      if (precedence.subscriptionHandle === subscriptionHandle) {\n        // The view's value can only change if this subscription is the one that\n        // used to have precedence.\n        if (i === 0)\n          removedValue = precedence.value;\n        precedenceList.splice(i, 1);\n        break;\n      }\n    }\n    if (_.isEmpty(precedenceList)) {\n      delete self.dataByKey[key];\n      changeCollector[key] = undefined;\n    } else if (removedValue !== undefined &&\n               !EJSON.equals(removedValue, precedenceList[0].value)) {\n      changeCollector[key] = precedenceList[0].value;\n    }\n  },\n\n  changeField: function (subscriptionHandle, key, value,\n                         changeCollector, isAdd) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\")\n      return;\n\n    // Don't share state with the data passed in by the user.\n    value = EJSON.clone(value);\n\n    if (!_.has(self.dataByKey, key)) {\n      self.dataByKey[key] = [{subscriptionHandle: subscriptionHandle,\n                              value: value}];\n      changeCollector[key] = value;\n      return;\n    }\n    var precedenceList = self.dataByKey[key];\n    var elt;\n    if (!isAdd) {\n      elt = _.find(precedenceList, function (precedence) {\n        return precedence.subscriptionHandle === subscriptionHandle;\n      });\n    }\n\n    if (elt) {\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\n        // this subscription is changing the value of this field.\n        changeCollector[key] = value;\n      }\n      elt.value = value;\n    } else {\n      // this subscription is newly caring about this field\n      precedenceList.push({subscriptionHandle: subscriptionHandle, value: value});\n    }\n\n  }\n});\n\n/**\n * Represents a client's view of a single collection\n * @param {String} collectionName Name of the collection it represents\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed\n * @class SessionCollectionView\n */\nvar SessionCollectionView = function (collectionName, sessionCallbacks) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.documents = {};\n  self.callbacks = sessionCallbacks;\n};\n\nDDPServer._SessionCollectionView = SessionCollectionView;\n\n\n_.extend(SessionCollectionView.prototype, {\n\n  isEmpty: function () {\n    var self = this;\n    return _.isEmpty(self.documents);\n  },\n\n  diff: function (previous) {\n    var self = this;\n    DiffSequence.diffObjects(previous.documents, self.documents, {\n      both: _.bind(self.diffDocument, self),\n\n      rightOnly: function (id, nowDV) {\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());\n      },\n\n      leftOnly: function (id, prevDV) {\n        self.callbacks.removed(self.collectionName, id);\n      }\n    });\n  },\n\n  diffDocument: function (id, prevDV, nowDV) {\n    var self = this;\n    var fields = {};\n    DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {\n      both: function (key, prev, now) {\n        if (!EJSON.equals(prev, now))\n          fields[key] = now;\n      },\n      rightOnly: function (key, now) {\n        fields[key] = now;\n      },\n      leftOnly: function(key, prev) {\n        fields[key] = undefined;\n      }\n    });\n    self.callbacks.changed(self.collectionName, id, fields);\n  },\n\n  added: function (subscriptionHandle, id, fields) {\n    var self = this;\n    var docView = self.documents[id];\n    var added = false;\n    if (!docView) {\n      added = true;\n      docView = new SessionDocumentView();\n      self.documents[id] = docView;\n    }\n    docView.existsIn[subscriptionHandle] = true;\n    var changeCollector = {};\n    _.each(fields, function (value, key) {\n      docView.changeField(\n        subscriptionHandle, key, value, changeCollector, true);\n    });\n    if (added)\n      self.callbacks.added(self.collectionName, id, changeCollector);\n    else\n      self.callbacks.changed(self.collectionName, id, changeCollector);\n  },\n\n  changed: function (subscriptionHandle, id, changed) {\n    var self = this;\n    var changedResult = {};\n    var docView = self.documents[id];\n    if (!docView)\n      throw new Error(\"Could not find element with id \" + id + \" to change\");\n    _.each(changed, function (value, key) {\n      if (value === undefined)\n        docView.clearField(subscriptionHandle, key, changedResult);\n      else\n        docView.changeField(subscriptionHandle, key, value, changedResult);\n    });\n    self.callbacks.changed(self.collectionName, id, changedResult);\n  },\n\n  removed: function (subscriptionHandle, id) {\n    var self = this;\n    var docView = self.documents[id];\n    if (!docView) {\n      var err = new Error(\"Removed nonexistent document \" + id);\n      throw err;\n    }\n    delete docView.existsIn[subscriptionHandle];\n    if (_.isEmpty(docView.existsIn)) {\n      // it is gone from everyone\n      self.callbacks.removed(self.collectionName, id);\n      delete self.documents[id];\n    } else {\n      var changed = {};\n      // remove this subscription from every precedence list\n      // and record the changes\n      _.each(docView.dataByKey, function (precedenceList, key) {\n        docView.clearField(subscriptionHandle, key, changed);\n      });\n\n      self.callbacks.changed(self.collectionName, id, changed);\n    }\n  }\n});\n\n/******************************************************************************/\n/* Session                                                                    */\n/******************************************************************************/\n\nvar Session = function (server, version, socket, options) {\n  var self = this;\n  self.id = Random.id();\n\n  self.server = server;\n  self.version = version;\n\n  self.initialized = false;\n  self.socket = socket;\n\n  // set to null when the session is destroyed. multiple places below\n  // use this to determine if the session is alive or not.\n  self.inQueue = new Meteor._DoubleEndedQueue();\n\n  self.blocked = false;\n  self.workerRunning = false;\n\n  // Sub objects for active subscriptions\n  self._namedSubs = {};\n  self._universalSubs = [];\n\n  self.userId = null;\n\n  self.collectionViews = {};\n\n  // Set this to false to not send messages when collectionViews are\n  // modified. This is done when rerunning subs in _setUserId and those messages\n  // are calculated via a diff instead.\n  self._isSending = true;\n\n  // If this is true, don't start a newly-created universal publisher on this\n  // session. The session will take care of starting it when appropriate.\n  self._dontStartNewUniversalSubs = false;\n\n  // when we are rerunning subscriptions, any ready messages\n  // we want to buffer up for when we are done rerunning subscriptions\n  self._pendingReady = [];\n\n  // List of callbacks to call when this connection is closed.\n  self._closeCallbacks = [];\n\n\n  // XXX HACK: If a sockjs connection, save off the URL. This is\n  // temporary and will go away in the near future.\n  self._socketUrl = socket.url;\n\n  // Allow tests to disable responding to pings.\n  self._respondToPings = options.respondToPings;\n\n  // This object is the public interface to the session. In the public\n  // API, it is called the `connection` object.  Internally we call it\n  // a `connectionHandle` to avoid ambiguity.\n  self.connectionHandle = {\n    id: self.id,\n    close: function () {\n      self.close();\n    },\n    onClose: function (fn) {\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");\n      if (self.inQueue) {\n        self._closeCallbacks.push(cb);\n      } else {\n        // if we're already closed, call the callback.\n        Meteor.defer(cb);\n      }\n    },\n    clientAddress: self._clientAddress(),\n    httpHeaders: self.socket.headers\n  };\n\n  self.send({ msg: 'connected', session: self.id });\n\n  // On initial connect, spin up all the universal publishers.\n  Fiber(function () {\n    self.startUniversalSubs();\n  }).run();\n\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {\n    self.heartbeat = new DDPCommon.Heartbeat({\n      heartbeatInterval: options.heartbeatInterval,\n      heartbeatTimeout: options.heartbeatTimeout,\n      onTimeout: function () {\n        self.close();\n      },\n      sendPing: function () {\n        self.send({msg: 'ping'});\n      }\n    });\n    self.heartbeat.start();\n  }\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\n    \"livedata\", \"sessions\", 1);\n};\n\n_.extend(Session.prototype, {\n\n  sendReady: function (subscriptionIds) {\n    var self = this;\n    if (self._isSending)\n      self.send({msg: \"ready\", subs: subscriptionIds});\n    else {\n      _.each(subscriptionIds, function (subscriptionId) {\n        self._pendingReady.push(subscriptionId);\n      });\n    }\n  },\n\n  sendAdded: function (collectionName, id, fields) {\n    var self = this;\n    if (self._isSending)\n      self.send({msg: \"added\", collection: collectionName, id: id, fields: fields});\n  },\n\n  sendChanged: function (collectionName, id, fields) {\n    var self = this;\n    if (_.isEmpty(fields))\n      return;\n\n    if (self._isSending) {\n      self.send({\n        msg: \"changed\",\n        collection: collectionName,\n        id: id,\n        fields: fields\n      });\n    }\n  },\n\n  sendRemoved: function (collectionName, id) {\n    var self = this;\n    if (self._isSending)\n      self.send({msg: \"removed\", collection: collectionName, id: id});\n  },\n\n  getSendCallbacks: function () {\n    var self = this;\n    return {\n      added: _.bind(self.sendAdded, self),\n      changed: _.bind(self.sendChanged, self),\n      removed: _.bind(self.sendRemoved, self)\n    };\n  },\n\n  getCollectionView: function (collectionName) {\n    var self = this;\n    if (_.has(self.collectionViews, collectionName)) {\n      return self.collectionViews[collectionName];\n    }\n    var ret = new SessionCollectionView(collectionName,\n                                        self.getSendCallbacks());\n    self.collectionViews[collectionName] = ret;\n    return ret;\n  },\n\n  added: function (subscriptionHandle, collectionName, id, fields) {\n    var self = this;\n    var view = self.getCollectionView(collectionName);\n    view.added(subscriptionHandle, id, fields);\n  },\n\n  removed: function (subscriptionHandle, collectionName, id) {\n    var self = this;\n    var view = self.getCollectionView(collectionName);\n    view.removed(subscriptionHandle, id);\n    if (view.isEmpty()) {\n      delete self.collectionViews[collectionName];\n    }\n  },\n\n  changed: function (subscriptionHandle, collectionName, id, fields) {\n    var self = this;\n    var view = self.getCollectionView(collectionName);\n    view.changed(subscriptionHandle, id, fields);\n  },\n\n  startUniversalSubs: function () {\n    var self = this;\n    // Make a shallow copy of the set of universal handlers and start them. If\n    // additional universal publishers start while we're running them (due to\n    // yielding), they will run separately as part of Server.publish.\n    var handlers = _.clone(self.server.universal_publish_handlers);\n    _.each(handlers, function (handler) {\n      self._startSubscription(handler);\n    });\n  },\n\n  // Destroy this session and unregister it at the server.\n  close: function () {\n    var self = this;\n\n    // Destroy this session, even if it's not registered at the\n    // server. Stop all processing and tear everything down. If a socket\n    // was attached, close it.\n\n    // Already destroyed.\n    if (! self.inQueue)\n      return;\n\n    // Drop the merge box data immediately.\n    self.inQueue = null;\n    self.collectionViews = {};\n\n    if (self.heartbeat) {\n      self.heartbeat.stop();\n      self.heartbeat = null;\n    }\n\n    if (self.socket) {\n      self.socket.close();\n      self.socket._meteorSession = null;\n    }\n\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"livedata\", \"sessions\", -1);\n\n    Meteor.defer(function () {\n      // stop callbacks can yield, so we defer this on close.\n      // sub._isDeactivated() detects that we set inQueue to null and\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\n      self._deactivateAllSubscriptions();\n\n      // Defer calling the close callbacks, so that the caller closing\n      // the session isn't waiting for all the callbacks to complete.\n      _.each(self._closeCallbacks, function (callback) {\n        callback();\n      });\n    });\n\n    // Unregister the session.\n    self.server._removeSession(self);\n  },\n\n  // Send a message (doing nothing if no socket is connected right now.)\n  // It should be a JSON object (it will be stringified.)\n  send: function (msg) {\n    var self = this;\n    if (self.socket) {\n      if (Meteor._printSentDDP)\n        Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));\n      self.socket.send(DDPCommon.stringifyDDP(msg));\n    }\n  },\n\n  // Send a connection error.\n  sendError: function (reason, offendingMessage) {\n    var self = this;\n    var msg = {msg: 'error', reason: reason};\n    if (offendingMessage)\n      msg.offendingMessage = offendingMessage;\n    self.send(msg);\n  },\n\n  // Process 'msg' as an incoming message. (But as a guard against\n  // race conditions during reconnection, ignore the message if\n  // 'socket' is not the currently connected socket.)\n  //\n  // We run the messages from the client one at a time, in the order\n  // given by the client. The message handler is passed an idempotent\n  // function 'unblock' which it may call to allow other messages to\n  // begin running in parallel in another fiber (for example, a method\n  // that wants to yield.) Otherwise, it is automatically unblocked\n  // when it returns.\n  //\n  // Actually, we don't have to 'totally order' the messages in this\n  // way, but it's the easiest thing that's correct. (unsub needs to\n  // be ordered against sub, methods need to be ordered against each\n  // other.)\n  processMessage: function (msg_in) {\n    var self = this;\n    if (!self.inQueue) // we have been destroyed.\n      return;\n\n    // Respond to ping and pong messages immediately without queuing.\n    // If the negotiated DDP version is \"pre1\" which didn't support\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad\n    // request\" for the unknown messages.\n    //\n    // Fibers are needed because heartbeat uses Meteor.setTimeout, which\n    // needs a Fiber. We could actually use regular setTimeout and avoid\n    // these new fibers, but it is easier to just make everything use\n    // Meteor.setTimeout and not think too hard.\n    //\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the client is still alive.\n    if (self.heartbeat) {\n      Fiber(function () {\n        self.heartbeat.messageReceived();\n      }).run();\n    }\n\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {\n      if (self._respondToPings)\n        self.send({msg: \"pong\", id: msg_in.id});\n      return;\n    }\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {\n      // Since everything is a pong, nothing to do\n      return;\n    }\n\n    self.inQueue.push(msg_in);\n    if (self.workerRunning)\n      return;\n    self.workerRunning = true;\n\n    var processNext = function () {\n      var msg = self.inQueue && self.inQueue.shift();\n      if (!msg) {\n        self.workerRunning = false;\n        return;\n      }\n\n      Fiber(function () {\n        var blocked = true;\n\n        var unblock = function () {\n          if (!blocked)\n            return; // idempotent\n          blocked = false;\n          processNext();\n        };\n\n        if (_.has(self.protocol_handlers, msg.msg))\n          self.protocol_handlers[msg.msg].call(self, msg, unblock);\n        else\n          self.sendError('Bad request', msg);\n        unblock(); // in case the handler didn't already do it\n      }).run();\n    };\n\n    processNext();\n  },\n\n  protocol_handlers: {\n    sub: function (msg) {\n      var self = this;\n\n      // reject malformed messages\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.name) !== \"string\" ||\n          (('params' in msg) && !(msg.params instanceof Array))) {\n        self.sendError(\"Malformed subscription\", msg);\n        return;\n      }\n\n      if (!self.server.publish_handlers[msg.name]) {\n        self.send({\n          msg: 'nosub', id: msg.id,\n          error: new Meteor.Error(404, `Subscription '${msg.name}' not found`)});\n        return;\n      }\n\n      if (_.has(self._namedSubs, msg.id))\n        // subs are idempotent, or rather, they are ignored if a sub\n        // with that id already exists. this is important during\n        // reconnect.\n        return;\n\n      // XXX It'd be much better if we had generic hooks where any package can\n      // hook into subscription handling, but in the mean while we special case\n      // ddp-rate-limiter package. This is also done for weak requirements to\n      // add the ddp-rate-limiter package in case we don't have Accounts. A\n      // user trying to use the ddp-rate-limiter must explicitly require it.\n      if (Package['ddp-rate-limiter']) {\n        var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n        var rateLimiterInput = {\n          userId: self.userId,\n          clientAddress: self.connectionHandle.clientAddress,\n          type: \"subscription\",\n          name: msg.name,\n          connectionId: self.id\n        };\n\n        DDPRateLimiter._increment(rateLimiterInput);\n        var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n        if (!rateLimitResult.allowed) {\n          self.send({\n            msg: 'nosub', id: msg.id,\n            error: new Meteor.Error(\n              'too-many-requests',\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset})\n          });\n          return;\n        }\n      }\n\n      var handler = self.server.publish_handlers[msg.name];\n\n      self._startSubscription(handler, msg.id, msg.params, msg.name);\n\n    },\n\n    unsub: function (msg) {\n      var self = this;\n\n      self._stopSubscription(msg.id);\n    },\n\n    method: function (msg, unblock) {\n      var self = this;\n\n      // reject malformed messages\n      // For now, we silently ignore unknown attributes,\n      // for forwards compatibility.\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.method) !== \"string\" ||\n          (('params' in msg) && !(msg.params instanceof Array)) ||\n          (('randomSeed' in msg) && (typeof msg.randomSeed !== \"string\"))) {\n        self.sendError(\"Malformed method invocation\", msg);\n        return;\n      }\n\n      var randomSeed = msg.randomSeed || null;\n\n      // set up to mark the method as satisfied once all observers\n      // (and subscriptions) have reacted to any writes that were\n      // done.\n      var fence = new DDPServer._WriteFence;\n      fence.onAllCommitted(function () {\n        // Retire the fence so that future writes are allowed.\n        // This means that callbacks like timers are free to use\n        // the fence, and if they fire before it's armed (for\n        // example, because the method waits for them) their\n        // writes will be included in the fence.\n        fence.retire();\n        self.send({\n          msg: 'updated', methods: [msg.id]});\n      });\n\n      // find the handler\n      var handler = self.server.method_handlers[msg.method];\n      if (!handler) {\n        self.send({\n          msg: 'result', id: msg.id,\n          error: new Meteor.Error(404, `Method '${msg.method}' not found`)});\n        fence.arm();\n        return;\n      }\n\n      var setUserId = function(userId) {\n        self._setUserId(userId);\n      };\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: false,\n        userId: self.userId,\n        setUserId: setUserId,\n        unblock: unblock,\n        connection: self.connectionHandle,\n        randomSeed: randomSeed\n      });\n\n      const promise = new Promise((resolve, reject) => {\n        // XXX It'd be better if we could hook into method handlers better but\n        // for now, we need to check if the ddp-rate-limiter exists since we\n        // have a weak requirement for the ddp-rate-limiter package to be added\n        // to our application.\n        if (Package['ddp-rate-limiter']) {\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n          var rateLimiterInput = {\n            userId: self.userId,\n            clientAddress: self.connectionHandle.clientAddress,\n            type: \"method\",\n            name: msg.method,\n            connectionId: self.id\n          };\n          DDPRateLimiter._increment(rateLimiterInput);\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput)\n          if (!rateLimitResult.allowed) {\n            reject(new Meteor.Error(\n              \"too-many-requests\",\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset}\n            ));\n            return;\n          }\n        }\n\n        resolve(DDPServer._CurrentWriteFence.withValue(\n          fence,\n          () => DDP._CurrentInvocation.withValue(\n            invocation,\n            () => maybeAuditArgumentChecks(\n              handler, invocation, msg.params,\n              \"call to '\" + msg.method + \"'\"\n            )\n          )\n        ));\n      });\n\n      function finish() {\n        fence.arm();\n        unblock();\n      }\n\n      const payload = {\n        msg: \"result\",\n        id: msg.id\n      };\n\n      promise.then((result) => {\n        finish();\n        if (result !== undefined) {\n          payload.result = result;\n        }\n        self.send(payload);\n      }, (exception) => {\n        finish();\n        payload.error = wrapInternalException(\n          exception,\n          `while invoking method '${msg.method}'`\n        );\n        self.send(payload);\n      });\n    }\n  },\n\n  _eachSub: function (f) {\n    var self = this;\n    _.each(self._namedSubs, f);\n    _.each(self._universalSubs, f);\n  },\n\n  _diffCollectionViews: function (beforeCVs) {\n    var self = this;\n    DiffSequence.diffObjects(beforeCVs, self.collectionViews, {\n      both: function (collectionName, leftValue, rightValue) {\n        rightValue.diff(leftValue);\n      },\n      rightOnly: function (collectionName, rightValue) {\n        _.each(rightValue.documents, function (docView, id) {\n          self.sendAdded(collectionName, id, docView.getFields());\n        });\n      },\n      leftOnly: function (collectionName, leftValue) {\n        _.each(leftValue.documents, function (doc, id) {\n          self.sendRemoved(collectionName, id);\n        });\n      }\n    });\n  },\n\n  // Sets the current user id in all appropriate contexts and reruns\n  // all subscriptions\n  _setUserId: function(userId) {\n    var self = this;\n\n    if (userId !== null && typeof userId !== \"string\")\n      throw new Error(\"setUserId must be called on string or null, not \" +\n                      typeof userId);\n\n    // Prevent newly-created universal subscriptions from being added to our\n    // session; they will be found below when we call startUniversalSubs.\n    //\n    // (We don't have to worry about named subscriptions, because we only add\n    // them when we process a 'sub' message. We are currently processing a\n    // 'method' message, and the method did not unblock, because it is illegal\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a\n    // new named subscription.)\n    self._dontStartNewUniversalSubs = true;\n\n    // Prevent current subs from updating our collectionViews and call their\n    // stop callbacks. This may yield.\n    self._eachSub(function (sub) {\n      sub._deactivate();\n    });\n\n    // All subs should now be deactivated. Stop sending messages to the client,\n    // save the state of the published collections, reset to an empty view, and\n    // update the userId.\n    self._isSending = false;\n    var beforeCVs = self.collectionViews;\n    self.collectionViews = {};\n    self.userId = userId;\n\n    // Save the old named subs, and reset to having no subscriptions.\n    var oldNamedSubs = self._namedSubs;\n    self._namedSubs = {};\n    self._universalSubs = [];\n\n    _.each(oldNamedSubs, function (sub, subscriptionId) {\n      self._namedSubs[subscriptionId] = sub._recreate();\n      // nb: if the handler throws or calls this.error(), it will in fact\n      // immediately send its 'nosub'. This is OK, though.\n      self._namedSubs[subscriptionId]._runHandler();\n    });\n\n    // Allow newly-created universal subs to be started on our connection in\n    // parallel with the ones we're spinning up here, and spin up universal\n    // subs.\n    self._dontStartNewUniversalSubs = false;\n    self.startUniversalSubs();\n\n    // Start sending messages again, beginning with the diff from the previous\n    // state of the world to the current state. No yields are allowed during\n    // this diff, so that other changes cannot interleave.\n    Meteor._noYieldsAllowed(function () {\n      self._isSending = true;\n      self._diffCollectionViews(beforeCVs);\n      if (!_.isEmpty(self._pendingReady)) {\n        self.sendReady(self._pendingReady);\n        self._pendingReady = [];\n      }\n    });\n  },\n\n  _startSubscription: function (handler, subId, params, name) {\n    var self = this;\n\n    var sub = new Subscription(\n      self, handler, subId, params, name);\n    if (subId)\n      self._namedSubs[subId] = sub;\n    else\n      self._universalSubs.push(sub);\n\n    sub._runHandler();\n  },\n\n  // tear down specified subscription\n  _stopSubscription: function (subId, error) {\n    var self = this;\n\n    var subName = null;\n\n    if (subId && self._namedSubs[subId]) {\n      subName = self._namedSubs[subId]._name;\n      self._namedSubs[subId]._removeAllDocuments();\n      self._namedSubs[subId]._deactivate();\n      delete self._namedSubs[subId];\n    }\n\n    var response = {msg: 'nosub', id: subId};\n\n    if (error) {\n      response.error = wrapInternalException(\n        error,\n        subName ? (\"from sub \" + subName + \" id \" + subId)\n          : (\"from sub id \" + subId));\n    }\n\n    self.send(response);\n  },\n\n  // tear down all subscriptions. Note that this does NOT send removed or nosub\n  // messages, since we assume the client is gone.\n  _deactivateAllSubscriptions: function () {\n    var self = this;\n\n    _.each(self._namedSubs, function (sub, id) {\n      sub._deactivate();\n    });\n    self._namedSubs = {};\n\n    _.each(self._universalSubs, function (sub) {\n      sub._deactivate();\n    });\n    self._universalSubs = [];\n  },\n\n  // Determine the remote client's IP address, based on the\n  // HTTP_FORWARDED_COUNT environment variable representing how many\n  // proxies the server is behind.\n  _clientAddress: function () {\n    var self = this;\n\n    // For the reported client address for a connection to be correct,\n    // the developer must set the HTTP_FORWARDED_COUNT environment\n    // variable to an integer representing the number of hops they\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the\n    // server is behind one proxy.\n    //\n    // This could be computed once at startup instead of every time.\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\n\n    if (httpForwardedCount === 0)\n      return self.socket.remoteAddress;\n\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];\n    if (! _.isString(forwardedFor))\n      return null;\n    forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);\n\n    // Typically the first value in the `x-forwarded-for` header is\n    // the original IP address of the client connecting to the first\n    // proxy.  However, the end user can easily spoof the header, in\n    // which case the first value(s) will be the fake IP address from\n    // the user pretending to be a proxy reporting the original IP\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the\n    // end of the list, we ensure that we get the IP address being\n    // reported by *our* first proxy.\n\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length)\n      return null;\n\n    return forwardedFor[forwardedFor.length - httpForwardedCount];\n  }\n});\n\n/******************************************************************************/\n/* Subscription                                                               */\n/******************************************************************************/\n\n// ctor for a sub handle: the input to each publish function\n\n// Instance name is this because it's usually referred to as this inside a\n// publish\n/**\n * @summary The server's side of a subscription\n * @class Subscription\n * @instanceName this\n */\nvar Subscription = function (\n    session, handler, subscriptionId, params, name) {\n  var self = this;\n  self._session = session; // type is Session\n\n  /**\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server\n   * @name  connection\n   * @memberOf Subscription\n   * @instance\n   */\n  self.connection = session.connectionHandle; // public API object\n\n  self._handler = handler;\n\n  // my subscription ID (generated by client, undefined for universal subs).\n  self._subscriptionId = subscriptionId;\n  // undefined for universal subs\n  self._name = name;\n\n  self._params = params || [];\n\n  // Only named subscriptions have IDs, but we need some sort of string\n  // internally to keep track of all subscriptions inside\n  // SessionDocumentViews. We use this subscriptionHandle for that.\n  if (self._subscriptionId) {\n    self._subscriptionHandle = 'N' + self._subscriptionId;\n  } else {\n    self._subscriptionHandle = 'U' + Random.id();\n  }\n\n  // has _deactivate been called?\n  self._deactivated = false;\n\n  // stop callbacks to g/c this sub.  called w/ zero arguments.\n  self._stopCallbacks = [];\n\n  // the set of (collection, documentid) that this subscription has\n  // an opinion about\n  self._documents = {};\n\n  // remember if we are ready.\n  self._ready = false;\n\n  // Part of the public API: the user of this sub.\n\n  /**\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.\n   * @locus Server\n   * @memberOf Subscription\n   * @name  userId\n   * @instance\n   */\n  self.userId = session.userId;\n\n  // For now, the id filter is going to default to\n  // the to/from DDP methods on MongoID, to\n  // specifically deal with mongo/minimongo ObjectIds.\n\n  // Later, you will be able to make this be \"raw\"\n  // if you want to publish a collection that you know\n  // just has strings for keys and no funny business, to\n  // a ddp consumer that isn't minimongo\n\n  self._idFilter = {\n    idStringify: MongoID.idStringify,\n    idParse: MongoID.idParse\n  };\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\n    \"livedata\", \"subscriptions\", 1);\n};\n\n_.extend(Subscription.prototype, {\n  _runHandler: function () {\n    // XXX should we unblock() here? Either before running the publish\n    // function, or before running _publishCursor.\n    //\n    // Right now, each publish function blocks all future publishes and\n    // methods waiting on data from Mongo (or whatever else the function\n    // blocks on). This probably slows page load in common cases.\n\n    var self = this;\n    try {\n      var res = maybeAuditArgumentChecks(\n        self._handler, self, EJSON.clone(self._params),\n        // It's OK that this would look weird for universal subscriptions,\n        // because they have no arguments so there can never be an\n        // audit-argument-checks failure.\n        \"publisher '\" + self._name + \"'\");\n    } catch (e) {\n      self.error(e);\n      return;\n    }\n\n    // Did the handler call this.error or this.stop?\n    if (self._isDeactivated())\n      return;\n\n    self._publishHandlerResult(res);\n  },\n\n  _publishHandlerResult: function (res) {\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke\n    // this.added/changed/ready/etc, the user can just return a collection\n    // cursor or array of cursors from the publish function; we call their\n    // _publishCursor method which starts observing the cursor and publishes the\n    // results. Note that _publishCursor does NOT call ready().\n    //\n    // XXX This uses an undocumented interface which only the Mongo cursor\n    // interface publishes. Should we make this interface public and encourage\n    // users to implement it themselves? Arguably, it's unnecessary; users can\n    // already write their own functions like\n    //   var publishMyReactiveThingy = function (name, handler) {\n    //     Meteor.publish(name, function () {\n    //       var reactiveThingy = handler();\n    //       reactiveThingy.publishMe();\n    //     });\n    //   };\n\n    var self = this;\n    var isCursor = function (c) {\n      return c && c._publishCursor;\n    };\n    if (isCursor(res)) {\n      try {\n        res._publishCursor(self);\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      // _publishCursor only returns after the initial added callbacks have run.\n      // mark subscription as ready.\n      self.ready();\n    } else if (_.isArray(res)) {\n      // check all the elements are cursors\n      if (! _.all(res, isCursor)) {\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));\n        return;\n      }\n      // find duplicate collection names\n      // XXX we should support overlapping cursors, but that would require the\n      // merge box to allow overlap within a subscription\n      var collectionNames = {};\n      for (var i = 0; i < res.length; ++i) {\n        var collectionName = res[i]._getCollectionName();\n        if (_.has(collectionNames, collectionName)) {\n          self.error(new Error(\n            \"Publish function returned multiple cursors for collection \" +\n              collectionName));\n          return;\n        }\n        collectionNames[collectionName] = true;\n      };\n\n      try {\n        _.each(res, function (cur) {\n          cur._publishCursor(self);\n        });\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      self.ready();\n    } else if (res) {\n      // truthy values other than cursors or arrays are probably a\n      // user mistake (possible returning a Mongo document via, say,\n      // `coll.findOne()`).\n      self.error(new Error(\"Publish function can only return a Cursor or \"\n                           + \"an array of Cursors\"));\n    }\n  },\n\n  // This calls all stop callbacks and prevents the handler from updating any\n  // SessionCollectionViews further. It's used when the user unsubscribes or\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send\n  // removed messages for the published objects; if that is necessary, call\n  // _removeAllDocuments first.\n  _deactivate: function() {\n    var self = this;\n    if (self._deactivated)\n      return;\n    self._deactivated = true;\n    self._callStopCallbacks();\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"livedata\", \"subscriptions\", -1);\n  },\n\n  _callStopCallbacks: function () {\n    var self = this;\n    // tell listeners, so they can clean up\n    var callbacks = self._stopCallbacks;\n    self._stopCallbacks = [];\n    _.each(callbacks, function (callback) {\n      callback();\n    });\n  },\n\n  // Send remove messages for every document.\n  _removeAllDocuments: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      _.each(self._documents, function(collectionDocs, collectionName) {\n        // Iterate over _.keys instead of the dictionary itself, since we'll be\n        // mutating it.\n        _.each(_.keys(collectionDocs), function (strId) {\n          self.removed(collectionName, self._idFilter.idParse(strId));\n        });\n      });\n    });\n  },\n\n  // Returns a new Subscription for the same session with the same\n  // initial creation parameters. This isn't a clone: it doesn't have\n  // the same _documents cache, stopped state or callbacks; may have a\n  // different _subscriptionHandle, and gets its userId from the\n  // session, not from this object.\n  _recreate: function () {\n    var self = this;\n    return new Subscription(\n      self._session, self._handler, self._subscriptionId, self._params,\n      self._name);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server\n   * @param {Error} error The error to pass to the client.\n   * @instance\n   * @memberOf Subscription\n   */\n  error: function (error) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId, error);\n  },\n\n  // Note that while our DDP client will notice that you've called stop() on the\n  // server (and clean up its _subscriptions table) we don't actually provide a\n  // mechanism for an app to notice this (the subscribe onError callback only\n  // triggers if there is an error).\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server\n   * @instance\n   * @memberOf Subscription\n   */\n  stop: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {Function} func The callback function\n   */\n  onStop: function (callback) {\n    var self = this;\n    if (self._isDeactivated())\n      callback();\n    else\n      self._stopCallbacks.push(callback);\n  },\n\n  // This returns true if the sub has been deactivated, *OR* if the session was\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\n  // happened yet.\n  _isDeactivated: function () {\n    var self = this;\n    return self._deactivated || self._session.inQueue === null;\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the new document.\n   * @param {String} id The new document's ID.\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.\n   */\n  added: function (collectionName, id, fields) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    id = self._idFilter.idStringify(id);\n    Meteor._ensure(self._documents, collectionName)[id] = true;\n    self._session.added(self._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the changed document.\n   * @param {String} id The changed document's ID.\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */\n  changed: function (collectionName, id, fields) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    id = self._idFilter.idStringify(id);\n    self._session.changed(self._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that the document has been removed from.\n   * @param {String} id The ID of the document that has been removed.\n   */\n  removed: function (collectionName, id) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    id = self._idFilter.idStringify(id);\n    // We don't bother to delete sets of things in a collection if the\n    // collection is empty.  It could break _removeAllDocuments.\n    delete self._documents[collectionName][id];\n    self._session.removed(self._subscriptionHandle, collectionName, id);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   */\n  ready: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    if (!self._subscriptionId)\n      return;  // unnecessary but ignored for universal sub\n    if (!self._ready) {\n      self._session.sendReady([self._subscriptionId]);\n      self._ready = true;\n    }\n  }\n});\n\n/******************************************************************************/\n/* Server                                                                     */\n/******************************************************************************/\n\nServer = function (options) {\n  var self = this;\n\n  // The default heartbeat interval is 30 seconds on the server and 35\n  // seconds on the client.  Since the client doesn't need to send a\n  // ping as long as it is receiving pings, this means that pings\n  // normally go from the server to the client.\n  //\n  // Note: Troposphere depends on the ability to mutate\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n  self.options = _.defaults(options || {}, {\n    heartbeatInterval: 15000,\n    heartbeatTimeout: 15000,\n    // For testing, allow responding to pings to be disabled.\n    respondToPings: true\n  });\n\n  // Map of callbacks to call when a new connection comes in to the\n  // server and completes DDP version negotiation. Use an object instead\n  // of an array so we can safely remove one from the list while\n  // iterating over it.\n  self.onConnectionHook = new Hook({\n    debugPrintExceptions: \"onConnection callback\"\n  });\n\n  self.publish_handlers = {};\n  self.universal_publish_handlers = [];\n\n  self.method_handlers = {};\n\n  self.sessions = {}; // map from id to session\n\n  self.stream_server = new StreamServer;\n\n  self.stream_server.register(function (socket) {\n    // socket implements the SockJSConnection interface\n    socket._meteorSession = null;\n\n    var sendError = function (reason, offendingMessage) {\n      var msg = {msg: 'error', reason: reason};\n      if (offendingMessage)\n        msg.offendingMessage = offendingMessage;\n      socket.send(DDPCommon.stringifyDDP(msg));\n    };\n\n    socket.on('data', function (raw_msg) {\n      if (Meteor._printReceivedDDP) {\n        Meteor._debug(\"Received DDP\", raw_msg);\n      }\n      try {\n        try {\n          var msg = DDPCommon.parseDDP(raw_msg);\n        } catch (err) {\n          sendError('Parse error');\n          return;\n        }\n        if (msg === null || !msg.msg) {\n          sendError('Bad request', msg);\n          return;\n        }\n\n        if (msg.msg === 'connect') {\n          if (socket._meteorSession) {\n            sendError(\"Already connected\", msg);\n            return;\n          }\n          Fiber(function () {\n            self._handleConnect(socket, msg);\n          }).run();\n          return;\n        }\n\n        if (!socket._meteorSession) {\n          sendError('Must connect first', msg);\n          return;\n        }\n        socket._meteorSession.processMessage(msg);\n      } catch (e) {\n        // XXX print stack nicely\n        Meteor._debug(\"Internal exception while processing message\", msg,\n                      e.message, e.stack);\n      }\n    });\n\n    socket.on('close', function () {\n      if (socket._meteorSession) {\n        Fiber(function () {\n          socket._meteorSession.close();\n        }).run();\n      }\n    });\n  });\n};\n\n_.extend(Server.prototype, {\n\n  /**\n   * @summary Register a callback to be called when a new DDP connection is made to the server.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP connection is established.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onConnection: function (fn) {\n    var self = this;\n    return self.onConnectionHook.register(fn);\n  },\n\n  _handleConnect: function (socket, msg) {\n    var self = this;\n\n    // The connect message must specify a version and an array of supported\n    // versions, and it must claim to support what it is proposing.\n    if (!(typeof (msg.version) === 'string' &&\n          _.isArray(msg.support) &&\n          _.all(msg.support, _.isString) &&\n          _.contains(msg.support, msg.version))) {\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed',\n                                version: DDPCommon.SUPPORTED_DDP_VERSIONS[0]}));\n      socket.close();\n      return;\n    }\n\n    // In the future, handle session resumption: something like:\n    //  socket._meteorSession = self.sessions[msg.session]\n    var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);\n\n    if (msg.version !== version) {\n      // The best version to use (according to the client's stated preferences)\n      // is not the one the client is trying to use. Inform them about the best\n      // version to use.\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed', version: version}));\n      socket.close();\n      return;\n    }\n\n    // Yay, version matches! Create a new session.\n    // Note: Troposphere depends on the ability to mutate\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n    socket._meteorSession = new Session(self, version, socket, self.options);\n    self.sessions[socket._meteorSession.id] = socket._meteorSession;\n    self.onConnectionHook.each(function (callback) {\n      if (socket._meteorSession)\n        callback(socket._meteorSession.connectionHandle);\n      return true;\n    });\n  },\n  /**\n   * Register a publish handler function.\n   *\n   * @param name {String} identifier for query\n   * @param handler {Function} publish handler\n   * @param options {Object}\n   *\n   * Server will call handler function on each new subscription,\n   * either when receiving DDP sub message for a named subscription, or on\n   * DDP connect for a universal subscription.\n   *\n   * If name is null, this will be a subscription that is\n   * automatically established and permanently on for all connected\n   * client, instead of a subscription that can be turned on and off\n   * with subscribe().\n   *\n   * options to contain:\n   *  - (mostly internal) is_auto: true if generated automatically\n   *    from an autopublish hook. this is for cosmetic purposes only\n   *    (it lets us determine whether to print a warning suggesting\n   *    that you turn off autopublish.)\n   */\n\n  /**\n   * @summary Publish a record set.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @locus Server\n   * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */\n  publish: function (name, handler, options) {\n    var self = this;\n\n    if (! _.isObject(name)) {\n      options = options || {};\n\n      if (name && name in self.publish_handlers) {\n        Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");\n        return;\n      }\n\n      if (Package.autopublish && !options.is_auto) {\n        // They have autopublish on, yet they're trying to manually\n        // picking stuff to publish. They probably should turn off\n        // autopublish. (This check isn't perfect -- if you create a\n        // publish before you turn on autopublish, it won't catch\n        // it. But this will definitely handle the simple case where\n        // you've added the autopublish package to your app, and are\n        // calling publish from your app code.)\n        if (!self.warned_about_autopublish) {\n          self.warned_about_autopublish = true;\n          Meteor._debug(\n    \"** You've set up some data subscriptions with Meteor.publish(), but\\n\" +\n    \"** you still have autopublish turned on. Because autopublish is still\\n\" +\n    \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" +\n    \"** will still be sent to all clients.\\n\" +\n    \"**\\n\" +\n    \"** Turn off autopublish by removing the autopublish package:\\n\" +\n    \"**\\n\" +\n    \"**   $ meteor remove autopublish\\n\" +\n    \"**\\n\" +\n    \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" +\n    \"** for each collection that you want clients to see.\\n\");\n        }\n      }\n\n      if (name)\n        self.publish_handlers[name] = handler;\n      else {\n        self.universal_publish_handlers.push(handler);\n        // Spin up the new publisher on any existing session too. Run each\n        // session's subscription in a new Fiber, so that there's no change for\n        // self.sessions to change while we're running this loop.\n        _.each(self.sessions, function (session) {\n          if (!session._dontStartNewUniversalSubs) {\n            Fiber(function() {\n              session._startSubscription(handler);\n            }).run();\n          }\n        });\n      }\n    }\n    else{\n      _.each(name, function(value, key) {\n        self.publish(key, value, {});\n      });\n    }\n  },\n\n  _removeSession: function (session) {\n    var self = this;\n    if (self.sessions[session.id]) {\n      delete self.sessions[session.id];\n    }\n  },\n\n  /**\n   * @summary Defines functions that can be invoked over the network by clients.\n   * @locus Anywhere\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  methods: function (methods) {\n    var self = this;\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function')\n        throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self.method_handlers[name])\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self.method_handlers[name] = func;\n    });\n  },\n\n  call: function (name /*, arguments */) {\n    // if it's a function, the last argument is the result callback,\n    // not a parameter to the remote method.\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (args.length && typeof args[args.length - 1] === \"function\")\n      var callback = args.pop();\n    return this.apply(name, args, callback);\n  },\n\n  // @param options {Optional Object}\n  // @param callback {Optional Function}\n  apply: function (name, args, options, callback) {\n    var self = this;\n\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = options || {};\n\n    if (callback)\n      // It's not really necessary to do this, since we immediately\n      // run the callback in this fiber before returning, but we do it\n      // anyway for regularity.\n      // XXX improve error message (and how we report it)\n      callback = Meteor.bindEnvironment(\n        callback,\n        \"delivering result of invoking '\" + name + \"'\"\n      );\n\n    // Run the handler\n    var handler = self.method_handlers[name];\n    var exception;\n    if (!handler) {\n      exception = new Meteor.Error(404, `Method '${name}' not found`);\n    } else {\n      // If this is a method call from within another method, get the\n      // user state from the outer method, otherwise don't allow\n      // setUserId to be called\n      var userId = null;\n      var setUserId = function() {\n        throw new Error(\"Can't call setUserId on a server initiated method call\");\n      };\n      var connection = null;\n      var currentInvocation = DDP._CurrentInvocation.get();\n      if (currentInvocation) {\n        userId = currentInvocation.userId;\n        setUserId = function(userId) {\n          currentInvocation.setUserId(userId);\n        };\n        connection = currentInvocation.connection;\n      }\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: false,\n        userId: userId,\n        setUserId: setUserId,\n        connection: connection,\n        randomSeed: DDPCommon.makeRpcSeed(currentInvocation, name)\n      });\n      try {\n        var result = DDP._CurrentInvocation.withValue(invocation, function () {\n          return maybeAuditArgumentChecks(\n            handler, invocation, EJSON.clone(args), \"internal call to '\" +\n              name + \"'\");\n        });\n        result = EJSON.clone(result);\n      } catch (e) {\n        exception = e;\n      }\n    }\n\n    // Return the result in whichever way the caller asked for it. Note that we\n    // do NOT block on the write fence in an analogous way to how the client\n    // blocks on the relevant data being visible, so you are NOT guaranteed that\n    // cursor observe callbacks have fired when your callback is invoked. (We\n    // can change this if there's a real use case.)\n    if (callback) {\n      callback(exception, result);\n      return undefined;\n    }\n    if (exception)\n      throw exception;\n    return result;\n  },\n\n  _urlForSession: function (sessionId) {\n    var self = this;\n    var session = self.sessions[sessionId];\n    if (session)\n      return session._socketUrl;\n    else\n      return null;\n  }\n});\n\nvar calculateVersion = function (clientSupportedVersions,\n                                 serverSupportedVersions) {\n  var correctVersion = _.find(clientSupportedVersions, function (version) {\n    return _.contains(serverSupportedVersions, version);\n  });\n  if (!correctVersion) {\n    correctVersion = serverSupportedVersions[0];\n  }\n  return correctVersion;\n};\n\nDDPServer._calculateVersion = calculateVersion;\n\n\n// \"blind\" exceptions other than those that were deliberately thrown to signal\n// errors to the client\nvar wrapInternalException = function (exception, context) {\n  if (!exception || exception instanceof Meteor.Error)\n    return exception;\n\n  // tests can set the 'expected' flag on an exception so it won't go to the\n  // server log\n  if (!exception.expected) {\n    Meteor._debug(\"Exception \" + context, exception.stack);\n    if (exception.sanitizedError) {\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError.message);\n      Meteor._debug();\n    }\n  }\n\n  // Did the error contain more details that could have been useful if caught in\n  // server code (or if thrown from non-client-originated code), but also\n  // provided a \"sanitized\" version with more context than 500 Internal server\n  // error? Use that.\n  if (exception.sanitizedError) {\n    if (exception.sanitizedError instanceof Meteor.Error)\n      return exception.sanitizedError;\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" +\n                  \"is not a Meteor.Error; ignoring\");\n  }\n\n  return new Meteor.Error(500, \"Internal server error\");\n};\n\n\n// Audit argument checks, if the audit-argument-checks package exists (it is a\n// weak dependency of this package).\nvar maybeAuditArgumentChecks = function (f, context, args, description) {\n  args = args || [];\n  if (Package['audit-argument-checks']) {\n    return Match._failIfArgumentsAreNotAllChecked(\n      f, context, args, description);\n  }\n  return f.apply(context, args);\n};\n","var path = Npm.require('path');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\n// A write fence collects a group of writes, and provides a callback\n// when all of the writes are fully committed and propagated (all\n// observers have been notified of the write and acknowledged it.)\n//\nDDPServer._WriteFence = function () {\n  var self = this;\n\n  self.armed = false;\n  self.fired = false;\n  self.retired = false;\n  self.outstanding_writes = 0;\n  self.before_fire_callbacks = [];\n  self.completion_callbacks = [];\n};\n\n// The current write fence. When there is a current write fence, code\n// that writes to databases should register their writes with it using\n// beginWrite().\n//\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable;\n\n_.extend(DDPServer._WriteFence.prototype, {\n  // Start tracking a write, and return an object to represent it. The\n  // object has a single method, committed(). This method should be\n  // called when the write is fully committed and propagated. You can\n  // continue to add writes to the WriteFence up until it is triggered\n  // (calls its callbacks because all writes have committed.)\n  beginWrite: function () {\n    var self = this;\n\n    if (self.retired)\n      return { committed: function () {} };\n\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to add writes\");\n\n    self.outstanding_writes++;\n    var committed = false;\n    return {\n      committed: function () {\n        if (committed)\n          throw new Error(\"committed called twice on the same write\");\n        committed = true;\n        self.outstanding_writes--;\n        self._maybeFire();\n      }\n    };\n  },\n\n  // Arm the fence. Once the fence is armed, and there are no more\n  // uncommitted writes, it will activate.\n  arm: function () {\n    var self = this;\n    if (self === DDPServer._CurrentWriteFence.get())\n      throw Error(\"Can't arm the current fence\");\n    self.armed = true;\n    self._maybeFire();\n  },\n\n  // Register a function to be called once before firing the fence.\n  // Callback function can add new writes to the fence, in which case\n  // it won't fire until those writes are done as well.\n  onBeforeFire: function (func) {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n                      \"add a callback\");\n    self.before_fire_callbacks.push(func);\n  },\n\n  // Register a function to be called when the fence fires.\n  onAllCommitted: function (func) {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n                      \"add a callback\");\n    self.completion_callbacks.push(func);\n  },\n\n  // Convenience function. Arms the fence, then blocks until it fires.\n  armAndWait: function () {\n    var self = this;\n    var future = new Future;\n    self.onAllCommitted(function () {\n      future['return']();\n    });\n    self.arm();\n    future.wait();\n  },\n\n  _maybeFire: function () {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"write fence already activated?\");\n    if (self.armed && !self.outstanding_writes) {\n      function invokeCallback (func) {\n        try {\n          func(self);\n        } catch (err) {\n          Meteor._debug(\"exception in write fence callback:\", err);\n        }\n      }\n\n      self.outstanding_writes++;\n      while (self.before_fire_callbacks.length > 0) {\n        var callbacks = self.before_fire_callbacks;\n        self.before_fire_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n      self.outstanding_writes--;\n\n      if (!self.outstanding_writes) {\n        self.fired = true;\n        var callbacks = self.completion_callbacks;\n        self.completion_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n    }\n  },\n\n  // Deactivate this fence so that adding more writes has no effect.\n  // The fence must have already fired.\n  retire: function () {\n    var self = this;\n    if (! self.fired)\n      throw new Error(\"Can't retire a fence that hasn't fired.\");\n    self.retired = true;\n  }\n});\n","// A \"crossbar\" is a class that provides structured notification registration.\n// See _match for the definition of how a notification matches a trigger.\n// All notifications and triggers must have a string key named 'collection'.\n\nDDPServer._Crossbar = function (options) {\n  var self = this;\n  options = options || {};\n\n  self.nextId = 1;\n  // map from collection name (string) -> listener id -> object. each object has\n  // keys 'trigger', 'callback'.  As a hack, the empty string means \"no\n  // collection\".\n  self.listenersByCollection = {};\n  self.factPackage = options.factPackage || \"livedata\";\n  self.factName = options.factName || null;\n};\n\n_.extend(DDPServer._Crossbar.prototype, {\n  // msg is a trigger or a notification\n  _collectionForMessage: function (msg) {\n    var self = this;\n    if (! _.has(msg, 'collection')) {\n      return '';\n    } else if (typeof(msg.collection) === 'string') {\n      if (msg.collection === '')\n        throw Error(\"Message has empty collection!\");\n      return msg.collection;\n    } else {\n      throw Error(\"Message has non-string collection!\");\n    }\n  },\n\n  // Listen for notification that match 'trigger'. A notification\n  // matches if it has the key-value pairs in trigger as a\n  // subset. When a notification matches, call 'callback', passing\n  // the actual notification.\n  //\n  // Returns a listen handle, which is an object with a method\n  // stop(). Call stop() to stop listening.\n  //\n  // XXX It should be legal to call fire() from inside a listen()\n  // callback?\n  listen: function (trigger, callback) {\n    var self = this;\n    var id = self.nextId++;\n\n    var collection = self._collectionForMessage(trigger);\n    var record = {trigger: EJSON.clone(trigger), callback: callback};\n    if (! _.has(self.listenersByCollection, collection)) {\n      self.listenersByCollection[collection] = {};\n    }\n    self.listenersByCollection[collection][id] = record;\n\n    if (self.factName && Package.facts) {\n      Package.facts.Facts.incrementServerFact(\n        self.factPackage, self.factName, 1);\n    }\n\n    return {\n      stop: function () {\n        if (self.factName && Package.facts) {\n          Package.facts.Facts.incrementServerFact(\n            self.factPackage, self.factName, -1);\n        }\n        delete self.listenersByCollection[collection][id];\n        if (_.isEmpty(self.listenersByCollection[collection])) {\n          delete self.listenersByCollection[collection];\n        }\n      }\n    };\n  },\n\n  // Fire the provided 'notification' (an object whose attribute\n  // values are all JSON-compatibile) -- inform all matching listeners\n  // (registered with listen()).\n  //\n  // If fire() is called inside a write fence, then each of the\n  // listener callbacks will be called inside the write fence as well.\n  //\n  // The listeners may be invoked in parallel, rather than serially.\n  fire: function (notification) {\n    var self = this;\n\n    var collection = self._collectionForMessage(notification);\n\n    if (! _.has(self.listenersByCollection, collection)) {\n      return;\n    }\n\n    var listenersForCollection = self.listenersByCollection[collection];\n    var callbackIds = [];\n    _.each(listenersForCollection, function (l, id) {\n      if (self._matches(notification, l.trigger)) {\n        callbackIds.push(id);\n      }\n    });\n\n    // Listener callbacks can yield, so we need to first find all the ones that\n    // match in a single iteration over self.listenersByCollection (which can't\n    // be mutated during this iteration), and then invoke the matching\n    // callbacks, checking before each call to ensure they haven't stopped.\n    // Note that we don't have to check that\n    // self.listenersByCollection[collection] still === listenersForCollection,\n    // because the only way that stops being true is if listenersForCollection\n    // first gets reduced down to the empty object (and then never gets\n    // increased again).\n    _.each(callbackIds, function (id) {\n      if (_.has(listenersForCollection, id)) {\n        listenersForCollection[id].callback(notification);\n      }\n    });\n  },\n\n  // A notification matches a trigger if all keys that exist in both are equal.\n  //\n  // Examples:\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}\n  //    (a non-targeted write to a collection matches a\n  //     non-targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}\n  //    (a targeted write to a collection matches a non-targeted query)\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a non-targeted write to a collection matches a\n  //     targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a targeted write to a collection matches a targeted query targeted\n  //     at the same document)\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}\n  //    (a targeted write to a collection does not match a targeted query\n  //     targeted at a different document)\n  _matches: function (notification, trigger) {\n    // Most notifications that use the crossbar have a string `collection` and\n    // maybe an `id` that is a string or ObjectID. We're already dividing up\n    // triggers by collection, but let's fast-track \"nope, different ID\" (and\n    // avoid the overly generic EJSON.equals). This makes a noticeable\n    // performance difference; see https://github.com/meteor/meteor/pull/3697\n    if (typeof(notification.id) === 'string' &&\n        typeof(trigger.id) === 'string' &&\n        notification.id !== trigger.id) {\n      return false;\n    }\n    if (notification.id instanceof MongoID.ObjectID &&\n        trigger.id instanceof MongoID.ObjectID &&\n        ! notification.id.equals(trigger.id)) {\n      return false;\n    }\n\n    return _.all(trigger, function (triggerValue, key) {\n      return !_.has(notification, key) ||\n        EJSON.equals(triggerValue, notification[key]);\n    });\n  }\n});\n\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to\n// implement write fence notifications. Listener callbacks on this crossbar\n// should call beginWrite on the current write fence before they return, if they\n// want to delay the write fence from firing (ie, the DDP method-data-updated\n// message from being sent).\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({\n  factName: \"invalidation-crossbar-listeners\"\n});\n","if (process.env.DDP_DEFAULT_CONNECTION_URL) {\n  __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL =\n    process.env.DDP_DEFAULT_CONNECTION_URL;\n}\n\nMeteor.server = new Server;\n\nMeteor.refresh = function (notification) {\n  DDPServer._InvalidationCrossbar.fire(notification);\n};\n\n// Proxy the public methods of Meteor.server so they can\n// be called directly on Meteor.\n_.each(['publish', 'methods', 'call', 'apply', 'onConnection'],\n       function (name) {\n         Meteor[name] = _.bind(Meteor.server[name], Meteor.server);\n       });\n\n// Meteor.server used to be called Meteor.default_server. Provide\n// backcompat as a courtesy even though it was never documented.\n// XXX COMPAT WITH 0.6.4\nMeteor.default_server = Meteor.server;\n"]}}]