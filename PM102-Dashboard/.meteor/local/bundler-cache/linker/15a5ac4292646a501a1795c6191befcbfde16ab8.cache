[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar meteorBabelHelpers;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"babel-runtime\":{\"babel-runtime.js\":[\"meteor-babel-helpers\",\"regenerator-runtime\",function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/babel-runtime/babel-runtime.js                                                                 //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar S = typeof Symbol === \"function\" ? Symbol : {};\nvar iteratorSymbol = S.iterator || \"@@iterator\";\n\nvar hasDefineProperty = false;\ntry {\n  // IE 8 has a broken Object.defineProperty, so feature-test by\n  // trying to call it.\n  Object.defineProperty({}, 'x', {});\n  hasDefineProperty = true;\n} catch (e) {}\n\nfunction defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexports.meteorBabelHelpers = require(\"meteor-babel-helpers\");\n\n// Returns true if a given absolute identifier will be provided at runtime\n// by the babel-runtime package.\nexports.checkHelper = function checkHelper(id) {\n  var parts = id.split(\"/\");\n  var index = 0;\n\n  // Skip over leading / and node_modules.\n  if (parts[index] === \"\") ++index;\n  if (parts[index] === \"node_modules\") ++index;\n\n  if (parts[index] !== \"babel-runtime\") {\n    return false;\n  }\n\n  // Skip over babel-runtime.\n  ++index;\n\n  if (parts.length - index === 2) {\n    return parts[index] === \"helpers\" &&\n      hasOwn.call(BabelRuntime, stripDotJS(parts[index + 1]));\n  }\n\n  if (parts.length - index === 1) {\n    return stripDotJS(parts[index]) === \"regenerator\";\n  }\n\n  return false;\n};\n\nfunction stripDotJS(name) {\n  return name.replace(/\\.js$/, \"\");\n}\n\nvar BabelRuntime = {\n  // es6.templateLiterals\n  // Constructs the object passed to the tag function in a tagged\n  // template literal.\n  taggedTemplateLiteralLoose: function (strings, raw) {\n    // Babel's own version of this calls Object.freeze on `strings` and\n    // `strings.raw`, but it doesn't seem worth the compatibility and\n    // performance concerns.  If you're writing code against this helper,\n    // don't add properties to these objects.\n    strings.raw = raw;\n    return strings;\n  },\n\n  // es6.classes\n  // Checks that a class constructor is being called with `new`, and throws\n  // an error if it is not.\n  classCallCheck: function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  },\n\n  // es6.classes\n  inherits: function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    if (superClass) {\n      if (Object.create) {\n        // All but IE 8\n        subClass.prototype = Object.create(superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n      } else {\n        // IE 8 path.  Slightly worse for modern browsers, because `constructor`\n        // is enumerable and shows up in the inspector unnecessarily.\n        // It's not an \"own\" property of any instance though.\n        //\n        // For correctness when writing code,\n        // don't enumerate all the own-and-inherited properties of an instance\n        // of a class and expect not to find `constructor` (but who does that?).\n        var F = function () {\n          this.constructor = subClass;\n        };\n        F.prototype = superClass.prototype;\n        subClass.prototype = new F();\n      }\n\n      // For modern browsers, this would be `subClass.__proto__ = superClass`,\n      // but IE <=10 don't support `__proto__`, and in this case the difference\n      // would be detectable; code that works in modern browsers could easily\n      // fail on IE 8 if we ever used the `__proto__` trick.\n      //\n      // There's no perfect way to make static methods inherited if they are\n      // assigned after declaration of the classes.  The best we can do is\n      // to copy them.  In other words, when you write `class Foo\n      // extends Bar`, we copy the static methods from Bar onto Foo, but future\n      // ones are not copied.\n      //\n      // For correctness when writing code, don't add static methods to a class\n      // after you subclass it.\n\n      // The ecmascript-runtime package provides adequate polyfills for\n      // all of these Object.* functions (and Array#forEach), and anyone\n      // using babel-runtime is almost certainly using it because of the\n      // ecmascript package, which also implies ecmascript-runtime.\n      Object.getOwnPropertyNames(superClass).forEach(function (k) {\n        // This property descriptor dance preserves getter/setter behavior\n        // in browsers that support accessor properties (all except\n        // IE8). In IE8, the superClass can't have accessor properties\n        // anyway, so this code is still safe.\n        var descriptor = Object.getOwnPropertyDescriptor(superClass, k);\n        if (descriptor && typeof descriptor === \"object\") {\n          if (Object.getOwnPropertyDescriptor(subClass, k)) {\n            // If subClass already has a property by this name, then it\n            // would not be inherited, so it should not be copied. This\n            // notably excludes properties like .prototype and .name.\n            return;\n          }\n\n          Object.defineProperty(subClass, k, descriptor);\n        }\n      });\n    }\n  },\n\n  defineProperty: function (obj, key, value) {\n    if (hasDefineProperty && (key in obj)) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  },\n\n  createClass: function (Constructor, protoProps, staticProps) {\n    if (! hasDefineProperty) {\n      // e.g. `class Foo { get bar() {} }`.  If you try to use getters and\n      // setters in IE 8, you will get a big nasty error, with or without\n      // Babel.  I don't know of any other syntax features besides getters\n      // and setters that will trigger this error.\n      throw new Error(\n        \"Your browser does not support this type of class property.  \" +\n          \"For example, Internet Explorer 8 does not support getters and \" +\n          \"setters.\");\n    }\n\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  },\n\n  \"typeof\": function (obj) {\n    return obj && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n  },\n\n  possibleConstructorReturn: function (self, call) {\n    if (! self) {\n      throw new ReferenceError(\n        \"this hasn't been initialised - super() hasn't been called\"\n      );\n    }\n\n    var callType = typeof call;\n    if (call &&\n        callType === \"function\" ||\n        callType === \"object\") {\n      return call;\n    }\n\n    return self;\n  },\n\n  interopRequireDefault: function (obj) {\n    return obj && obj.__esModule ? obj : { 'default': obj };\n  },\n\n  interopRequireWildcard: function (obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    }\n\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (hasOwn.call(obj, key)) {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  },\n\n  interopExportWildcard: function (obj, defaults) {\n    var newObj = defaults({}, obj);\n    delete newObj[\"default\"];\n    return newObj;\n  },\n\n  defaults: function (obj, defaults) {\n    Object.getOwnPropertyNames(defaults).forEach(function (key) {\n      var desc = Object.getOwnPropertyDescriptor(defaults, key);\n      if (desc && desc.configurable && typeof obj[key] === \"undefined\") {\n        Object.defineProperty(obj, key, desc);\n      }\n    });\n\n    return obj;\n  },\n\n  // es7.objectRestSpread and react (JSX)\n  \"extends\": Object.assign || (function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (hasOwn.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  }),\n\n  // es6.destructuring\n  objectWithoutProperties: function (obj, keys) {\n    var target = {};\n    outer: for (var i in obj) {\n      if (! hasOwn.call(obj, i)) continue;\n      for (var j = 0; j < keys.length; j++) {\n        if (keys[j] === i) continue outer;\n      }\n      target[i] = obj[i];\n    }\n    return target;\n  },\n\n  // es6.destructuring\n  objectDestructuringEmpty: function (obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  },\n\n  // es6.spread\n  bind: Function.prototype.bind || (function () {\n    var isCallable = function (value) { return typeof value === 'function'; };\n    var $Object = Object;\n    var to_string = Object.prototype.toString;\n    var array_slice = Array.prototype.slice;\n    var array_concat = Array.prototype.concat;\n    var array_push = Array.prototype.push;\n    var max = Math.max;\n    var Empty = function Empty() {};\n\n    // Copied from es5-shim.js (3ac7942).  See original for more comments.\n    return function bind(that) {\n      var target = this;\n      if (!isCallable(target)) {\n        throw new TypeError('Function.prototype.bind called on incompatible ' + target);\n      }\n\n      var args = array_slice.call(arguments, 1);\n\n      var bound;\n      var binder = function () {\n\n        if (this instanceof bound) {\n          var result = target.apply(\n            this,\n            array_concat.call(args, array_slice.call(arguments))\n          );\n          if ($Object(result) === result) {\n            return result;\n          }\n          return this;\n        } else {\n          return target.apply(\n            that,\n            array_concat.call(args, array_slice.call(arguments))\n          );\n        }\n      };\n\n      var boundLength = max(0, target.length - args.length);\n\n      var boundArgs = [];\n      for (var i = 0; i < boundLength; i++) {\n        array_push.call(boundArgs, '$' + i);\n      }\n\n      // Create a Function from source code so that it has the right `.length`.\n      // Probably not important for Babel.  This code violates CSPs that ban\n      // `eval`, but the browsers that need this polyfill don't have CSP!\n      bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\n\n      if (target.prototype) {\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n      }\n\n      return bound;\n    };\n\n  })(),\n\n  toConsumableArray: function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = arr.length - 1, arr2 = Array(i + 1); i >= 0; --i) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    }\n\n    return Array.from(arr);\n  },\n\n  toArray: function (arr) {\n    return Array.isArray(arr) ? arr : Array.from(arr);\n  },\n\n  slicedToArray: function (iterable, limit) {\n    if (Array.isArray(iterable)) {\n      return iterable;\n    }\n\n    if (iterable) {\n      var it = iterable[iteratorSymbol]();\n      var result = [];\n      var info;\n\n      if (typeof limit !== \"number\") {\n        limit = Infinity;\n      }\n\n      while (result.length < limit &&\n             ! (info = it.next()).done) {\n        result.push(info.value);\n      }\n\n      return result;\n    }\n\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance\"\n    );\n  },\n\n  slice: Array.prototype.slice\n};\n\n// Use meteorInstall to install all of the above helper functions within\n// node_modules/babel-runtime/helpers.\nObject.keys(BabelRuntime).forEach(function (helperName) {\n  var helpers = {};\n\n  helpers[helperName + \".js\"] = function (require, exports, module) {\n    module.exports = BabelRuntime[helperName];\n  };\n\n  meteorInstall({\n    node_modules: {\n      \"babel-runtime\": {\n        helpers: helpers\n      }\n    }\n  });\n});\n\n// Use meteorInstall to install the regenerator runtime at\n// node_modules/babel-runtime/regenerator.\nmeteorInstall({\n  node_modules: {\n    \"babel-runtime\": {\n      \"regenerator.js\": function (r, e, module) {\n        // Note that we use the require function provided to the\n        // babel-runtime.js file, not the one named 'r' above.\n        var runtime = require(\"regenerator-runtime\");\n\n        // If Promise.asyncApply is defined, use it to wrap calls to\n        // runtime.async so that the entire async function will run in its\n        // own Fiber, not just the code that comes after the first await.\n        if (typeof Promise === \"function\" &&\n            typeof Promise.asyncApply === \"function\") {\n          var realAsync = runtime.async;\n          runtime.async = function () {\n            return Promise.asyncApply(realAsync, runtime, arguments);\n          };\n        }\n\n        module.exports = runtime;\n      }\n    }\n  }\n});\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"meteor-babel-helpers\":{\"package.json\":function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// ../../.0.1.12.1fuj6pb++os+web.browser+web.cordova/npm/node_modules/meteor-babel-helpers/package.json    //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nexports.name = \"meteor-babel-helpers\";\nexports.version = \"0.0.3\";\nexports.main = \"index.js\";\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// node_modules/meteor/babel-runtime/node_modules/meteor-babel-helpers/index.js                            //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nfunction canDefineNonEnumerableProperties() {\n  var testObj = {};\n  var testPropName = \"t\";\n\n  try {\n    Object.defineProperty(testObj, testPropName, {\n      enumerable: false,\n      value: testObj\n    });\n\n    for (var k in testObj) {\n      if (k === testPropName) {\n        return false;\n      }\n    }\n  } catch (e) {\n    return false;\n  }\n\n  return testObj[testPropName] === testObj;\n}\n\nfunction sanitizeEasy(value) {\n  return value;\n}\n\nfunction sanitizeHard(obj) {\n  if (Array.isArray(obj)) {\n    var newObj = {};\n    var keys = Object.keys(obj);\n    var keyCount = keys.length;\n    for (var i = 0; i < keyCount; ++i) {\n      var key = keys[i];\n      newObj[key] = obj[key];\n    }\n    return newObj;\n  }\n\n  return obj;\n}\n\nmeteorBabelHelpers = module.exports = {\n  // Meteor-specific runtime helper for wrapping the object of for-in\n  // loops, so that inherited Array methods defined by es5-shim can be\n  // ignored in browsers where they cannot be defined as non-enumerable.\n  sanitizeForInObject: canDefineNonEnumerableProperties()\n    ? sanitizeEasy\n    : sanitizeHard,\n\n  // Exposed so that we can test sanitizeForInObject in environments that\n  // support defining non-enumerable properties.\n  _sanitizeForInObjectHard: sanitizeHard\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"regenerator-runtime\":{\"package.json\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// ../../.0.1.12.1fuj6pb++os+web.browser+web.cordova/npm/node_modules/regenerator-runtime/package.json     //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nexports.name = \"regenerator-runtime\";\nexports.version = \"0.9.5\";\nexports.main = \"runtime-module.js\";\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"runtime-module.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// node_modules/meteor/babel-runtime/node_modules/regenerator-runtime/runtime-module.js                    //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}},{\"extensions\":[\".js\",\".json\"]});\nvar exports = require(\"./node_modules/meteor/babel-runtime/babel-runtime.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['babel-runtime'] = exports, {\n  meteorBabelHelpers: meteorBabelHelpers\n});\n\n})();\n","servePath":"/packages/babel-runtime.js"}]