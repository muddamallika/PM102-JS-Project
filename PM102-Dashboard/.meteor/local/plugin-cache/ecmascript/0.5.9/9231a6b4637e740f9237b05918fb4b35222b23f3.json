{"metadata":{"usedHelpers":["inherits","possibleConstructorReturn","classCallCheck"],"marked":[],"modules":{"imports":[{"source":"./accounts_common.js","imported":["AccountsCommon"],"specifiers":[{"kind":"named","imported":"AccountsCommon","local":"AccountsCommon"}]}],"exports":{"exported":["AccountsClient"],"specifiers":[{"kind":"local","local":"AccountsClient","exported":"AccountsClient"}]}}},"options":{"filename":"/packages/accounts-base/accounts_client.js","filenameRelative":"/packages/accounts-base/accounts_client.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/accounts-base/accounts_client.js.map","sourceFileName":"/packages/accounts-base/accounts_client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"accounts_client"},"ignored":false,"code":"module.export({AccountsClient:function(){return AccountsClient}});var _classCallCheck;module.import(\"babel-runtime/helpers/classCallCheck\",{\"default\":function(v){_classCallCheck=v}});var _possibleConstructorReturn;module.import(\"babel-runtime/helpers/possibleConstructorReturn\",{\"default\":function(v){_possibleConstructorReturn=v}});var _inherits;module.import(\"babel-runtime/helpers/inherits\",{\"default\":function(v){_inherits=v}});var AccountsCommon;module.import(\"./accounts_common.js\",{\"AccountsCommon\":function(v){AccountsCommon=v}});\n\n\n\n\n/**\n * @summary Constructor for the `Accounts` object on the client.\n * @locus Client\n * @class AccountsClient\n * @extends AccountsCommon\n * @instancename accountsClient\n * @param {Object} options an object with fields:\n * @param {Object} options.connection Optional DDP connection to reuse.\n * @param {String} options.ddpUrl Optional URL for creating a new DDP connection.\n */\nvar AccountsClient = function (_AccountsCommon) {\n  _inherits(AccountsClient, _AccountsCommon);\n\n  function AccountsClient(options) {\n    _classCallCheck(this, AccountsClient);\n\n    var _this = _possibleConstructorReturn(this, _AccountsCommon.call(this, options));\n\n    _this._loggingIn = false;\n    _this._loggingInDeps = new Tracker.Dependency();\n\n    _this._loginServicesHandle = _this.connection.subscribe(\"meteor.loginServiceConfiguration\");\n\n    _this._pageLoadLoginCallbacks = [];\n    _this._pageLoadLoginAttemptInfo = null;\n\n    // Defined in url_client.js.\n    _this._initUrlMatching();\n\n    // Defined in localstorage_token.js.\n    _this._initLocalStorage();\n    return _this;\n  }\n\n  ///\n  /// CURRENT USER\n  ///\n\n  // @override\n\n\n  AccountsClient.prototype.userId = function () {\n    function userId() {\n      return this.connection.userId();\n    }\n\n    return userId;\n  }();\n\n  // This is mostly just called within this file, but Meteor.loginWithPassword\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\n  // method call too.\n\n\n  AccountsClient.prototype._setLoggingIn = function () {\n    function _setLoggingIn(x) {\n      if (this._loggingIn !== x) {\n        this._loggingIn = x;\n        this._loggingInDeps.changed();\n      }\n    }\n\n    return _setLoggingIn;\n  }();\n\n  /**\n   * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n   * @locus Client\n   */\n\n\n  AccountsClient.prototype.loggingIn = function () {\n    function loggingIn() {\n      this._loggingInDeps.depend();\n      return this._loggingIn;\n    }\n\n    return loggingIn;\n  }();\n\n  /**\n   * @summary Log the user out.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n\n\n  AccountsClient.prototype.logout = function () {\n    function logout(callback) {\n      var self = this;\n      self.connection.apply('logout', [], {\n        wait: true\n      }, function (error, result) {\n        if (error) {\n          callback && callback(error);\n        } else {\n          self.makeClientLoggedOut();\n          callback && callback();\n        }\n      });\n    }\n\n    return logout;\n  }();\n\n  /**\n   * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n\n\n  AccountsClient.prototype.logoutOtherClients = function () {\n    function logoutOtherClients(callback) {\n      var self = this;\n\n      // We need to make two method calls: one to replace our current token,\n      // and another to remove all tokens except the current one. We want to\n      // call these two methods one after the other, without any other\n      // methods running between them. For example, we don't want `logout`\n      // to be called in between our two method calls (otherwise the second\n      // method call would return an error). Another example: we don't want\n      // logout to be called before the callback for `getNewToken`;\n      // otherwise we would momentarily log the user out and then write a\n      // new token to localStorage.\n      //\n      // To accomplish this, we make both calls as wait methods, and queue\n      // them one after the other, without spinning off the event loop in\n      // between. Even though we queue `removeOtherTokens` before\n      // `getNewToken`, we won't actually send the `removeOtherTokens` call\n      // until the `getNewToken` callback has finished running, because they\n      // are both wait methods.\n      self.connection.apply('getNewToken', [], { wait: true }, function (err, result) {\n        if (!err) {\n          self._storeLoginToken(self.userId(), result.token, result.tokenExpires);\n        }\n      });\n\n      self.connection.apply('removeOtherTokens', [], { wait: true }, function (err) {\n        callback && callback(err);\n      });\n    }\n\n    return logoutOtherClients;\n  }();\n\n  return AccountsClient;\n}(AccountsCommon);;\n\nvar Ap = AccountsClient.prototype;\n\n/**\n * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n * @locus Client\n * @importFromPackage meteor\n */\nMeteor.loggingIn = function () {\n  return Accounts.loggingIn();\n};\n\n///\n/// LOGIN METHODS\n///\n\n// Call a login method on the server.\n//\n// A login method is a method which on success calls `this.setUserId(id)` and\n// `Accounts._setLoginToken` on the server and returns an object with fields\n// 'id' (containing the user id), 'token' (containing a resume token), and\n// optionally `tokenExpires`.\n//\n// This function takes care of:\n//   - Updating the Meteor.loggingIn() reactive data source\n//   - Calling the method in 'wait' mode\n//   - On success, saving the resume token to localStorage\n//   - On success, calling Accounts.connection.setUserId()\n//   - Setting up an onReconnect handler which logs in with\n//     the resume token\n//\n// Options:\n// - methodName: The method to call (default 'login')\n// - methodArguments: The arguments for the method\n// - validateResult: If provided, will be called with the result of the\n//                 method. If it throws, the client will not be logged in (and\n//                 its error will be passed to the callback).\n// - userCallback: Will be called with no arguments once the user is fully\n//                 logged in, or with the error on error.\n//\nAp.callLoginMethod = function (options) {\n  var self = this;\n\n  options = _.extend({\n    methodName: 'login',\n    methodArguments: [{}],\n    _suppressLoggingIn: false\n  }, options);\n\n  // Set defaults for callback arguments to no-op functions; make sure we\n  // override falsey values too.\n  _.each(['validateResult', 'userCallback'], function (f) {\n    if (!options[f]) options[f] = function () {};\n  });\n\n  // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\n  var loginCallbacks = _.once(function (error) {\n    if (!error) {\n      self._onLoginHook.each(function (callback) {\n        callback();\n        return true;\n      });\n    } else {\n      self._onLoginFailureHook.each(function (callback) {\n        callback({ error: error });\n        return true;\n      });\n    }\n    options.userCallback.apply(this, arguments);\n  });\n\n  var reconnected = false;\n\n  // We want to set up onReconnect as soon as we get a result token back from\n  // the server, without having to wait for subscriptions to rerun. This is\n  // because if we disconnect and reconnect between getting the result and\n  // getting the results of subscription rerun, we WILL NOT re-send this\n  // method (because we never re-send methods whose results we've received)\n  // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n  // time. This will lead to makeClientLoggedIn(result.id) even though we\n  // haven't actually sent a login method!\n  //\n  // But by making sure that we send this \"resume\" login in that case (and\n  // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n  // client-side userId. (It's important that livedata_connection guarantees\n  // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n  // will occur before the callback from the resume login call.)\n  var onResultReceived = function onResultReceived(err, result) {\n    if (err || !result || !result.token) {\n      // Leave onReconnect alone if there was an error, so that if the user was\n      // already logged in they will still get logged in on reconnect.\n      // See issue #4970.\n    } else {\n      self.connection.onReconnect = function () {\n        reconnected = true;\n        // If our token was updated in storage, use the latest one.\n        var storedToken = self._storedLoginToken();\n        if (storedToken) {\n          result = {\n            token: storedToken,\n            tokenExpires: self._storedLoginTokenExpires()\n          };\n        }\n        if (!result.tokenExpires) result.tokenExpires = self._tokenExpiration(new Date());\n        if (self._tokenExpiresSoon(result.tokenExpires)) {\n          self.makeClientLoggedOut();\n        } else {\n          self.callLoginMethod({\n            methodArguments: [{ resume: result.token }],\n            // Reconnect quiescence ensures that the user doesn't see an\n            // intermediate state before the login method finishes. So we don't\n            // need to show a logging-in animation.\n            _suppressLoggingIn: true,\n            userCallback: function () {\n              function userCallback(error) {\n                var storedTokenNow = self._storedLoginToken();\n                if (error) {\n                  // If we had a login error AND the current stored token is the\n                  // one that we tried to log in with, then declare ourselves\n                  // logged out. If there's a token in storage but it's not the\n                  // token that we tried to log in with, we don't know anything\n                  // about whether that token is valid or not, so do nothing. The\n                  // periodic localStorage poll will decide if we are logged in or\n                  // out with this token, if it hasn't already. Of course, even\n                  // with this check, another tab could insert a new valid token\n                  // immediately before we clear localStorage here, which would\n                  // lead to both tabs being logged out, but by checking the token\n                  // in storage right now we hope to make that unlikely to happen.\n                  //\n                  // If there is no token in storage right now, we don't have to\n                  // do anything; whatever code removed the token from storage was\n                  // responsible for calling `makeClientLoggedOut()`, or the\n                  // periodic localStorage poll will call `makeClientLoggedOut`\n                  // eventually if another tab wiped the token from storage.\n                  if (storedTokenNow && storedTokenNow === result.token) {\n                    self.makeClientLoggedOut();\n                  }\n                }\n                // Possibly a weird callback to call, but better than nothing if\n                // there is a reconnect between \"login result received\" and \"data\n                // ready\".\n                loginCallbacks(error);\n              }\n\n              return userCallback;\n            }() });\n        }\n      };\n    }\n  };\n\n  // This callback is called once the local cache of the current-user\n  // subscription (and all subscriptions, in fact) are guaranteed to be up to\n  // date.\n  var loggedInAndDataReadyCallback = function loggedInAndDataReadyCallback(error, result) {\n    // If the login method returns its result but the connection is lost\n    // before the data is in the local cache, it'll set an onReconnect (see\n    // above). The onReconnect will try to log in using the token, and *it*\n    // will call userCallback via its own version of this\n    // loggedInAndDataReadyCallback. So we don't have to do anything here.\n    if (reconnected) return;\n\n    // Note that we need to call this even if _suppressLoggingIn is true,\n    // because it could be matching a _setLoggingIn(true) from a\n    // half-completed pre-reconnect login method.\n    self._setLoggingIn(false);\n    if (error || !result) {\n      error = error || new Error(\"No result from call to \" + options.methodName);\n      loginCallbacks(error);\n      return;\n    }\n    try {\n      options.validateResult(result);\n    } catch (e) {\n      loginCallbacks(e);\n      return;\n    }\n\n    // Make the client logged in. (The user data should already be loaded!)\n    self.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\n    loginCallbacks();\n  };\n\n  if (!options._suppressLoggingIn) self._setLoggingIn(true);\n  self.connection.apply(options.methodName, options.methodArguments, { wait: true, onResultReceived: onResultReceived }, loggedInAndDataReadyCallback);\n};\n\nAp.makeClientLoggedOut = function () {\n  // Ensure client was successfully logged in before running logout hooks.\n  if (this.connection._userId) {\n    this._onLogoutHook.each(function (callback) {\n      callback();\n      return true;\n    });\n  }\n  this._unstoreLoginToken();\n  this.connection.setUserId(null);\n  this.connection.onReconnect = null;\n};\n\nAp.makeClientLoggedIn = function (userId, token, tokenExpires) {\n  this._storeLoginToken(userId, token, tokenExpires);\n  this.connection.setUserId(userId);\n};\n\n/**\n * @summary Log the user out.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\nMeteor.logout = function (callback) {\n  return Accounts.logout(callback);\n};\n\n/**\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\nMeteor.logoutOtherClients = function (callback) {\n  return Accounts.logoutOtherClients(callback);\n};\n\n///\n/// LOGIN SERVICES\n///\n\n// A reactive function returning whether the loginServiceConfiguration\n// subscription is ready. Used by accounts-ui to hide the login button\n// until we have all the configuration loaded\n//\nAp.loginServicesConfigured = function () {\n  return this._loginServicesHandle.ready();\n};\n\n// Some login services such as the redirect login flow or the resume\n// login handler can log the user in at page load time.  The\n// Meteor.loginWithX functions have a callback argument, but the\n// callback function instance won't be in memory any longer if the\n// page was reloaded.  The `onPageLoadLogin` function allows a\n// callback to be registered for the case where the login was\n// initiated in a previous VM, and we now have the result of the login\n// attempt in a new VM.\n\n// Register a callback to be called if we have information about a\n// login attempt at page load time.  Call the callback immediately if\n// we already have the page load login attempt info, otherwise stash\n// the callback to be called if and when we do get the attempt info.\n//\nAp.onPageLoadLogin = function (f) {\n  if (this._pageLoadLoginAttemptInfo) {\n    f(this._pageLoadLoginAttemptInfo);\n  } else {\n    this._pageLoadLoginCallbacks.push(f);\n  }\n};\n\n// Receive the information about the login attempt at page load time.\n// Call registered callbacks, and also record the info in case\n// someone's callback hasn't been registered yet.\n//\nAp._pageLoadLogin = function (attemptInfo) {\n  if (this._pageLoadLoginAttemptInfo) {\n    Meteor._debug(\"Ignoring unexpected duplicate page load login attempt info\");\n    return;\n  }\n\n  _.each(this._pageLoadLoginCallbacks, function (callback) {\n    callback(attemptInfo);\n  });\n\n  this._pageLoadLoginCallbacks = [];\n  this._pageLoadLoginAttemptInfo = attemptInfo;\n};\n\n///\n/// HANDLEBARS HELPERS\n///\n\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\n// global helpers.\nif (Package.blaze) {\n  /**\n   * @global\n   * @name  currentUser\n   * @isHelper true\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\n   */\n  Package.blaze.Blaze.Template.registerHelper('currentUser', function () {\n    return Meteor.user();\n  });\n\n  /**\n   * @global\n   * @name  loggingIn\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\n   */\n  Package.blaze.Blaze.Template.registerHelper('loggingIn', function () {\n    return Meteor.loggingIn();\n  });\n}","ast":null,"map":{"version":3,"sources":["/packages/accounts-base/accounts_client.js"],"names":["AccountsCommon","AccountsClient","options","_loggingIn","_loggingInDeps","Tracker","Dependency","_loginServicesHandle","connection","subscribe","_pageLoadLoginCallbacks","_pageLoadLoginAttemptInfo","_initUrlMatching","_initLocalStorage","userId","_setLoggingIn","x","changed","loggingIn","depend","logout","callback","self","apply","wait","error","result","makeClientLoggedOut","logoutOtherClients","err","_storeLoginToken","token","tokenExpires","Ap","prototype","Meteor","Accounts","callLoginMethod","_","extend","methodName","methodArguments","_suppressLoggingIn","each","f","loginCallbacks","once","_onLoginHook","_onLoginFailureHook","userCallback","arguments","reconnected","onResultReceived","onReconnect","storedToken","_storedLoginToken","_storedLoginTokenExpires","_tokenExpiration","Date","_tokenExpiresSoon","resume","storedTokenNow","loggedInAndDataReadyCallback","Error","validateResult","e","makeClientLoggedIn","id","_userId","_onLogoutHook","_unstoreLoginToken","setUserId","loginServicesConfigured","ready","onPageLoadLogin","push","_pageLoadLogin","attemptInfo","_debug","Package","blaze","Blaze","Template","registerHelper","user"],"mappings":"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","file":"/packages/accounts-base/accounts_client.js.map","sourcesContent":["import {AccountsCommon} from \"./accounts_common.js\";\n\n/**\n * @summary Constructor for the `Accounts` object on the client.\n * @locus Client\n * @class AccountsClient\n * @extends AccountsCommon\n * @instancename accountsClient\n * @param {Object} options an object with fields:\n * @param {Object} options.connection Optional DDP connection to reuse.\n * @param {String} options.ddpUrl Optional URL for creating a new DDP connection.\n */\nexport class AccountsClient extends AccountsCommon {\n  constructor(options) {\n    super(options);\n\n    this._loggingIn = false;\n    this._loggingInDeps = new Tracker.Dependency;\n\n    this._loginServicesHandle =\n      this.connection.subscribe(\"meteor.loginServiceConfiguration\");\n\n    this._pageLoadLoginCallbacks = [];\n    this._pageLoadLoginAttemptInfo = null;\n\n    // Defined in url_client.js.\n    this._initUrlMatching();\n\n    // Defined in localstorage_token.js.\n    this._initLocalStorage();\n  }\n\n  ///\n  /// CURRENT USER\n  ///\n\n  // @override\n  userId() {\n    return this.connection.userId();\n  }\n\n  // This is mostly just called within this file, but Meteor.loginWithPassword\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\n  // method call too.\n  _setLoggingIn(x) {\n    if (this._loggingIn !== x) {\n      this._loggingIn = x;\n      this._loggingInDeps.changed();\n    }\n  }\n\n  /**\n   * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n   * @locus Client\n   */\n  loggingIn() {\n    this._loggingInDeps.depend();\n    return this._loggingIn;\n  }\n\n  /**\n   * @summary Log the user out.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n  logout(callback) {\n    var self = this;\n    self.connection.apply('logout', [], {\n      wait: true\n    }, function (error, result) {\n      if (error) {\n        callback && callback(error);\n      } else {\n        self.makeClientLoggedOut();\n        callback && callback();\n      }\n    });\n  }\n\n  /**\n   * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n  logoutOtherClients(callback) {\n    var self = this;\n\n    // We need to make two method calls: one to replace our current token,\n    // and another to remove all tokens except the current one. We want to\n    // call these two methods one after the other, without any other\n    // methods running between them. For example, we don't want `logout`\n    // to be called in between our two method calls (otherwise the second\n    // method call would return an error). Another example: we don't want\n    // logout to be called before the callback for `getNewToken`;\n    // otherwise we would momentarily log the user out and then write a\n    // new token to localStorage.\n    //\n    // To accomplish this, we make both calls as wait methods, and queue\n    // them one after the other, without spinning off the event loop in\n    // between. Even though we queue `removeOtherTokens` before\n    // `getNewToken`, we won't actually send the `removeOtherTokens` call\n    // until the `getNewToken` callback has finished running, because they\n    // are both wait methods.\n    self.connection.apply(\n      'getNewToken',\n      [],\n      { wait: true },\n      function (err, result) {\n        if (! err) {\n          self._storeLoginToken(\n            self.userId(),\n            result.token,\n            result.tokenExpires\n          );\n        }\n      }\n    );\n\n    self.connection.apply(\n      'removeOtherTokens',\n      [],\n      { wait: true },\n      function (err) {\n        callback && callback(err);\n      }\n    );\n  }\n};\n\nvar Ap = AccountsClient.prototype;\n\n/**\n * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n * @locus Client\n * @importFromPackage meteor\n */\nMeteor.loggingIn = function () {\n  return Accounts.loggingIn();\n};\n\n///\n/// LOGIN METHODS\n///\n\n// Call a login method on the server.\n//\n// A login method is a method which on success calls `this.setUserId(id)` and\n// `Accounts._setLoginToken` on the server and returns an object with fields\n// 'id' (containing the user id), 'token' (containing a resume token), and\n// optionally `tokenExpires`.\n//\n// This function takes care of:\n//   - Updating the Meteor.loggingIn() reactive data source\n//   - Calling the method in 'wait' mode\n//   - On success, saving the resume token to localStorage\n//   - On success, calling Accounts.connection.setUserId()\n//   - Setting up an onReconnect handler which logs in with\n//     the resume token\n//\n// Options:\n// - methodName: The method to call (default 'login')\n// - methodArguments: The arguments for the method\n// - validateResult: If provided, will be called with the result of the\n//                 method. If it throws, the client will not be logged in (and\n//                 its error will be passed to the callback).\n// - userCallback: Will be called with no arguments once the user is fully\n//                 logged in, or with the error on error.\n//\nAp.callLoginMethod = function (options) {\n  var self = this;\n\n  options = _.extend({\n    methodName: 'login',\n    methodArguments: [{}],\n    _suppressLoggingIn: false\n  }, options);\n\n  // Set defaults for callback arguments to no-op functions; make sure we\n  // override falsey values too.\n  _.each(['validateResult', 'userCallback'], function (f) {\n    if (!options[f])\n      options[f] = function () {};\n  });\n\n  // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\n  var loginCallbacks = _.once(function (error) {\n    if (!error) {\n      self._onLoginHook.each(function (callback) {\n        callback();\n        return true;\n      });\n    } else {\n      self._onLoginFailureHook.each(function (callback) {\n        callback({ error });\n        return true;\n      });\n    }\n    options.userCallback.apply(this, arguments);\n  });\n\n  var reconnected = false;\n\n  // We want to set up onReconnect as soon as we get a result token back from\n  // the server, without having to wait for subscriptions to rerun. This is\n  // because if we disconnect and reconnect between getting the result and\n  // getting the results of subscription rerun, we WILL NOT re-send this\n  // method (because we never re-send methods whose results we've received)\n  // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n  // time. This will lead to makeClientLoggedIn(result.id) even though we\n  // haven't actually sent a login method!\n  //\n  // But by making sure that we send this \"resume\" login in that case (and\n  // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n  // client-side userId. (It's important that livedata_connection guarantees\n  // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n  // will occur before the callback from the resume login call.)\n  var onResultReceived = function (err, result) {\n    if (err || !result || !result.token) {\n      // Leave onReconnect alone if there was an error, so that if the user was\n      // already logged in they will still get logged in on reconnect.\n      // See issue #4970.\n    } else {\n      self.connection.onReconnect = function () {\n        reconnected = true;\n        // If our token was updated in storage, use the latest one.\n        var storedToken = self._storedLoginToken();\n        if (storedToken) {\n          result = {\n            token: storedToken,\n            tokenExpires: self._storedLoginTokenExpires()\n          };\n        }\n        if (! result.tokenExpires)\n          result.tokenExpires = self._tokenExpiration(new Date());\n        if (self._tokenExpiresSoon(result.tokenExpires)) {\n          self.makeClientLoggedOut();\n        } else {\n          self.callLoginMethod({\n            methodArguments: [{resume: result.token}],\n            // Reconnect quiescence ensures that the user doesn't see an\n            // intermediate state before the login method finishes. So we don't\n            // need to show a logging-in animation.\n            _suppressLoggingIn: true,\n            userCallback: function (error) {\n              var storedTokenNow = self._storedLoginToken();\n              if (error) {\n                // If we had a login error AND the current stored token is the\n                // one that we tried to log in with, then declare ourselves\n                // logged out. If there's a token in storage but it's not the\n                // token that we tried to log in with, we don't know anything\n                // about whether that token is valid or not, so do nothing. The\n                // periodic localStorage poll will decide if we are logged in or\n                // out with this token, if it hasn't already. Of course, even\n                // with this check, another tab could insert a new valid token\n                // immediately before we clear localStorage here, which would\n                // lead to both tabs being logged out, but by checking the token\n                // in storage right now we hope to make that unlikely to happen.\n                //\n                // If there is no token in storage right now, we don't have to\n                // do anything; whatever code removed the token from storage was\n                // responsible for calling `makeClientLoggedOut()`, or the\n                // periodic localStorage poll will call `makeClientLoggedOut`\n                // eventually if another tab wiped the token from storage.\n                if (storedTokenNow && storedTokenNow === result.token) {\n                  self.makeClientLoggedOut();\n                }\n              }\n              // Possibly a weird callback to call, but better than nothing if\n              // there is a reconnect between \"login result received\" and \"data\n              // ready\".\n              loginCallbacks(error);\n            }});\n        }\n      };\n    }\n  };\n\n  // This callback is called once the local cache of the current-user\n  // subscription (and all subscriptions, in fact) are guaranteed to be up to\n  // date.\n  var loggedInAndDataReadyCallback = function (error, result) {\n    // If the login method returns its result but the connection is lost\n    // before the data is in the local cache, it'll set an onReconnect (see\n    // above). The onReconnect will try to log in using the token, and *it*\n    // will call userCallback via its own version of this\n    // loggedInAndDataReadyCallback. So we don't have to do anything here.\n    if (reconnected)\n      return;\n\n    // Note that we need to call this even if _suppressLoggingIn is true,\n    // because it could be matching a _setLoggingIn(true) from a\n    // half-completed pre-reconnect login method.\n    self._setLoggingIn(false);\n    if (error || !result) {\n      error = error || new Error(\n        \"No result from call to \" + options.methodName);\n      loginCallbacks(error);\n      return;\n    }\n    try {\n      options.validateResult(result);\n    } catch (e) {\n      loginCallbacks(e);\n      return;\n    }\n\n    // Make the client logged in. (The user data should already be loaded!)\n    self.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\n    loginCallbacks();\n  };\n\n  if (!options._suppressLoggingIn)\n    self._setLoggingIn(true);\n  self.connection.apply(\n    options.methodName,\n    options.methodArguments,\n    {wait: true, onResultReceived: onResultReceived},\n    loggedInAndDataReadyCallback);\n};\n\nAp.makeClientLoggedOut = function () {\n  // Ensure client was successfully logged in before running logout hooks.\n  if (this.connection._userId) {\n    this._onLogoutHook.each(function (callback) {\n      callback();\n      return true;\n    });\n  }\n  this._unstoreLoginToken();\n  this.connection.setUserId(null);\n  this.connection.onReconnect = null;\n};\n\nAp.makeClientLoggedIn = function (userId, token, tokenExpires) {\n  this._storeLoginToken(userId, token, tokenExpires);\n  this.connection.setUserId(userId);\n};\n\n/**\n * @summary Log the user out.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\nMeteor.logout = function (callback) {\n  return Accounts.logout(callback);\n};\n\n/**\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\nMeteor.logoutOtherClients = function (callback) {\n  return Accounts.logoutOtherClients(callback);\n};\n\n\n///\n/// LOGIN SERVICES\n///\n\n// A reactive function returning whether the loginServiceConfiguration\n// subscription is ready. Used by accounts-ui to hide the login button\n// until we have all the configuration loaded\n//\nAp.loginServicesConfigured = function () {\n  return this._loginServicesHandle.ready();\n};\n\n\n// Some login services such as the redirect login flow or the resume\n// login handler can log the user in at page load time.  The\n// Meteor.loginWithX functions have a callback argument, but the\n// callback function instance won't be in memory any longer if the\n// page was reloaded.  The `onPageLoadLogin` function allows a\n// callback to be registered for the case where the login was\n// initiated in a previous VM, and we now have the result of the login\n// attempt in a new VM.\n\n// Register a callback to be called if we have information about a\n// login attempt at page load time.  Call the callback immediately if\n// we already have the page load login attempt info, otherwise stash\n// the callback to be called if and when we do get the attempt info.\n//\nAp.onPageLoadLogin = function (f) {\n  if (this._pageLoadLoginAttemptInfo) {\n    f(this._pageLoadLoginAttemptInfo);\n  } else {\n    this._pageLoadLoginCallbacks.push(f);\n  }\n};\n\n\n// Receive the information about the login attempt at page load time.\n// Call registered callbacks, and also record the info in case\n// someone's callback hasn't been registered yet.\n//\nAp._pageLoadLogin = function (attemptInfo) {\n  if (this._pageLoadLoginAttemptInfo) {\n    Meteor._debug(\"Ignoring unexpected duplicate page load login attempt info\");\n    return;\n  }\n\n  _.each(this._pageLoadLoginCallbacks, function (callback) {\n    callback(attemptInfo);\n  });\n\n  this._pageLoadLoginCallbacks = [];\n  this._pageLoadLoginAttemptInfo = attemptInfo;\n};\n\n\n///\n/// HANDLEBARS HELPERS\n///\n\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\n// global helpers.\nif (Package.blaze) {\n  /**\n   * @global\n   * @name  currentUser\n   * @isHelper true\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\n   */\n  Package.blaze.Blaze.Template.registerHelper('currentUser', function () {\n    return Meteor.user();\n  });\n\n  /**\n   * @global\n   * @name  loggingIn\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\n   */\n  Package.blaze.Blaze.Template.registerHelper('loggingIn', function () {\n    return Meteor.loggingIn();\n  });\n}\n"]},"hash":"9231a6b4637e740f9237b05918fb4b35222b23f3"}
