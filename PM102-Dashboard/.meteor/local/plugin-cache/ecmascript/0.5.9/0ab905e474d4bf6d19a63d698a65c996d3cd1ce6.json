{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ddp-server/writefence.js","filenameRelative":"/packages/ddp-server/writefence.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ddp-server/writefence.js.map","sourceFileName":"/packages/ddp-server/writefence.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"writefence"},"ignored":false,"code":"var path = Npm.require('path');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\n// A write fence collects a group of writes, and provides a callback\n// when all of the writes are fully committed and propagated (all\n// observers have been notified of the write and acknowledged it.)\n//\nDDPServer._WriteFence = function () {\n  var self = this;\n\n  self.armed = false;\n  self.fired = false;\n  self.retired = false;\n  self.outstanding_writes = 0;\n  self.before_fire_callbacks = [];\n  self.completion_callbacks = [];\n};\n\n// The current write fence. When there is a current write fence, code\n// that writes to databases should register their writes with it using\n// beginWrite().\n//\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable();\n\n_.extend(DDPServer._WriteFence.prototype, {\n  // Start tracking a write, and return an object to represent it. The\n  // object has a single method, committed(). This method should be\n  // called when the write is fully committed and propagated. You can\n  // continue to add writes to the WriteFence up until it is triggered\n  // (calls its callbacks because all writes have committed.)\n  beginWrite: function () {\n    function beginWrite() {\n      var self = this;\n\n      if (self.retired) return { committed: function () {\n          function committed() {}\n\n          return committed;\n        }() };\n\n      if (self.fired) throw new Error(\"fence has already activated -- too late to add writes\");\n\n      self.outstanding_writes++;\n      var _committed = false;\n      return {\n        committed: function () {\n          function committed() {\n            if (_committed) throw new Error(\"committed called twice on the same write\");\n            _committed = true;\n            self.outstanding_writes--;\n            self._maybeFire();\n          }\n\n          return committed;\n        }()\n      };\n    }\n\n    return beginWrite;\n  }(),\n\n  // Arm the fence. Once the fence is armed, and there are no more\n  // uncommitted writes, it will activate.\n  arm: function () {\n    function arm() {\n      var self = this;\n      if (self === DDPServer._CurrentWriteFence.get()) throw Error(\"Can't arm the current fence\");\n      self.armed = true;\n      self._maybeFire();\n    }\n\n    return arm;\n  }(),\n\n  // Register a function to be called once before firing the fence.\n  // Callback function can add new writes to the fence, in which case\n  // it won't fire until those writes are done as well.\n  onBeforeFire: function () {\n    function onBeforeFire(func) {\n      var self = this;\n      if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");\n      self.before_fire_callbacks.push(func);\n    }\n\n    return onBeforeFire;\n  }(),\n\n  // Register a function to be called when the fence fires.\n  onAllCommitted: function () {\n    function onAllCommitted(func) {\n      var self = this;\n      if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");\n      self.completion_callbacks.push(func);\n    }\n\n    return onAllCommitted;\n  }(),\n\n  // Convenience function. Arms the fence, then blocks until it fires.\n  armAndWait: function () {\n    function armAndWait() {\n      var self = this;\n      var future = new Future();\n      self.onAllCommitted(function () {\n        future['return']();\n      });\n      self.arm();\n      future.wait();\n    }\n\n    return armAndWait;\n  }(),\n\n  _maybeFire: function () {\n    function _maybeFire() {\n      var self = this;\n      if (self.fired) throw new Error(\"write fence already activated?\");\n      if (self.armed && !self.outstanding_writes) {\n        var invokeCallback = function () {\n          function invokeCallback(func) {\n            try {\n              func(self);\n            } catch (err) {\n              Meteor._debug(\"exception in write fence callback:\", err);\n            }\n          }\n\n          return invokeCallback;\n        }();\n\n        self.outstanding_writes++;\n        while (self.before_fire_callbacks.length > 0) {\n          var callbacks = self.before_fire_callbacks;\n          self.before_fire_callbacks = [];\n          _.each(callbacks, invokeCallback);\n        }\n        self.outstanding_writes--;\n\n        if (!self.outstanding_writes) {\n          self.fired = true;\n          var callbacks = self.completion_callbacks;\n          self.completion_callbacks = [];\n          _.each(callbacks, invokeCallback);\n        }\n      }\n    }\n\n    return _maybeFire;\n  }(),\n\n  // Deactivate this fence so that adding more writes has no effect.\n  // The fence must have already fired.\n  retire: function () {\n    function retire() {\n      var self = this;\n      if (!self.fired) throw new Error(\"Can't retire a fence that hasn't fired.\");\n      self.retired = true;\n    }\n\n    return retire;\n  }()\n});","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/writefence.js"],"names":["path","Npm","require","Future","join","DDPServer","_WriteFence","self","armed","fired","retired","outstanding_writes","before_fire_callbacks","completion_callbacks","_CurrentWriteFence","Meteor","EnvironmentVariable","_","extend","prototype","beginWrite","committed","Error","_maybeFire","arm","get","onBeforeFire","func","push","onAllCommitted","armAndWait","future","wait","invokeCallback","err","_debug","length","callbacks","each","retire"],"mappings":"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","file":"/packages/ddp-server/writefence.js.map","sourcesContent":["var path = Npm.require('path');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\n// A write fence collects a group of writes, and provides a callback\n// when all of the writes are fully committed and propagated (all\n// observers have been notified of the write and acknowledged it.)\n//\nDDPServer._WriteFence = function () {\n  var self = this;\n\n  self.armed = false;\n  self.fired = false;\n  self.retired = false;\n  self.outstanding_writes = 0;\n  self.before_fire_callbacks = [];\n  self.completion_callbacks = [];\n};\n\n// The current write fence. When there is a current write fence, code\n// that writes to databases should register their writes with it using\n// beginWrite().\n//\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable;\n\n_.extend(DDPServer._WriteFence.prototype, {\n  // Start tracking a write, and return an object to represent it. The\n  // object has a single method, committed(). This method should be\n  // called when the write is fully committed and propagated. You can\n  // continue to add writes to the WriteFence up until it is triggered\n  // (calls its callbacks because all writes have committed.)\n  beginWrite: function () {\n    var self = this;\n\n    if (self.retired)\n      return { committed: function () {} };\n\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to add writes\");\n\n    self.outstanding_writes++;\n    var committed = false;\n    return {\n      committed: function () {\n        if (committed)\n          throw new Error(\"committed called twice on the same write\");\n        committed = true;\n        self.outstanding_writes--;\n        self._maybeFire();\n      }\n    };\n  },\n\n  // Arm the fence. Once the fence is armed, and there are no more\n  // uncommitted writes, it will activate.\n  arm: function () {\n    var self = this;\n    if (self === DDPServer._CurrentWriteFence.get())\n      throw Error(\"Can't arm the current fence\");\n    self.armed = true;\n    self._maybeFire();\n  },\n\n  // Register a function to be called once before firing the fence.\n  // Callback function can add new writes to the fence, in which case\n  // it won't fire until those writes are done as well.\n  onBeforeFire: function (func) {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n                      \"add a callback\");\n    self.before_fire_callbacks.push(func);\n  },\n\n  // Register a function to be called when the fence fires.\n  onAllCommitted: function (func) {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n                      \"add a callback\");\n    self.completion_callbacks.push(func);\n  },\n\n  // Convenience function. Arms the fence, then blocks until it fires.\n  armAndWait: function () {\n    var self = this;\n    var future = new Future;\n    self.onAllCommitted(function () {\n      future['return']();\n    });\n    self.arm();\n    future.wait();\n  },\n\n  _maybeFire: function () {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"write fence already activated?\");\n    if (self.armed && !self.outstanding_writes) {\n      function invokeCallback (func) {\n        try {\n          func(self);\n        } catch (err) {\n          Meteor._debug(\"exception in write fence callback:\", err);\n        }\n      }\n\n      self.outstanding_writes++;\n      while (self.before_fire_callbacks.length > 0) {\n        var callbacks = self.before_fire_callbacks;\n        self.before_fire_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n      self.outstanding_writes--;\n\n      if (!self.outstanding_writes) {\n        self.fired = true;\n        var callbacks = self.completion_callbacks;\n        self.completion_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n    }\n  },\n\n  // Deactivate this fence so that adding more writes has no effect.\n  // The fence must have already fired.\n  retire: function () {\n    var self = this;\n    if (! self.fired)\n      throw new Error(\"Can't retire a fence that hasn't fired.\");\n    self.retired = true;\n  }\n});\n"]},"hash":"0ab905e474d4bf6d19a63d698a65c996d3cd1ce6"}
