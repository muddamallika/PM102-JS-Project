{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/accounts-base/accounts_tests.js","filenameRelative":"/packages/accounts-base/accounts_tests.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/accounts-base/accounts_tests.js.map","sourceFileName":"/packages/accounts-base/accounts_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"accounts_tests"},"ignored":false,"code":"var _typeof;module.import('babel-runtime/helpers/typeof',{\"default\":function(v){_typeof=v}});\nMeteor.methods({\n  getCurrentLoginToken: function () {\n    function getCurrentLoginToken() {\n      return Accounts._getLoginToken(this.connection.id);\n    }\n\n    return getCurrentLoginToken;\n  }()\n});\n\n// XXX it'd be cool to also test that the right thing happens if options\n// *are* validated, but Accounts._options is global state which makes this hard\n// (impossible?)\nTinytest.add('accounts - config validates keys', function (test) {\n  test.throws(function () {\n    Accounts.config({ foo: \"bar\" });\n  });\n});\n\nvar idsInValidateNewUser = {};\nAccounts.validateNewUser(function (user) {\n  idsInValidateNewUser[user._id] = true;\n  return true;\n});\n\nTinytest.add('accounts - validateNewUser gets passed user with _id', function (test) {\n  var newUserId = Accounts.updateOrCreateUserFromExternalService('foobook', { id: Random.id() }).userId;\n  test.isTrue(newUserId in idsInValidateNewUser);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Facebook', function (test) {\n  var facebookId = Random.id();\n\n  // create an account with facebook\n  var uid1 = Accounts.updateOrCreateUserFromExternalService('facebook', { id: facebookId, monkey: 42 }, { profile: { foo: 1 } }).id;\n  var users = Meteor.users.find({ \"services.facebook.id\": facebookId }).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.facebook.monkey, 42);\n\n  // create again with the same id, see that we get the same user.\n  // it should update services.facebook but not profile.\n  var uid2 = Accounts.updateOrCreateUserFromExternalService('facebook', { id: facebookId, llama: 50 }, { profile: { foo: 1000, bar: 2 } }).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({ \"services.facebook.id\": facebookId }).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].profile.bar, undefined);\n  test.equal(users[0].services.facebook.llama, 50);\n  // make sure we *don't* lose values not passed this call to\n  // updateOrCreateUserFromExternalService\n  test.equal(users[0].services.facebook.monkey, 42);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Weibo', function (test) {\n  var weiboId1 = Random.id();\n  var weiboId2 = Random.id();\n\n  // users that have different service ids get different users\n  var uid1 = Accounts.updateOrCreateUserFromExternalService('weibo', { id: weiboId1 }, { profile: { foo: 1 } }).id;\n  var uid2 = Accounts.updateOrCreateUserFromExternalService('weibo', { id: weiboId2 }, { profile: { bar: 2 } }).id;\n  test.equal(Meteor.users.find({ \"services.weibo.id\": { $in: [weiboId1, weiboId2] } }).count(), 2);\n  test.equal(Meteor.users.findOne({ \"services.weibo.id\": weiboId1 }).profile.foo, 1);\n  test.equal(Meteor.users.findOne({ \"services.weibo.id\": weiboId1 }).emails, undefined);\n  test.equal(Meteor.users.findOne({ \"services.weibo.id\": weiboId2 }).profile.bar, 2);\n  test.equal(Meteor.users.findOne({ \"services.weibo.id\": weiboId2 }).emails, undefined);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n  Meteor.users.remove(uid2);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Twitter', function (test) {\n  var twitterIdOld = parseInt(Random.hexString(4), 16);\n  var twitterIdNew = '' + twitterIdOld;\n\n  // create an account with twitter using the old ID format of integer\n  var uid1 = Accounts.updateOrCreateUserFromExternalService('twitter', { id: twitterIdOld, monkey: 42 }, { profile: { foo: 1 } }).id;\n  var users = Meteor.users.find({ \"services.twitter.id\": twitterIdOld }).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.twitter.monkey, 42);\n\n  // Update the account with the new ID format of string\n  // test that the existing user is found, and that the ID\n  // gets updated to a string value\n  var uid2 = Accounts.updateOrCreateUserFromExternalService('twitter', { id: twitterIdNew, monkey: 42 }, { profile: { foo: 1 } }).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({ \"services.twitter.id\": twitterIdNew }).fetch();\n  test.length(users, 1);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n});\n\nTinytest.add('accounts - insertUserDoc username', function (test) {\n  var userIn = {\n    username: Random.id()\n  };\n\n  // user does not already exist. create a user object with fields set.\n  var userId = Accounts.insertUserDoc({ profile: { name: 'Foo Bar' } }, userIn);\n  var userOut = Meteor.users.findOne(userId);\n\n  test.equal(_typeof(userOut.createdAt), 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.username, userIn.username);\n\n  // run the hook again. now the user exists, so it throws an error.\n  test.throws(function () {\n    Accounts.insertUserDoc({ profile: { name: 'Foo Bar' } }, userIn);\n  }, 'Username already exists.');\n\n  // cleanup\n  Meteor.users.remove(userId);\n});\n\nTinytest.add('accounts - insertUserDoc email', function (test) {\n  var email1 = Random.id();\n  var email2 = Random.id();\n  var email3 = Random.id();\n  var userIn = {\n    emails: [{ address: email1, verified: false }, { address: email2, verified: true }]\n  };\n\n  // user does not already exist. create a user object with fields set.\n  var userId = Accounts.insertUserDoc({ profile: { name: 'Foo Bar' } }, userIn);\n  var userOut = Meteor.users.findOne(userId);\n\n  test.equal(_typeof(userOut.createdAt), 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.emails, userIn.emails);\n\n  // run the hook again with the exact same emails.\n  // run the hook again. now the user exists, so it throws an error.\n  test.throws(function () {\n    Accounts.insertUserDoc({ profile: { name: 'Foo Bar' } }, userIn);\n  }, 'Email already exists.');\n\n  // now with only one of them.\n  test.throws(function () {\n    Accounts.insertUserDoc({}, { emails: [{ address: email1 }] });\n  }, 'Email already exists.');\n\n  test.throws(function () {\n    Accounts.insertUserDoc({}, { emails: [{ address: email2 }] });\n  }, 'Email already exists.');\n\n  // a third email works.\n  var userId3 = Accounts.insertUserDoc({}, { emails: [{ address: email3 }] });\n  var user3 = Meteor.users.findOne(userId3);\n  test.equal(_typeof(user3.createdAt), 'object');\n\n  // cleanup\n  Meteor.users.remove(userId);\n  Meteor.users.remove(userId3);\n});\n\n// More token expiration tests are in accounts-password\nTinytest.addAsync('accounts - expire numeric token', function (test, onComplete) {\n  var userIn = { username: Random.id() };\n  var userId = Accounts.insertUserDoc({ profile: {\n      name: 'Foo Bar'\n    } }, userIn);\n  var date = new Date(new Date() - 5000);\n  Meteor.users.update(userId, {\n    $set: {\n      \"services.resume.loginTokens\": [{\n        hashedToken: Random.id(),\n        when: date\n      }, {\n        hashedToken: Random.id(),\n        when: +date\n      }]\n    }\n  });\n  var observe = Meteor.users.find(userId).observe({\n    changed: function () {\n      function changed(newUser) {\n        if (newUser.services && newUser.services.resume && _.isEmpty(newUser.services.resume.loginTokens)) {\n          observe.stop();\n          onComplete();\n        }\n      }\n\n      return changed;\n    }()\n  });\n  Accounts._expireTokens(new Date(), userId);\n});\n\n// Login tokens used to be stored unhashed in the database.  We want\n// to make sure users can still login after upgrading.\nvar insertUnhashedLoginToken = function insertUnhashedLoginToken(userId, stampedToken) {\n  Meteor.users.update(userId, { $push: { 'services.resume.loginTokens': stampedToken } });\n};\n\nTinytest.addAsync('accounts - login token', function (test, onComplete) {\n  // Test that we can login when the database contains a leftover\n  // old style unhashed login token.\n  var userId1 = Accounts.insertUserDoc({}, { username: Random.id() });\n  var stampedToken = Accounts._generateStampedLoginToken();\n  insertUnhashedLoginToken(userId1, stampedToken);\n  var connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', { resume: stampedToken.token });\n  connection.disconnect();\n\n  // Steal the unhashed token from the database and use it to login.\n  // This is a sanity check so that when we *can't* login with a\n  // stolen *hashed* token, we know it's not a problem with the test.\n  var userId2 = Accounts.insertUserDoc({}, { username: Random.id() });\n  insertUnhashedLoginToken(userId2, Accounts._generateStampedLoginToken());\n  var stolenToken = Meteor.users.findOne(userId2).services.resume.loginTokens[0].token;\n  test.isTrue(stolenToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', { resume: stolenToken });\n  connection.disconnect();\n\n  // Now do the same thing, this time with a stolen hashed token.\n  var userId3 = Accounts.insertUserDoc({}, { username: Random.id() });\n  Accounts._insertLoginToken(userId3, Accounts._generateStampedLoginToken());\n  stolenToken = Meteor.users.findOne(userId3).services.resume.loginTokens[0].hashedToken;\n  test.isTrue(stolenToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  // evil plan foiled\n  test.throws(function () {\n    connection.call('login', { resume: stolenToken });\n  }, /You\\'ve been logged out by the server/);\n  connection.disconnect();\n\n  // Old style unhashed tokens are replaced by hashed tokens when\n  // encountered.  This means that after someone logins once, the\n  // old unhashed token is no longer available to be stolen.\n  var userId4 = Accounts.insertUserDoc({}, { username: Random.id() });\n  var stampedToken = Accounts._generateStampedLoginToken();\n  insertUnhashedLoginToken(userId4, stampedToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', { resume: stampedToken.token });\n  connection.disconnect();\n\n  // The token is no longer available to be stolen.\n  stolenToken = Meteor.users.findOne(userId4).services.resume.loginTokens[0].token;\n  test.isFalse(stolenToken);\n\n  // After the upgrade, the client can still login with their original\n  // unhashed login token.\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', { resume: stampedToken.token });\n  connection.disconnect();\n\n  onComplete();\n});\n\nTinytest.addAsync('accounts - connection data cleaned up', function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // onClose callbacks are called in order, so we run after the\n    // close callback in accounts.\n    serverConn.onClose(function () {\n      test.isFalse(Accounts._getAccountData(serverConn.id, 'connection'));\n      onComplete();\n    });\n\n    test.isTrue(Accounts._getAccountData(serverConn.id, 'connection'));\n    serverConn.close();\n  }, onComplete);\n});\n\nTinytest.add('accounts - get new token', function (test) {\n  // Test that the `getNewToken` method returns us a valid token, with\n  // the same expiration as our original token.\n  var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n  var stampedToken = Accounts._generateStampedLoginToken();\n  Accounts._insertLoginToken(userId, stampedToken);\n  var conn = DDP.connect(Meteor.absoluteUrl());\n  conn.call('login', { resume: stampedToken.token });\n  test.equal(conn.call('getCurrentLoginToken'), Accounts._hashLoginToken(stampedToken.token));\n\n  var newTokenResult = conn.call('getNewToken');\n  test.equal(newTokenResult.tokenExpires, Accounts._tokenExpiration(stampedToken.when));\n  test.equal(conn.call('getCurrentLoginToken'), Accounts._hashLoginToken(newTokenResult.token));\n  conn.disconnect();\n\n  // A second connection should be able to log in with the new token\n  // we got.\n  var secondConn = DDP.connect(Meteor.absoluteUrl());\n  secondConn.call('login', { resume: newTokenResult.token });\n  secondConn.disconnect();\n});\n\nTinytest.addAsync('accounts - remove other tokens', function (test, onComplete) {\n  // Test that the `removeOtherTokens` method removes all tokens other\n  // than the caller's token, thereby logging out and closing other\n  // connections.\n  var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n  var stampedTokens = [];\n  var conns = [];\n\n  _.times(2, function (i) {\n    stampedTokens.push(Accounts._generateStampedLoginToken());\n    Accounts._insertLoginToken(userId, stampedTokens[i]);\n    var conn = DDP.connect(Meteor.absoluteUrl());\n    conn.call('login', { resume: stampedTokens[i].token });\n    test.equal(conn.call('getCurrentLoginToken'), Accounts._hashLoginToken(stampedTokens[i].token));\n    conns.push(conn);\n  });\n\n  conns[0].call('removeOtherTokens');\n  simplePoll(function () {\n    var tokens = _.map(conns, function (conn) {\n      return conn.call('getCurrentLoginToken');\n    });\n    return !tokens[1] && tokens[0] === Accounts._hashLoginToken(stampedTokens[0].token);\n  }, function () {\n    // success\n    _.each(conns, function (conn) {\n      conn.disconnect();\n    });\n    onComplete();\n  }, function () {\n    // timed out\n    throw new Error(\"accounts - remove other tokens timed out\");\n  });\n});\n\nTinytest.add('accounts - hook callbacks can access Meteor.userId()', function (test) {\n  var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n  var stampedToken = Accounts._generateStampedLoginToken();\n  Accounts._insertLoginToken(userId, stampedToken);\n\n  var validateStopper = Accounts.validateLoginAttempt(function (attempt) {\n    test.equal(Meteor.userId(), validateAttemptExpectedUserId, \"validateLoginAttempt\");\n    return true;\n  });\n  var onLoginStopper = Accounts.onLogin(function (attempt) {\n    test.equal(Meteor.userId(), onLoginExpectedUserId, \"onLogin\");\n  });\n  var onLogoutStopper = Accounts.onLogout(function (logoutContext) {\n    test.equal(logoutContext.user._id, onLogoutExpectedUserId, \"onLogout\");\n    test.instanceOf(logoutContext.connection, Object);\n  });\n  var onLoginFailureStopper = Accounts.onLoginFailure(function (attempt) {\n    test.equal(Meteor.userId(), onLoginFailureExpectedUserId, \"onLoginFailure\");\n  });\n\n  var conn = DDP.connect(Meteor.absoluteUrl());\n\n  // On a new connection, Meteor.userId() should be null until logged in.\n  var validateAttemptExpectedUserId = null;\n  var onLoginExpectedUserId = userId;\n  conn.call('login', { resume: stampedToken.token });\n\n  // Now that the user is logged in on the connection, Meteor.userId() should\n  // return that user.\n  validateAttemptExpectedUserId = userId;\n  conn.call('login', { resume: stampedToken.token });\n\n  // Trigger onLoginFailure callbacks\n  var onLoginFailureExpectedUserId = userId;\n  test.throws(function () {\n    conn.call('login', { resume: \"bogus\" });\n  }, '403');\n\n  // Trigger onLogout callbacks\n  var onLogoutExpectedUserId = userId;\n  conn.call('logout');\n\n  conn.disconnect();\n  validateStopper.stop();\n  onLoginStopper.stop();\n  onLogoutStopper.stop();\n  onLoginFailureStopper.stop();\n});","ast":null,"map":{"version":3,"sources":["/packages/accounts-base/accounts_tests.js"],"names":["Meteor","methods","getCurrentLoginToken","Accounts","_getLoginToken","connection","id","Tinytest","add","test","throws","config","foo","idsInValidateNewUser","validateNewUser","user","_id","newUserId","updateOrCreateUserFromExternalService","Random","userId","isTrue","facebookId","uid1","monkey","profile","users","find","fetch","length","equal","services","facebook","uid2","llama","bar","undefined","remove","weiboId1","weiboId2","$in","count","findOne","emails","twitterIdOld","parseInt","hexString","twitterIdNew","twitter","userIn","username","insertUserDoc","name","userOut","createdAt","email1","email2","email3","address","verified","userId3","user3","addAsync","onComplete","date","Date","update","$set","hashedToken","when","observe","changed","newUser","resume","_","isEmpty","loginTokens","stop","_expireTokens","insertUnhashedLoginToken","stampedToken","$push","userId1","_generateStampedLoginToken","DDP","connect","absoluteUrl","call","token","disconnect","userId2","stolenToken","_insertLoginToken","userId4","isFalse","makeTestConnection","clientConn","serverConn","onClose","_getAccountData","close","conn","_hashLoginToken","newTokenResult","tokenExpires","_tokenExpiration","secondConn","stampedTokens","conns","times","i","push","simplePoll","tokens","map","each","Error","validateStopper","validateLoginAttempt","attempt","validateAttemptExpectedUserId","onLoginStopper","onLogin","onLoginExpectedUserId","onLogoutStopper","onLogout","logoutContext","onLogoutExpectedUserId","instanceOf","Object","onLoginFailureStopper","onLoginFailure","onLoginFailureExpectedUserId"],"mappings":"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","file":"/packages/accounts-base/accounts_tests.js.map","sourcesContent":["Meteor.methods({\n  getCurrentLoginToken: function () {\n    return Accounts._getLoginToken(this.connection.id);\n  }\n});\n\n// XXX it'd be cool to also test that the right thing happens if options\n// *are* validated, but Accounts._options is global state which makes this hard\n// (impossible?)\nTinytest.add('accounts - config validates keys', function (test) {\n  test.throws(function () {\n    Accounts.config({foo: \"bar\"});\n  });\n});\n\n\nvar idsInValidateNewUser = {};\nAccounts.validateNewUser(function (user) {\n  idsInValidateNewUser[user._id] = true;\n  return true;\n});\n\nTinytest.add('accounts - validateNewUser gets passed user with _id', function (test) {\n  var newUserId = Accounts.updateOrCreateUserFromExternalService('foobook', {id: Random.id()}).userId;\n  test.isTrue(newUserId in idsInValidateNewUser);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Facebook', function (test) {\n  var facebookId = Random.id();\n\n  // create an account with facebook\n  var uid1 = Accounts.updateOrCreateUserFromExternalService(\n    'facebook', {id: facebookId, monkey: 42}, {profile: {foo: 1}}).id;\n  var users = Meteor.users.find({\"services.facebook.id\": facebookId}).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.facebook.monkey, 42);\n\n  // create again with the same id, see that we get the same user.\n  // it should update services.facebook but not profile.\n  var uid2 = Accounts.updateOrCreateUserFromExternalService(\n    'facebook', {id: facebookId, llama: 50},\n    {profile: {foo: 1000, bar: 2}}).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({\"services.facebook.id\": facebookId}).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].profile.bar, undefined);\n  test.equal(users[0].services.facebook.llama, 50);\n  // make sure we *don't* lose values not passed this call to\n  // updateOrCreateUserFromExternalService\n  test.equal(users[0].services.facebook.monkey, 42);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Weibo', function (test) {\n  var weiboId1 = Random.id();\n  var weiboId2 = Random.id();\n\n  // users that have different service ids get different users\n  var uid1 = Accounts.updateOrCreateUserFromExternalService(\n    'weibo', {id: weiboId1}, {profile: {foo: 1}}).id;\n  var uid2 = Accounts.updateOrCreateUserFromExternalService(\n    'weibo', {id: weiboId2}, {profile: {bar: 2}}).id;\n  test.equal(Meteor.users.find({\"services.weibo.id\": {$in: [weiboId1, weiboId2]}}).count(), 2);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId1}).profile.foo, 1);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId1}).emails, undefined);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId2}).profile.bar, 2);\n  test.equal(Meteor.users.findOne({\"services.weibo.id\": weiboId2}).emails, undefined);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n  Meteor.users.remove(uid2);\n});\n\nTinytest.add('accounts - updateOrCreateUserFromExternalService - Twitter', function (test) {\n  var twitterIdOld = parseInt(Random.hexString(4), 16);\n  var twitterIdNew = ''+twitterIdOld;\n\n  // create an account with twitter using the old ID format of integer\n  var uid1 = Accounts.updateOrCreateUserFromExternalService(\n    'twitter', {id: twitterIdOld, monkey: 42}, {profile: {foo: 1}}).id;\n  var users = Meteor.users.find({\"services.twitter.id\": twitterIdOld}).fetch();\n  test.length(users, 1);\n  test.equal(users[0].profile.foo, 1);\n  test.equal(users[0].services.twitter.monkey, 42);\n\n  // Update the account with the new ID format of string\n  // test that the existing user is found, and that the ID\n  // gets updated to a string value\n  var uid2 = Accounts.updateOrCreateUserFromExternalService(\n    'twitter', {id: twitterIdNew, monkey: 42}, {profile: {foo: 1}}).id;\n  test.equal(uid1, uid2);\n  users = Meteor.users.find({\"services.twitter.id\": twitterIdNew}).fetch();\n  test.length(users, 1);\n\n  // cleanup\n  Meteor.users.remove(uid1);\n});\n\n\nTinytest.add('accounts - insertUserDoc username', function (test) {\n  var userIn = {\n    username: Random.id()\n  };\n\n  // user does not already exist. create a user object with fields set.\n  var userId = Accounts.insertUserDoc(\n    {profile: {name: 'Foo Bar'}},\n    userIn\n  );\n  var userOut = Meteor.users.findOne(userId);\n\n  test.equal(typeof userOut.createdAt, 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.username, userIn.username);\n\n  // run the hook again. now the user exists, so it throws an error.\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {profile: {name: 'Foo Bar'}},\n      userIn\n    );\n  }, 'Username already exists.');\n\n  // cleanup\n  Meteor.users.remove(userId);\n});\n\nTinytest.add('accounts - insertUserDoc email', function (test) {\n  var email1 = Random.id();\n  var email2 = Random.id();\n  var email3 = Random.id();\n  var userIn = {\n    emails: [{address: email1, verified: false},\n             {address: email2, verified: true}]\n  };\n\n  // user does not already exist. create a user object with fields set.\n  var userId = Accounts.insertUserDoc(\n    {profile: {name: 'Foo Bar'}},\n    userIn\n  );\n  var userOut = Meteor.users.findOne(userId);\n\n  test.equal(typeof userOut.createdAt, 'object');\n  test.equal(userOut.profile.name, 'Foo Bar');\n  test.equal(userOut.emails, userIn.emails);\n\n  // run the hook again with the exact same emails.\n  // run the hook again. now the user exists, so it throws an error.\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {profile: {name: 'Foo Bar'}},\n      userIn\n    );\n  }, 'Email already exists.');\n\n  // now with only one of them.\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {}, {emails: [{address: email1}]}\n    );\n  }, 'Email already exists.');\n\n  test.throws(function () {\n    Accounts.insertUserDoc(\n      {}, {emails: [{address: email2}]}\n    );\n  }, 'Email already exists.');\n\n\n  // a third email works.\n  var userId3 = Accounts.insertUserDoc(\n      {}, {emails: [{address: email3}]}\n  );\n  var user3 = Meteor.users.findOne(userId3);\n  test.equal(typeof user3.createdAt, 'object');\n\n  // cleanup\n  Meteor.users.remove(userId);\n  Meteor.users.remove(userId3);\n});\n\n// More token expiration tests are in accounts-password\nTinytest.addAsync('accounts - expire numeric token', function (test, onComplete) {\n  var userIn = { username: Random.id() };\n  var userId = Accounts.insertUserDoc({ profile: {\n    name: 'Foo Bar'\n  } }, userIn);\n  var date = new Date(new Date() - 5000);\n  Meteor.users.update(userId, {\n    $set: {\n      \"services.resume.loginTokens\": [{\n        hashedToken: Random.id(),\n        when: date\n      }, {\n        hashedToken: Random.id(),\n        when: +date\n      }]\n    }\n  });\n  var observe = Meteor.users.find(userId).observe({\n    changed: function (newUser) {\n      if (newUser.services && newUser.services.resume &&\n          _.isEmpty(newUser.services.resume.loginTokens)) {\n        observe.stop();\n        onComplete();\n      }\n    }\n  });\n  Accounts._expireTokens(new Date(), userId);\n});\n\n\n// Login tokens used to be stored unhashed in the database.  We want\n// to make sure users can still login after upgrading.\nvar insertUnhashedLoginToken = function (userId, stampedToken) {\n  Meteor.users.update(\n    userId,\n    {$push: {'services.resume.loginTokens': stampedToken}}\n  );\n};\n\nTinytest.addAsync('accounts - login token', function (test, onComplete) {\n  // Test that we can login when the database contains a leftover\n  // old style unhashed login token.\n  var userId1 = Accounts.insertUserDoc({}, {username: Random.id()});\n  var stampedToken = Accounts._generateStampedLoginToken();\n  insertUnhashedLoginToken(userId1, stampedToken);\n  var connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {resume: stampedToken.token});\n  connection.disconnect();\n\n  // Steal the unhashed token from the database and use it to login.\n  // This is a sanity check so that when we *can't* login with a\n  // stolen *hashed* token, we know it's not a problem with the test.\n  var userId2 = Accounts.insertUserDoc({}, {username: Random.id()});\n  insertUnhashedLoginToken(userId2, Accounts._generateStampedLoginToken());\n  var stolenToken = Meteor.users.findOne(userId2).services.resume.loginTokens[0].token;\n  test.isTrue(stolenToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {resume: stolenToken});\n  connection.disconnect();\n\n  // Now do the same thing, this time with a stolen hashed token.\n  var userId3 = Accounts.insertUserDoc({}, {username: Random.id()});\n  Accounts._insertLoginToken(userId3, Accounts._generateStampedLoginToken());\n  stolenToken = Meteor.users.findOne(userId3).services.resume.loginTokens[0].hashedToken;\n  test.isTrue(stolenToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  // evil plan foiled\n  test.throws(\n    function () {\n      connection.call('login', {resume: stolenToken});\n    },\n    /You\\'ve been logged out by the server/\n  );\n  connection.disconnect();\n\n  // Old style unhashed tokens are replaced by hashed tokens when\n  // encountered.  This means that after someone logins once, the\n  // old unhashed token is no longer available to be stolen.\n  var userId4 = Accounts.insertUserDoc({}, {username: Random.id()});\n  var stampedToken = Accounts._generateStampedLoginToken();\n  insertUnhashedLoginToken(userId4, stampedToken);\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {resume: stampedToken.token});\n  connection.disconnect();\n\n  // The token is no longer available to be stolen.\n  stolenToken = Meteor.users.findOne(userId4).services.resume.loginTokens[0].token;\n  test.isFalse(stolenToken);\n\n  // After the upgrade, the client can still login with their original\n  // unhashed login token.\n  connection = DDP.connect(Meteor.absoluteUrl());\n  connection.call('login', {resume: stampedToken.token});\n  connection.disconnect();\n\n  onComplete();\n});\n\nTinytest.addAsync(\n  'accounts - connection data cleaned up',\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // onClose callbacks are called in order, so we run after the\n        // close callback in accounts.\n        serverConn.onClose(function () {\n          test.isFalse(Accounts._getAccountData(serverConn.id, 'connection'));\n          onComplete();\n        });\n\n        test.isTrue(Accounts._getAccountData(serverConn.id, 'connection'));\n        serverConn.close();\n      },\n      onComplete\n    );\n  }\n);\n\nTinytest.add(\n  'accounts - get new token',\n  function (test) {\n    // Test that the `getNewToken` method returns us a valid token, with\n    // the same expiration as our original token.\n    var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n    var stampedToken = Accounts._generateStampedLoginToken();\n    Accounts._insertLoginToken(userId, stampedToken);\n    var conn = DDP.connect(Meteor.absoluteUrl());\n    conn.call('login', { resume: stampedToken.token });\n    test.equal(conn.call('getCurrentLoginToken'),\n               Accounts._hashLoginToken(stampedToken.token));\n\n    var newTokenResult = conn.call('getNewToken');\n    test.equal(newTokenResult.tokenExpires,\n               Accounts._tokenExpiration(stampedToken.when));\n    test.equal(conn.call('getCurrentLoginToken'),\n               Accounts._hashLoginToken(newTokenResult.token));\n    conn.disconnect();\n\n    // A second connection should be able to log in with the new token\n    // we got.\n    var secondConn = DDP.connect(Meteor.absoluteUrl());\n    secondConn.call('login', { resume: newTokenResult.token });\n    secondConn.disconnect();\n  }\n);\n\nTinytest.addAsync(\n  'accounts - remove other tokens',\n  function (test, onComplete) {\n    // Test that the `removeOtherTokens` method removes all tokens other\n    // than the caller's token, thereby logging out and closing other\n    // connections.\n    var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n    var stampedTokens = [];\n    var conns = [];\n\n    _.times(2, function (i) {\n      stampedTokens.push(Accounts._generateStampedLoginToken());\n      Accounts._insertLoginToken(userId, stampedTokens[i]);\n      var conn = DDP.connect(Meteor.absoluteUrl());\n      conn.call('login', { resume: stampedTokens[i].token });\n      test.equal(conn.call('getCurrentLoginToken'),\n                 Accounts._hashLoginToken(stampedTokens[i].token));\n      conns.push(conn);\n    });\n\n    conns[0].call('removeOtherTokens');\n    simplePoll(\n      function () {\n        var tokens = _.map(conns, function (conn) {\n          return conn.call('getCurrentLoginToken');\n        });\n        return ! tokens[1] &&\n          tokens[0] === Accounts._hashLoginToken(stampedTokens[0].token);\n      },\n      function () { // success\n        _.each(conns, function (conn) {\n          conn.disconnect();\n        });\n        onComplete();\n      },\n      function () { // timed out\n        throw new Error(\"accounts - remove other tokens timed out\");\n      }\n    );\n  }\n);\n\nTinytest.add(\n  'accounts - hook callbacks can access Meteor.userId()',\n  function (test) {\n    var userId = Accounts.insertUserDoc({}, { username: Random.id() });\n    var stampedToken = Accounts._generateStampedLoginToken();\n    Accounts._insertLoginToken(userId, stampedToken);\n\n    var validateStopper = Accounts.validateLoginAttempt(function(attempt) {\n      test.equal(Meteor.userId(), validateAttemptExpectedUserId, \"validateLoginAttempt\");\n      return true;\n    });\n    var onLoginStopper = Accounts.onLogin(function(attempt) {\n      test.equal(Meteor.userId(), onLoginExpectedUserId, \"onLogin\");\n    });\n    var onLogoutStopper = Accounts.onLogout(function(logoutContext) {\n      test.equal(logoutContext.user._id, onLogoutExpectedUserId, \"onLogout\");\n      test.instanceOf(logoutContext.connection, Object);\n    });\n    var onLoginFailureStopper = Accounts.onLoginFailure(function(attempt) {\n      test.equal(Meteor.userId(), onLoginFailureExpectedUserId, \"onLoginFailure\");\n    });\n\n    var conn = DDP.connect(Meteor.absoluteUrl());\n\n    // On a new connection, Meteor.userId() should be null until logged in.\n    var validateAttemptExpectedUserId = null;\n    var onLoginExpectedUserId = userId;\n    conn.call('login', { resume: stampedToken.token });\n\n    // Now that the user is logged in on the connection, Meteor.userId() should\n    // return that user.\n    validateAttemptExpectedUserId = userId;\n    conn.call('login', { resume: stampedToken.token });\n\n    // Trigger onLoginFailure callbacks\n    var onLoginFailureExpectedUserId = userId;\n    test.throws(function() { conn.call('login', { resume: \"bogus\" }) }, '403');\n\n    // Trigger onLogout callbacks\n    var onLogoutExpectedUserId = userId;\n    conn.call('logout');\n\n    conn.disconnect();\n    validateStopper.stop();\n    onLoginStopper.stop();\n    onLogoutStopper.stop();\n    onLoginFailureStopper.stop();\n  }\n);\n"]},"hash":"b8282fb1cd4b60b9da2df71e246072325e7cded4"}
