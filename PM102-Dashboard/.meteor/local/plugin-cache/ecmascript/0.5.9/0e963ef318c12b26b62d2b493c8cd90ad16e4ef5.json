{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mongo/allow_tests.js","filenameRelative":"/packages/mongo/allow_tests.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mongo/allow_tests.js.map","sourceFileName":"/packages/mongo/allow_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"allow_tests"},"ignored":false,"code":"if (Meteor.isServer) {\n  // Set up allow/deny rules for test collections\n\n  var allowCollections = {};\n\n  // We create the collections in the publisher (instead of using a method or\n  // something) because if we made them with a method, we'd need to follow the\n  // method with some subscribes, and it's possible that the method call would\n  // be delayed by a wait method and the subscribe messages would be sent before\n  // it and fail due to the collection not yet existing. So we are very hacky\n  // and use a publish.\n  Meteor.publish(\"allowTests\", function (nonce, idGeneration) {\n    check(nonce, String);\n    check(idGeneration, String);\n    var cursors = [];\n    var needToConfigure = undefined;\n\n    // helper for defining a collection. we are careful to create just one\n    // Mongo.Collection even if the sub body is rerun, by caching them.\n    var defineCollection = function defineCollection(name, insecure, transform) {\n      var fullName = name + idGeneration + nonce;\n\n      var collection;\n      if (_.has(allowCollections, fullName)) {\n        collection = allowCollections[fullName];\n        if (needToConfigure === true) throw new Error(\"collections inconsistently exist\");\n        needToConfigure = false;\n      } else {\n        collection = new Mongo.Collection(fullName, { idGeneration: idGeneration, transform: transform });\n        allowCollections[fullName] = collection;\n        if (needToConfigure === false) throw new Error(\"collections inconsistently don't exist\");\n        needToConfigure = true;\n        collection._insecure = insecure;\n        var m = {};\n        m[\"clear-collection-\" + fullName] = function () {\n          collection.remove({});\n        };\n        Meteor.methods(m);\n      }\n\n      cursors.push(collection.find());\n      return collection;\n    };\n\n    var insecureCollection = defineCollection(\"collection-insecure\", true /*insecure*/);\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\", false /*insecure*/);\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\"collection-restrictedDefaultSecure\", false /*insecure*/);\n    var restrictedCollectionDefaultInsecure = defineCollection(\"collection-restrictedDefaultInsecure\", true /*insecure*/);\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\"collection-restrictedForUpdateOptionsTest\", true /*insecure*/);\n    var restrictedCollectionForPartialAllowTest = defineCollection(\"collection-restrictedForPartialAllowTest\", true /*insecure*/);\n    var restrictedCollectionForPartialDenyTest = defineCollection(\"collection-restrictedForPartialDenyTest\", true /*insecure*/);\n    var restrictedCollectionForFetchTest = defineCollection(\"collection-restrictedForFetchTest\", true /*insecure*/);\n    var restrictedCollectionForFetchAllTest = defineCollection(\"collection-restrictedForFetchAllTest\", true /*insecure*/);\n    var restrictedCollectionWithTransform = defineCollection(\"withTransform\", false, function (doc) {\n      return doc.a;\n    });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\"collection-restrictedForInvalidTransform\", false /*insecure*/);\n    var restrictedCollectionForClientIdTest = defineCollection(\"collection-restrictedForClientIdTest\", false /*insecure*/);\n\n    if (needToConfigure) {\n      restrictedCollectionWithTransform.allow({\n        insert: function () {\n          function insert(userId, doc) {\n            return doc.foo === \"foo\";\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc) {\n            return doc.foo === \"foo\";\n          }\n\n          return update;\n        }(),\n        remove: function () {\n          function remove(userId, doc) {\n            return doc.bar === \"bar\";\n          }\n\n          return remove;\n        }()\n      });\n      restrictedCollectionWithTransform.allow({\n        // transform: null means that doc here is the top level, not the 'a'\n        // element.\n        transform: null,\n        insert: function () {\n          function insert(userId, doc) {\n            return !!doc.topLevelField;\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc) {\n            return !!doc.topLevelField;\n          }\n\n          return update;\n        }()\n      });\n      restrictedCollectionForInvalidTransformTest.allow({\n        // transform must return an object which is not a mongo id\n        transform: function () {\n          function transform(doc) {\n            return doc._id;\n          }\n\n          return transform;\n        }(),\n        insert: function () {\n          function insert() {\n            return true;\n          }\n\n          return insert;\n        }()\n      });\n      restrictedCollectionForClientIdTest.allow({\n        // This test just requires the collection to trigger the restricted\n        // case.\n        insert: function () {\n          function insert() {\n            return true;\n          }\n\n          return insert;\n        }()\n      });\n\n      // two calls to allow to verify that either validator is sufficient.\n      var allows = [{\n        insert: function () {\n          function insert(userId, doc) {\n            return doc.canInsert;\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc) {\n            return doc.canUpdate;\n          }\n\n          return update;\n        }(),\n        remove: function () {\n          function remove(userId, doc) {\n            return doc.canRemove;\n          }\n\n          return remove;\n        }()\n      }, {\n        insert: function () {\n          function insert(userId, doc) {\n            return doc.canInsert2;\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc, fields, modifier) {\n            return -1 !== _.indexOf(fields, 'canUpdate2');\n          }\n\n          return update;\n        }(),\n        remove: function () {\n          function remove(userId, doc) {\n            return doc.canRemove2;\n          }\n\n          return remove;\n        }()\n      }];\n\n      // two calls to deny to verify that either one blocks the change.\n      var denies = [{\n        insert: function () {\n          function insert(userId, doc) {\n            return doc.cantInsert;\n          }\n\n          return insert;\n        }(),\n        remove: function () {\n          function remove(userId, doc) {\n            return doc.cantRemove;\n          }\n\n          return remove;\n        }()\n      }, {\n        insert: function () {\n          function insert(userId, doc) {\n            // Don't allow explicit ID to be set by the client.\n            return _.has(doc, '_id');\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc, fields, modifier) {\n            return -1 !== _.indexOf(fields, 'verySecret');\n          }\n\n          return update;\n        }()\n      }];\n\n      _.each([restrictedCollectionDefaultSecure, restrictedCollectionDefaultInsecure, restrictedCollectionForUpdateOptionsTest], function (collection) {\n        _.each(allows, function (allow) {\n          collection.allow(allow);\n        });\n        _.each(denies, function (deny) {\n          collection.deny(deny);\n        });\n      });\n\n      // just restrict one operation so that we can verify that others\n      // fail\n      restrictedCollectionForPartialAllowTest.allow({\n        insert: function () {\n          function insert() {}\n\n          return insert;\n        }()\n      });\n      restrictedCollectionForPartialDenyTest.deny({\n        insert: function () {\n          function insert() {}\n\n          return insert;\n        }()\n      });\n\n      // verify that we only fetch the fields specified - we should\n      // be fetching just field1, field2, and field3.\n      restrictedCollectionForFetchTest.allow({\n        insert: function () {\n          function insert() {\n            return true;\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc) {\n            // throw fields in doc so that we can inspect them in test\n            throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n          }\n\n          return update;\n        }(),\n        remove: function () {\n          function remove(userId, doc) {\n            // throw fields in doc so that we can inspect them in test\n            throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n          }\n\n          return remove;\n        }(),\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchTest.allow({\n        fetch: ['field2']\n      });\n      restrictedCollectionForFetchTest.deny({\n        fetch: ['field3']\n      });\n\n      // verify that not passing fetch to one of the calls to allow\n      // causes all fields to be fetched\n      restrictedCollectionForFetchAllTest.allow({\n        insert: function () {\n          function insert() {\n            return true;\n          }\n\n          return insert;\n        }(),\n        update: function () {\n          function update(userId, doc) {\n            // throw fields in doc so that we can inspect them in test\n            throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n          }\n\n          return update;\n        }(),\n        remove: function () {\n          function remove(userId, doc) {\n            // throw fields in doc so that we can inspect them in test\n            throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n          }\n\n          return remove;\n        }(),\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchAllTest.allow({\n        update: function () {\n          function update() {\n            return true;\n          }\n\n          return update;\n        }()\n      });\n    }\n\n    return cursors;\n  });\n}\n\nif (Meteor.isClient) {\n  _.each(['STRING', 'MONGO'], function (idGeneration) {\n    // Set up a bunch of test collections... on the client! They match the ones\n    // created by setUpAllowTestsCollections.\n\n    var nonce = Random.id();\n    // Tell the server to make, configure, and publish a set of collections unique\n    // to our test run. Since the method does not unblock, this will complete\n    // running on the server before anything else happens.\n    Meteor.subscribe('allowTests', nonce, idGeneration);\n\n    // helper for defining a collection, subscribing to it, and defining\n    // a method to clear it\n    var defineCollection = function defineCollection(name, transform) {\n      var fullName = name + idGeneration + nonce;\n      var collection = new Mongo.Collection(fullName, { idGeneration: idGeneration, transform: transform });\n\n      collection.callClearMethod = function (callback) {\n        Meteor.call(\"clear-collection-\" + fullName, callback);\n      };\n      collection.unnoncedName = name + idGeneration;\n      return collection;\n    };\n\n    // totally insecure collection\n    var insecureCollection = defineCollection(\"collection-insecure\");\n\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\");\n\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\"collection-restrictedDefaultSecure\");\n    var restrictedCollectionDefaultInsecure = defineCollection(\"collection-restrictedDefaultInsecure\");\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\"collection-restrictedForUpdateOptionsTest\");\n    var restrictedCollectionForPartialAllowTest = defineCollection(\"collection-restrictedForPartialAllowTest\");\n    var restrictedCollectionForPartialDenyTest = defineCollection(\"collection-restrictedForPartialDenyTest\");\n    var restrictedCollectionForFetchTest = defineCollection(\"collection-restrictedForFetchTest\");\n    var restrictedCollectionForFetchAllTest = defineCollection(\"collection-restrictedForFetchAllTest\");\n    var restrictedCollectionWithTransform = defineCollection(\"withTransform\", function (doc) {\n      return doc.a;\n    });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\"collection-restrictedForInvalidTransform\");\n    var restrictedCollectionForClientIdTest = defineCollection(\"collection-restrictedForClientIdTest\");\n\n    // test that if allow is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial allow, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForPartialAllowTest.update('foo', { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.error, 403);\n      }));\n    }]);\n\n    // test that if deny is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial deny, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForPartialDenyTest.update('foo', { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.error, 403);\n      }));\n    }]);\n\n    // test that we only fetch the fields specified\n    testAsyncMulti(\"collection - fetch, \" + idGeneration, [function (test, expect) {\n      var fetchId = restrictedCollectionForFetchTest.insert({ field1: 1, field2: 1, field3: 1, field4: 1 });\n      var fetchAllId = restrictedCollectionForFetchAllTest.insert({ field1: 1, field2: 1, field3: 1, field4: 1 });\n      restrictedCollectionForFetchTest.update(fetchId, { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3\");\n      }));\n      restrictedCollectionForFetchTest.remove(fetchId, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3\");\n      }));\n\n      restrictedCollectionForFetchAllTest.update(fetchAllId, { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n      }));\n      restrictedCollectionForFetchAllTest.remove(fetchAllId, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n      }));\n    }]);\n\n    (function () {\n      testAsyncMulti(\"collection - restricted factories \" + idGeneration, [function (test, expect) {\n        restrictedCollectionWithTransform.callClearMethod(expect(function () {\n          test.equal(restrictedCollectionWithTransform.find().count(), 0);\n        }));\n      }, function (test, expect) {\n        var self = this;\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"foo\", bar: \"bar\", baz: \"baz\" }\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item1 = res;\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"foo\", bar: \"quux\", baz: \"quux\" },\n          b: \"potato\"\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item2 = res;\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"adsfadf\", bar: \"quux\", baz: \"quux\" },\n          b: \"potato\"\n        }, expect(function (e, res) {\n          test.isTrue(e);\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"bar\" },\n          topLevelField: true\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item3 = res;\n        }));\n      }, function (test, expect) {\n        var self = this;\n        // This should work, because there is an update allow for things with\n        // topLevelField.\n        restrictedCollectionWithTransform.update(self.item3, { $set: { xxx: true } }, expect(function (e, res) {\n          test.isFalse(e);\n          test.equal(1, res);\n        }));\n      }, function (test, expect) {\n        var self = this;\n        test.equal(restrictedCollectionWithTransform.findOne(self.item1), { _id: self.item1, foo: \"foo\", bar: \"bar\", baz: \"baz\" });\n        restrictedCollectionWithTransform.remove(self.item1, expect(function (e, res) {\n          test.isFalse(e);\n        }));\n        restrictedCollectionWithTransform.remove(self.item2, expect(function (e, res) {\n          test.isTrue(e);\n        }));\n      }]);\n    })();\n\n    testAsyncMulti(\"collection - insecure, \" + idGeneration, [function (test, expect) {\n      insecureCollection.callClearMethod(expect(function () {\n        test.equal(insecureCollection.find().count(), 0);\n      }));\n    }, function (test, expect) {\n      var id = insecureCollection.insert({ foo: 'bar' }, expect(function (err, res) {\n        test.equal(res, id);\n        test.equal(insecureCollection.find(id).count(), 1);\n        test.equal(insecureCollection.findOne(id).foo, 'bar');\n      }));\n      test.equal(insecureCollection.find(id).count(), 1);\n      test.equal(insecureCollection.findOne(id).foo, 'bar');\n    }]);\n\n    testAsyncMulti(\"collection - locked down, \" + idGeneration, [function (test, expect) {\n      lockedDownCollection.callClearMethod(expect(function () {\n        test.equal(lockedDownCollection.find().count(), 0);\n      }));\n    }, function (test, expect) {\n      lockedDownCollection.insert({ foo: 'bar' }, expect(function (err, res) {\n        test.equal(err.error, 403);\n        test.equal(lockedDownCollection.find().count(), 0);\n      }));\n    }]);\n\n    (function () {\n      var collection = restrictedCollectionForUpdateOptionsTest;\n      var id1, id2;\n      testAsyncMulti(\"collection - update options, \" + idGeneration, [\n      // init\n      function (test, expect) {\n        collection.callClearMethod(expect(function () {\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // put a few objects\n      function (test, expect) {\n        var doc = { canInsert: true, canUpdate: true };\n        id1 = collection.insert(doc);\n        id2 = collection.insert(doc);\n        collection.insert(doc);\n        collection.insert(doc, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 4);\n        }));\n      },\n      // update by id\n      function (test, expect) {\n        collection.update(id1, { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ updated: true }).count(), 1);\n        }));\n      },\n      // update by id in an object\n      function (test, expect) {\n        collection.update({ _id: id2 }, { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // update with replacement operator not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({ _id: id2 }, { _id: id2, updated: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /In a restricted/);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // upsert not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({ _id: id2 }, { $set: { upserted: true } }, { upsert: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /in a restricted/);\n          test.equal(collection.find({ upserted: true }).count(), 0);\n        }));\n      },\n      // update with rename operator not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({ _id: id2 }, { $rename: { updated: 'asdf' } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /not allowed/);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // update method with a non-ID selector is not allowed\n      function (test, expect) {\n        // We shouldn't even send the method...\n        test.throws(function () {\n          collection.update({ updated: { $exists: false } }, { $set: { updated: true } });\n        });\n        // ... but if we did, the server would reject it too.\n        Meteor.call('/' + collection._name + '/update', { updated: { $exists: false } }, { $set: { updated: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // make sure it doesn't think that {_id: 'foo', something: else} is ok.\n      function (test, expect) {\n        test.throws(function () {\n          collection.update({ _id: id1, updated: { $exists: false } }, { $set: { updated: true } });\n        });\n      },\n      // remove method with a non-ID selector is not allowed\n      function (test, expect) {\n        // We shouldn't even send the method...\n        test.throws(function () {\n          collection.remove({ updated: true });\n        });\n        // ... but if we did, the server would reject it too.\n        Meteor.call('/' + collection._name + '/remove', { updated: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      }]);\n    })();\n\n    _.each([restrictedCollectionDefaultInsecure, restrictedCollectionDefaultSecure], function (collection) {\n      var canUpdateId, canRemoveId;\n\n      testAsyncMulti(\"collection - \" + collection.unnoncedName, [\n      // init\n      function (test, expect) {\n        collection.callClearMethod(expect(function () {\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n\n      // insert with no allows passing. request is denied.\n      function (test, expect) {\n        collection.insert({}, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // insert with one allow and one deny. denied.\n      function (test, expect) {\n        collection.insert({ canInsert: true, cantInsert: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // insert with one allow and other deny. denied.\n      function (test, expect) {\n        collection.insert({ canInsert: true, _id: Random.id() }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // insert one allow passes. allowed.\n      function (test, expect) {\n        collection.insert({ canInsert: true }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 1);\n        }));\n      },\n      // insert other allow passes. allowed.\n      // includes canUpdate for later.\n      function (test, expect) {\n        canUpdateId = collection.insert({ canInsert2: true, canUpdate: true }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 2);\n        }));\n      },\n      // yet a third insert executes. this one has canRemove and\n      // cantRemove set for later.\n      function (test, expect) {\n        canRemoveId = collection.insert({ canInsert: true, canRemove: true, cantRemove: true }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n\n      // can't update with a non-operator mutation\n      function (test, expect) {\n        collection.update(canUpdateId, { newObject: 1 }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n\n      // updating dotted fields works as if we are changing their\n      // top part\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { \"dotted.field\": 1 } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.findOne(canUpdateId).dotted.field, 1);\n        }));\n      }, function (test, expect) {\n        collection.update(canUpdateId, { $set: { \"verySecret.field\": 1 } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find({ verySecret: { $exists: true } }).count(), 0);\n        }));\n      },\n\n      // update doesn't do anything if no docs match\n      function (test, expect) {\n        collection.update(\"doesn't exist\", { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 0);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update fails when access is denied trying to set `verySecret`\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { verySecret: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update fails when trying to set two fields, one of which is\n      // `verySecret`\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { updated: true, verySecret: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update fails when trying to modify docs that don't\n      // have `canUpdate` set\n      function (test, expect) {\n        collection.update(canRemoveId, { $set: { updated: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update executes when it should\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ updated: true }).count(), 1);\n        }));\n      },\n\n      // remove fails when trying to modify a doc with no `canRemove` set\n      function (test, expect) {\n        collection.remove(canUpdateId, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n      // remove fails when trying to modify an doc with `cantRemove`\n      // set\n      function (test, expect) {\n        collection.remove(canRemoveId, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n\n      // update the doc to remove cantRemove.\n      function (test, expect) {\n        collection.update(canRemoveId, { $set: { cantRemove: false, canUpdate2: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ cantRemove: true }).count(), 0);\n        }));\n      },\n\n      // now remove can remove it.\n      function (test, expect) {\n        collection.remove(canRemoveId, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          // successfully removed\n          test.equal(collection.find().count(), 2);\n        }));\n      },\n\n      // try to remove a doc that doesn't exist. see we remove no docs.\n      function (test, expect) {\n        collection.remove('some-random-id-that-never-matches', expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 0);\n          // nothing removed\n          test.equal(collection.find().count(), 2);\n        }));\n      },\n\n      // methods can still bypass restrictions\n      function (test, expect) {\n        collection.callClearMethod(expect(function (err, res) {\n          test.isFalse(err);\n          // successfully removed\n          test.equal(collection.find().count(), 0);\n        }));\n      }]);\n    });\n    testAsyncMulti(\"collection - allow/deny transform must return object, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForInvalidTransformTest.insert({}, expect(function (err, res) {\n        test.isTrue(err);\n      }));\n    }]);\n    testAsyncMulti(\"collection - restricted collection allows client-side id, \" + idGeneration, [function (test, expect) {\n      var self = this;\n      self.id = Random.id();\n      restrictedCollectionForClientIdTest.insert({ _id: self.id }, expect(function (err, res) {\n        test.isFalse(err);\n        test.equal(res, self.id);\n        test.equal(restrictedCollectionForClientIdTest.findOne(self.id), { _id: self.id });\n      }));\n    }]);\n  }); // end idGeneration loop\n} // end if isClient\n\n\n// A few simple server-only tests which don't need to coordinate collections\n// with the client..\nif (Meteor.isServer) {\n  Tinytest.add(\"collection - allow and deny validate options\", function (test) {\n    var collection = new Mongo.Collection(null);\n\n    test.throws(function () {\n      collection.allow({ invalidOption: true });\n    });\n    test.throws(function () {\n      collection.deny({ invalidOption: true });\n    });\n\n    _.each(['insert', 'update', 'remove', 'fetch'], function (key) {\n      var options = {};\n      options[key] = true;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = false;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = undefined;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = ['an array']; // this should be a function, not an array\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    test.throws(function () {\n      collection.allow({ fetch: function () {\n          function fetch() {}\n\n          return fetch;\n        }() }); // this should be an array\n    });\n  });\n\n  Tinytest.add(\"collection - calling allow restricts\", function (test) {\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._restricted, false);\n    collection.allow({\n      insert: function () {\n        function insert() {}\n\n        return insert;\n      }()\n    });\n    test.equal(collection._restricted, true);\n  });\n\n  Tinytest.add(\"collection - global insecure\", function (test) {\n    // note: This test alters the global insecure status, by sneakily hacking\n    // the global Package object!\n    var insecurePackage = Package.insecure;\n\n    Package.insecure = {};\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._isInsecure(), true);\n\n    Package.insecure = undefined;\n    test.equal(collection._isInsecure(), false);\n\n    delete Package.insecure;\n    test.equal(collection._isInsecure(), false);\n\n    collection._insecure = true;\n    test.equal(collection._isInsecure(), true);\n\n    if (insecurePackage) Package.insecure = insecurePackage;else delete Package.insecure;\n  });\n}","ast":null,"map":{"version":3,"sources":["/packages/mongo/allow_tests.js"],"names":["Meteor","isServer","allowCollections","publish","nonce","idGeneration","check","String","cursors","needToConfigure","undefined","defineCollection","name","insecure","transform","fullName","collection","_","has","Error","Mongo","Collection","_insecure","m","remove","methods","push","find","insecureCollection","lockedDownCollection","restrictedCollectionDefaultSecure","restrictedCollectionDefaultInsecure","restrictedCollectionForUpdateOptionsTest","restrictedCollectionForPartialAllowTest","restrictedCollectionForPartialDenyTest","restrictedCollectionForFetchTest","restrictedCollectionForFetchAllTest","restrictedCollectionWithTransform","doc","a","restrictedCollectionForInvalidTransformTest","restrictedCollectionForClientIdTest","allow","insert","userId","foo","update","bar","topLevelField","_id","allows","canInsert","canUpdate","canRemove","canInsert2","fields","modifier","indexOf","canRemove2","denies","cantInsert","cantRemove","each","deny","keys","sort","join","fetch","isClient","Random","id","subscribe","callClearMethod","callback","call","unnoncedName","testAsyncMulti","test","expect","$set","updated","err","res","equal","error","fetchId","field1","field2","field3","field4","fetchAllId","reason","count","self","baz","e","isFalse","isTrue","item1","b","item2","item3","xxx","findOne","id1","id2","matches","upserted","upsert","$rename","throws","$exists","_name","canUpdateId","canRemoveId","newObject","dotted","field","verySecret","canUpdate2","Tinytest","add","invalidOption","key","options","_restricted","insecurePackage","Package","_isInsecure"],"mappings":"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","file":"/packages/mongo/allow_tests.js.map","sourcesContent":["if (Meteor.isServer) {\n  // Set up allow/deny rules for test collections\n\n  var allowCollections = {};\n\n  // We create the collections in the publisher (instead of using a method or\n  // something) because if we made them with a method, we'd need to follow the\n  // method with some subscribes, and it's possible that the method call would\n  // be delayed by a wait method and the subscribe messages would be sent before\n  // it and fail due to the collection not yet existing. So we are very hacky\n  // and use a publish.\n  Meteor.publish(\"allowTests\", function (nonce, idGeneration) {\n    check(nonce, String);\n    check(idGeneration, String);\n    var cursors = [];\n    var needToConfigure = undefined;\n\n    // helper for defining a collection. we are careful to create just one\n    // Mongo.Collection even if the sub body is rerun, by caching them.\n    var defineCollection = function(name, insecure, transform) {\n      var fullName = name + idGeneration + nonce;\n\n      var collection;\n      if (_.has(allowCollections, fullName)) {\n        collection = allowCollections[fullName];\n        if (needToConfigure === true)\n          throw new Error(\"collections inconsistently exist\");\n        needToConfigure = false;\n      } else {\n        collection = new Mongo.Collection(\n          fullName, {idGeneration: idGeneration, transform: transform});\n        allowCollections[fullName] = collection;\n        if (needToConfigure === false)\n          throw new Error(\"collections inconsistently don't exist\");\n        needToConfigure = true;\n        collection._insecure = insecure;\n        var m = {};\n        m[\"clear-collection-\" + fullName] = function() {\n          collection.remove({});\n        };\n        Meteor.methods(m);\n      }\n\n      cursors.push(collection.find());\n      return collection;\n    };\n\n    var insecureCollection = defineCollection(\n      \"collection-insecure\", true /*insecure*/);\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\n      \"collection-locked-down\", false /*insecure*/);\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\n      \"collection-restrictedDefaultSecure\", false /*insecure*/);\n    var restrictedCollectionDefaultInsecure = defineCollection(\n      \"collection-restrictedDefaultInsecure\", true /*insecure*/);\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\n      \"collection-restrictedForUpdateOptionsTest\", true /*insecure*/);\n    var restrictedCollectionForPartialAllowTest = defineCollection(\n      \"collection-restrictedForPartialAllowTest\", true /*insecure*/);\n    var restrictedCollectionForPartialDenyTest = defineCollection(\n      \"collection-restrictedForPartialDenyTest\", true /*insecure*/);\n    var restrictedCollectionForFetchTest = defineCollection(\n      \"collection-restrictedForFetchTest\", true /*insecure*/);\n    var restrictedCollectionForFetchAllTest = defineCollection(\n      \"collection-restrictedForFetchAllTest\", true /*insecure*/);\n    var restrictedCollectionWithTransform = defineCollection(\n      \"withTransform\", false, function (doc) {\n        return doc.a;\n      });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\n      \"collection-restrictedForInvalidTransform\", false /*insecure*/);\n    var restrictedCollectionForClientIdTest = defineCollection(\n      \"collection-restrictedForClientIdTest\", false /*insecure*/);\n\n    if (needToConfigure) {\n      restrictedCollectionWithTransform.allow({\n        insert: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        update: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        remove: function (userId, doc) {\n          return doc.bar === \"bar\";\n        }\n      });\n      restrictedCollectionWithTransform.allow({\n        // transform: null means that doc here is the top level, not the 'a'\n        // element.\n        transform: null,\n        insert: function (userId, doc) {\n          return !!doc.topLevelField;\n        },\n        update: function (userId, doc) {\n          return !!doc.topLevelField;\n        }\n      });\n      restrictedCollectionForInvalidTransformTest.allow({\n        // transform must return an object which is not a mongo id\n        transform: function (doc) { return doc._id; },\n        insert: function () { return true; }\n      });\n      restrictedCollectionForClientIdTest.allow({\n        // This test just requires the collection to trigger the restricted\n        // case.\n        insert: function () { return true; }\n      });\n\n      // two calls to allow to verify that either validator is sufficient.\n      var allows = [{\n        insert: function(userId, doc) {\n          return doc.canInsert;\n        },\n        update: function(userId, doc) {\n          return doc.canUpdate;\n        },\n        remove: function (userId, doc) {\n          return doc.canRemove;\n        }\n      }, {\n        insert: function(userId, doc) {\n          return doc.canInsert2;\n        },\n        update: function(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'canUpdate2');\n        },\n        remove: function(userId, doc) {\n          return doc.canRemove2;\n        }\n      }];\n\n      // two calls to deny to verify that either one blocks the change.\n      var denies = [{\n        insert: function(userId, doc) {\n          return doc.cantInsert;\n        },\n        remove: function (userId, doc) {\n          return doc.cantRemove;\n        }\n      }, {\n        insert: function(userId, doc) {\n          // Don't allow explicit ID to be set by the client.\n          return _.has(doc, '_id');\n        },\n        update: function(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'verySecret');\n        }\n      }];\n\n      _.each([\n        restrictedCollectionDefaultSecure,\n        restrictedCollectionDefaultInsecure,\n        restrictedCollectionForUpdateOptionsTest\n      ], function (collection) {\n        _.each(allows, function (allow) {\n          collection.allow(allow);\n        });\n        _.each(denies, function (deny) {\n          collection.deny(deny);\n        });\n      });\n\n      // just restrict one operation so that we can verify that others\n      // fail\n      restrictedCollectionForPartialAllowTest.allow({\n        insert: function() {}\n      });\n      restrictedCollectionForPartialDenyTest.deny({\n        insert: function() {}\n      });\n\n      // verify that we only fetch the fields specified - we should\n      // be fetching just field1, field2, and field3.\n      restrictedCollectionForFetchTest.allow({\n        insert: function() { return true; },\n        update: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchTest.allow({\n        fetch: ['field2']\n      });\n      restrictedCollectionForFetchTest.deny({\n        fetch: ['field3']\n      });\n\n      // verify that not passing fetch to one of the calls to allow\n      // causes all fields to be fetched\n      restrictedCollectionForFetchAllTest.allow({\n        insert: function() { return true; },\n        update: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchAllTest.allow({\n        update: function() { return true; }\n      });\n    }\n\n    return cursors;\n  });\n}\n\nif (Meteor.isClient) {\n  _.each(['STRING', 'MONGO'], function (idGeneration) {\n    // Set up a bunch of test collections... on the client! They match the ones\n    // created by setUpAllowTestsCollections.\n\n    var nonce = Random.id();\n    // Tell the server to make, configure, and publish a set of collections unique\n    // to our test run. Since the method does not unblock, this will complete\n    // running on the server before anything else happens.\n    Meteor.subscribe('allowTests', nonce, idGeneration);\n\n    // helper for defining a collection, subscribing to it, and defining\n    // a method to clear it\n    var defineCollection = function(name, transform) {\n      var fullName = name + idGeneration + nonce;\n      var collection = new Mongo.Collection(\n        fullName, {idGeneration: idGeneration, transform: transform});\n\n      collection.callClearMethod = function (callback) {\n        Meteor.call(\"clear-collection-\" + fullName, callback);\n      };\n      collection.unnoncedName = name + idGeneration;\n      return collection;\n    };\n\n    // totally insecure collection\n    var insecureCollection = defineCollection(\"collection-insecure\");\n\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\");\n\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\n      \"collection-restrictedDefaultSecure\");\n    var restrictedCollectionDefaultInsecure = defineCollection(\n      \"collection-restrictedDefaultInsecure\");\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\n      \"collection-restrictedForUpdateOptionsTest\");\n    var restrictedCollectionForPartialAllowTest = defineCollection(\n      \"collection-restrictedForPartialAllowTest\");\n    var restrictedCollectionForPartialDenyTest = defineCollection(\n      \"collection-restrictedForPartialDenyTest\");\n    var restrictedCollectionForFetchTest = defineCollection(\n      \"collection-restrictedForFetchTest\");\n    var restrictedCollectionForFetchAllTest = defineCollection(\n      \"collection-restrictedForFetchAllTest\");\n    var restrictedCollectionWithTransform = defineCollection(\n      \"withTransform\", function (doc) {\n        return doc.a;\n      });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\n      \"collection-restrictedForInvalidTransform\");\n    var restrictedCollectionForClientIdTest = defineCollection(\n      \"collection-restrictedForClientIdTest\");\n\n    // test that if allow is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial allow, \" + idGeneration, [\n      function (test, expect) {\n        restrictedCollectionForPartialAllowTest.update(\n          'foo', {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.error, 403);\n          }));\n      }\n    ]);\n\n    // test that if deny is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial deny, \" + idGeneration, [\n      function (test, expect) {\n        restrictedCollectionForPartialDenyTest.update(\n          'foo', {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.error, 403);\n          }));\n      }\n    ]);\n\n\n    // test that we only fetch the fields specified\n    testAsyncMulti(\"collection - fetch, \" + idGeneration, [\n      function (test, expect) {\n        var fetchId = restrictedCollectionForFetchTest.insert(\n          {field1: 1, field2: 1, field3: 1, field4: 1});\n        var fetchAllId = restrictedCollectionForFetchAllTest.insert(\n          {field1: 1, field2: 1, field3: 1, field4: 1});\n        restrictedCollectionForFetchTest.update(\n          fetchId, {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3\");\n          }));\n        restrictedCollectionForFetchTest.remove(\n          fetchId, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3\");\n          }));\n\n        restrictedCollectionForFetchAllTest.update(\n          fetchAllId, {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n          }));\n        restrictedCollectionForFetchAllTest.remove(\n          fetchAllId, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n          }));\n      }\n    ]);\n\n    (function(){\n      testAsyncMulti(\"collection - restricted factories \" + idGeneration, [\n        function (test, expect) {\n          restrictedCollectionWithTransform.callClearMethod(expect(function () {\n            test.equal(restrictedCollectionWithTransform.find().count(), 0);\n          }));\n        },\n        function (test, expect) {\n          var self = this;\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"foo\", bar: \"bar\", baz: \"baz\"}\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item1 = res;\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"foo\", bar: \"quux\", baz: \"quux\"},\n            b: \"potato\"\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item2 = res;\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"adsfadf\", bar: \"quux\", baz: \"quux\"},\n            b: \"potato\"\n          }, expect(function (e, res) {\n            test.isTrue(e);\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"bar\"},\n            topLevelField: true\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item3 = res;\n          }));\n        },\n        function (test, expect) {\n          var self = this;\n          // This should work, because there is an update allow for things with\n          // topLevelField.\n          restrictedCollectionWithTransform.update(\n            self.item3, { $set: { xxx: true } }, expect(function (e, res) {\n              test.isFalse(e);\n              test.equal(1, res);\n            }));\n        },\n        function (test, expect) {\n          var self = this;\n          test.equal(\n            restrictedCollectionWithTransform.findOne(self.item1),\n            {_id: self.item1, foo: \"foo\", bar: \"bar\", baz: \"baz\"});\n          restrictedCollectionWithTransform.remove(\n            self.item1, expect(function (e, res) {\n              test.isFalse(e);\n            }));\n          restrictedCollectionWithTransform.remove(\n            self.item2, expect(function (e, res) {\n              test.isTrue(e);\n            }));\n        }\n      ]);\n    })();\n\n    testAsyncMulti(\"collection - insecure, \" + idGeneration, [\n      function (test, expect) {\n        insecureCollection.callClearMethod(expect(function () {\n          test.equal(insecureCollection.find().count(), 0);\n        }));\n      },\n      function (test, expect) {\n        var id = insecureCollection.insert({foo: 'bar'}, expect(function(err, res) {\n          test.equal(res, id);\n          test.equal(insecureCollection.find(id).count(), 1);\n          test.equal(insecureCollection.findOne(id).foo, 'bar');\n        }));\n        test.equal(insecureCollection.find(id).count(), 1);\n        test.equal(insecureCollection.findOne(id).foo, 'bar');\n      }\n    ]);\n\n    testAsyncMulti(\"collection - locked down, \" + idGeneration, [\n      function (test, expect) {\n        lockedDownCollection.callClearMethod(expect(function() {\n          test.equal(lockedDownCollection.find().count(), 0);\n        }));\n      },\n      function (test, expect) {\n        lockedDownCollection.insert({foo: 'bar'}, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(lockedDownCollection.find().count(), 0);\n        }));\n      }\n    ]);\n\n    (function () {\n      var collection = restrictedCollectionForUpdateOptionsTest;\n      var id1, id2;\n      testAsyncMulti(\"collection - update options, \" + idGeneration, [\n        // init\n        function (test, expect) {\n          collection.callClearMethod(expect(function () {\n            test.equal(collection.find().count(), 0);\n          }));\n        },\n        // put a few objects\n        function (test, expect) {\n          var doc = {canInsert: true, canUpdate: true};\n          id1 = collection.insert(doc);\n          id2 = collection.insert(doc);\n          collection.insert(doc);\n          collection.insert(doc, expect(function (err, res) {\n            test.isFalse(err);\n            test.equal(collection.find().count(), 4);\n          }));\n        },\n        // update by id\n        function (test, expect) {\n          collection.update(\n            id1,\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              test.equal(collection.find({updated: true}).count(), 1);\n            }));\n        },\n        // update by id in an object\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // update with replacement operator not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {_id: id2, updated: true},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /In a restricted/);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // upsert not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$set: { upserted: true }},\n            { upsert: true },\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /in a restricted/);\n              test.equal(collection.find({ upserted: true }).count(), 0);\n            }));\n        },\n        // update with rename operator not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$rename: {updated: 'asdf'}},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /not allowed/);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // update method with a non-ID selector is not allowed\n        function (test, expect) {\n          // We shouldn't even send the method...\n          test.throws(function () {\n            collection.update(\n              {updated: {$exists: false}},\n              {$set: {updated: true}});\n          });\n          // ... but if we did, the server would reject it too.\n          Meteor.call(\n            '/' + collection._name + '/update',\n            {updated: {$exists: false}},\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // make sure it doesn't think that {_id: 'foo', something: else} is ok.\n        function (test, expect) {\n          test.throws(function () {\n            collection.update(\n              {_id: id1, updated: {$exists: false}},\n              {$set: {updated: true}});\n          });\n        },\n        // remove method with a non-ID selector is not allowed\n        function (test, expect) {\n          // We shouldn't even send the method...\n          test.throws(function () {\n            collection.remove({updated: true});\n          });\n          // ... but if we did, the server would reject it too.\n          Meteor.call(\n            '/' + collection._name + '/remove',\n            {updated: true},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        }\n      ]);\n    }) ();\n\n    _.each(\n      [restrictedCollectionDefaultInsecure, restrictedCollectionDefaultSecure],\n      function(collection) {\n        var canUpdateId, canRemoveId;\n\n        testAsyncMulti(\"collection - \" + collection.unnoncedName, [\n          // init\n          function (test, expect) {\n            collection.callClearMethod(expect(function () {\n              test.equal(collection.find().count(), 0);\n            }));\n          },\n\n          // insert with no allows passing. request is denied.\n          function (test, expect) {\n            collection.insert(\n              {},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert with one allow and one deny. denied.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true, cantInsert: true},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert with one allow and other deny. denied.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true, _id: Random.id()},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert one allow passes. allowed.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 1);\n              }));\n          },\n          // insert other allow passes. allowed.\n          // includes canUpdate for later.\n          function (test, expect) {\n            canUpdateId = collection.insert(\n              {canInsert2: true, canUpdate: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 2);\n              }));\n          },\n          // yet a third insert executes. this one has canRemove and\n          // cantRemove set for later.\n          function (test, expect) {\n            canRemoveId = collection.insert(\n              {canInsert: true, canRemove: true, cantRemove: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 3);\n              }));\n          },\n\n          // can't update with a non-operator mutation\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {newObject: 1},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 3);\n              }));\n          },\n\n          // updating dotted fields works as if we are changing their\n          // top part\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {\"dotted.field\": 1}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.findOne(canUpdateId).dotted.field, 1);\n              }));\n          },\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {\"verySecret.field\": 1}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find({verySecret: {$exists: true}}).count(), 0);\n              }));\n          },\n\n          // update doesn't do anything if no docs match\n          function (test, expect) {\n            collection.update(\n              \"doesn't exist\",\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 0);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when access is denied trying to set `verySecret`\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {verySecret: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when trying to set two fields, one of which is\n          // `verySecret`\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {updated: true, verySecret: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when trying to modify docs that don't\n          // have `canUpdate` set\n          function (test, expect) {\n            collection.update(\n              canRemoveId,\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update executes when it should\n          function (test, expect) {\n            collection.update(\n              canUpdateId,\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.find({updated: true}).count(), 1);\n              }));\n          },\n\n          // remove fails when trying to modify a doc with no `canRemove` set\n          function (test, expect) {\n            collection.remove(canUpdateId,\n                              expect(function (err, res) {\n              test.equal(err.error, 403);\n              // nothing has changed\n              test.equal(collection.find().count(), 3);\n            }));\n          },\n          // remove fails when trying to modify an doc with `cantRemove`\n          // set\n          function (test, expect) {\n            collection.remove(canRemoveId,\n                              expect(function (err, res) {\n              test.equal(err.error, 403);\n              // nothing has changed\n              test.equal(collection.find().count(), 3);\n            }));\n          },\n\n          // update the doc to remove cantRemove.\n          function (test, expect) {\n            collection.update(\n              canRemoveId,\n              {$set: {cantRemove: false, canUpdate2: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.find({cantRemove: true}).count(), 0);\n              }));\n          },\n\n          // now remove can remove it.\n          function (test, expect) {\n            collection.remove(canRemoveId,\n                              expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              // successfully removed\n              test.equal(collection.find().count(), 2);\n            }));\n          },\n\n          // try to remove a doc that doesn't exist. see we remove no docs.\n          function (test, expect) {\n            collection.remove('some-random-id-that-never-matches',\n                              expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 0);\n              // nothing removed\n              test.equal(collection.find().count(), 2);\n            }));\n          },\n\n          // methods can still bypass restrictions\n          function (test, expect) {\n            collection.callClearMethod(\n              expect(function (err, res) {\n                test.isFalse(err);\n                // successfully removed\n                test.equal(collection.find().count(), 0);\n            }));\n          }\n        ]);\n      });\n    testAsyncMulti(\n      \"collection - allow/deny transform must return object, \" + idGeneration,\n      [function (test, expect) {\n        restrictedCollectionForInvalidTransformTest.insert({}, expect(function (err, res) {\n          test.isTrue(err);\n        }));\n      }]);\n    testAsyncMulti(\n      \"collection - restricted collection allows client-side id, \" + idGeneration,\n      [function (test, expect) {\n        var self = this;\n        self.id = Random.id();\n        restrictedCollectionForClientIdTest.insert({_id: self.id}, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, self.id);\n          test.equal(restrictedCollectionForClientIdTest.findOne(self.id),\n                     {_id: self.id});\n        }));\n      }]);\n  });  // end idGeneration loop\n}  // end if isClient\n\n\n\n// A few simple server-only tests which don't need to coordinate collections\n// with the client..\nif (Meteor.isServer) {\n  Tinytest.add(\"collection - allow and deny validate options\", function (test) {\n    var collection = new Mongo.Collection(null);\n\n    test.throws(function () {\n      collection.allow({invalidOption: true});\n    });\n    test.throws(function () {\n      collection.deny({invalidOption: true});\n    });\n\n    _.each(['insert', 'update', 'remove', 'fetch'], function (key) {\n      var options = {};\n      options[key] = true;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = false;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = undefined;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = ['an array']; // this should be a function, not an array\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    test.throws(function () {\n      collection.allow({fetch: function () {}}); // this should be an array\n    });\n  });\n\n  Tinytest.add(\"collection - calling allow restricts\", function (test) {\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._restricted, false);\n    collection.allow({\n      insert: function() {}\n    });\n    test.equal(collection._restricted, true);\n  });\n\n  Tinytest.add(\"collection - global insecure\", function (test) {\n    // note: This test alters the global insecure status, by sneakily hacking\n    // the global Package object!\n    var insecurePackage = Package.insecure;\n\n    Package.insecure = {};\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._isInsecure(), true);\n\n    Package.insecure = undefined;\n    test.equal(collection._isInsecure(), false);\n\n    delete Package.insecure;\n    test.equal(collection._isInsecure(), false);\n\n    collection._insecure = true;\n    test.equal(collection._isInsecure(), true);\n\n    if (insecurePackage)\n      Package.insecure = insecurePackage;\n    else\n      delete Package.insecure;\n  });\n}\n"]},"hash":"0e963ef318c12b26b62d2b493c8cd90ad16e4ef5"}
