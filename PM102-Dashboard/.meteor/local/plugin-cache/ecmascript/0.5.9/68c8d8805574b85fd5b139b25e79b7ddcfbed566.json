{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ddp-server/stream_server.js","filenameRelative":"/packages/ddp-server/stream_server.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ddp-server/stream_server.js.map","sourceFileName":"/packages/ddp-server/stream_server.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"stream_server"},"ignored":false,"code":"var url = Npm.require('url');\n\n// By default, we use the permessage-deflate extension with default\n// configuration. If $SERVER_WEBSOCKET_COMPRESSION is set, then it must be valid\n// JSON. If it represents a falsey value, then we do not use permessage-deflate\n// at all; otherwise, the JSON value is used as an argument to deflate's\n// configure method; see\n// https://github.com/faye/permessage-deflate-node/blob/master/README.md\n//\n// (We do this in an _.once instead of at startup, because we don't want to\n// crash the tool during isopacket load if your JSON doesn't parse. This is only\n// a problem because the tool has to load the DDP server code just in order to\n// be a DDP client; see https://github.com/meteor/meteor/issues/3452 .)\nvar websocketExtensions = _.once(function () {\n  var extensions = [];\n\n  var websocketCompressionConfig = process.env.SERVER_WEBSOCKET_COMPRESSION ? JSON.parse(process.env.SERVER_WEBSOCKET_COMPRESSION) : {};\n  if (websocketCompressionConfig) {\n    extensions.push(Npm.require('permessage-deflate').configure(websocketCompressionConfig));\n  }\n\n  return extensions;\n});\n\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || \"\";\n\nStreamServer = function StreamServer() {\n  var self = this;\n  self.registration_callbacks = [];\n  self.open_sockets = [];\n\n  // Because we are installing directly onto WebApp.httpServer instead of using\n  // WebApp.app, we have to process the path prefix ourselves.\n  self.prefix = pathPrefix + '/sockjs';\n  RoutePolicy.declare(self.prefix + '/', 'network');\n\n  // set up sockjs\n  var sockjs = Npm.require('sockjs');\n  var serverOptions = {\n    prefix: self.prefix,\n    log: function () {\n      function log() {}\n\n      return log;\n    }(),\n    // this is the default, but we code it explicitly because we depend\n    // on it in stream_client:HEARTBEAT_TIMEOUT\n    heartbeat_delay: 45000,\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU\n    // bound for that much time, SockJS might not notice that the user has\n    // reconnected because the timer (of disconnect_delay ms) can fire before\n    // SockJS processes the new connection. Eventually we'll fix this by not\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which\n    // converts to Unix sockets) but for now, raise the delay.\n    disconnect_delay: 60 * 1000,\n    // Set the USE_JSESSIONID environment variable to enable setting the\n    // JSESSIONID cookie. This is useful for setting up proxies with\n    // session affinity.\n    jsessionid: !!process.env.USE_JSESSIONID\n  };\n\n  // If you know your server environment (eg, proxies) will prevent websockets\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,\n  // browsers) will not waste time attempting to use them.\n  // (Your server will still have a /websocket endpoint.)\n  if (process.env.DISABLE_WEBSOCKETS) {\n    serverOptions.websocket = false;\n  } else {\n    serverOptions.faye_server_options = {\n      extensions: websocketExtensions()\n    };\n  }\n\n  self.server = sockjs.createServer(serverOptions);\n\n  // Install the sockjs handlers, but we want to keep around our own particular\n  // request handler that adjusts idle timeouts while we have an outstanding\n  // request.  This compensates for the fact that sockjs removes all listeners\n  // for \"request\" to add its own.\n  WebApp.httpServer.removeListener('request', WebApp._timeoutAdjustmentRequestCallback);\n  self.server.installHandlers(WebApp.httpServer);\n  WebApp.httpServer.addListener('request', WebApp._timeoutAdjustmentRequestCallback);\n\n  // Support the /websocket endpoint\n  self._redirectWebsocketEndpoint();\n\n  self.server.on('connection', function (socket) {\n    socket.send = function (data) {\n      socket.write(data);\n    };\n    socket.on('close', function () {\n      self.open_sockets = _.without(self.open_sockets, socket);\n    });\n    self.open_sockets.push(socket);\n\n    // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which\n    // will force old clients to reload. Remove this once we're not\n    // concerned about people upgrading from a pre-0.7.0 release. Also,\n    // remove the clause in the client that ignores the welcome message\n    // (livedata_connection.js)\n    socket.send(JSON.stringify({ server_id: \"0\" }));\n\n    // call all our callbacks when we get a new socket. they will do the\n    // work of setting up handlers and such for specific messages.\n    _.each(self.registration_callbacks, function (callback) {\n      callback(socket);\n    });\n  });\n};\n\n_.extend(StreamServer.prototype, {\n  // call my callback when a new socket connects.\n  // also call it for all current connections.\n  register: function () {\n    function register(callback) {\n      var self = this;\n      self.registration_callbacks.push(callback);\n      _.each(self.all_sockets(), function (socket) {\n        callback(socket);\n      });\n    }\n\n    return register;\n  }(),\n\n  // get a list of all sockets\n  all_sockets: function () {\n    function all_sockets() {\n      var self = this;\n      return _.values(self.open_sockets);\n    }\n\n    return all_sockets;\n  }(),\n\n  // Redirect /websocket to /sockjs/websocket in order to not expose\n  // sockjs to clients that want to use raw websockets\n  _redirectWebsocketEndpoint: function () {\n    function _redirectWebsocketEndpoint() {\n      var self = this;\n      // Unfortunately we can't use a connect middleware here since\n      // sockjs installs itself prior to all existing listeners\n      // (meaning prior to any connect middlewares) so we need to take\n      // an approach similar to overshadowListeners in\n      // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee\n      _.each(['request', 'upgrade'], function (event) {\n        var httpServer = WebApp.httpServer;\n        var oldHttpServerListeners = httpServer.listeners(event).slice(0);\n        httpServer.removeAllListeners(event);\n\n        // request and upgrade have different arguments passed but\n        // we only care about the first one which is always request\n        var newListener = function () {\n          function newListener(request /*, moreArguments */) {\n            // Store arguments for use within the closure below\n            var args = arguments;\n\n            // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while\n            // preserving query string.\n            var parsedUrl = url.parse(request.url);\n            if (parsedUrl.pathname === pathPrefix + '/websocket' || parsedUrl.pathname === pathPrefix + '/websocket/') {\n              parsedUrl.pathname = self.prefix + '/websocket';\n              request.url = url.format(parsedUrl);\n            }\n            _.each(oldHttpServerListeners, function (oldListener) {\n              oldListener.apply(httpServer, args);\n            });\n          }\n\n          return newListener;\n        }();\n        httpServer.addListener(event, newListener);\n      });\n    }\n\n    return _redirectWebsocketEndpoint;\n  }()\n});","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/stream_server.js"],"names":["url","Npm","require","websocketExtensions","_","once","extensions","websocketCompressionConfig","process","env","SERVER_WEBSOCKET_COMPRESSION","JSON","parse","push","configure","pathPrefix","__meteor_runtime_config__","ROOT_URL_PATH_PREFIX","StreamServer","self","registration_callbacks","open_sockets","prefix","RoutePolicy","declare","sockjs","serverOptions","log","heartbeat_delay","disconnect_delay","jsessionid","USE_JSESSIONID","DISABLE_WEBSOCKETS","websocket","faye_server_options","server","createServer","WebApp","httpServer","removeListener","_timeoutAdjustmentRequestCallback","installHandlers","addListener","_redirectWebsocketEndpoint","on","socket","send","data","write","without","stringify","server_id","each","callback","extend","prototype","register","all_sockets","values","event","oldHttpServerListeners","listeners","slice","removeAllListeners","newListener","request","args","arguments","parsedUrl","pathname","format","oldListener","apply"],"mappings":"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","file":"/packages/ddp-server/stream_server.js.map","sourcesContent":["var url = Npm.require('url');\n\n// By default, we use the permessage-deflate extension with default\n// configuration. If $SERVER_WEBSOCKET_COMPRESSION is set, then it must be valid\n// JSON. If it represents a falsey value, then we do not use permessage-deflate\n// at all; otherwise, the JSON value is used as an argument to deflate's\n// configure method; see\n// https://github.com/faye/permessage-deflate-node/blob/master/README.md\n//\n// (We do this in an _.once instead of at startup, because we don't want to\n// crash the tool during isopacket load if your JSON doesn't parse. This is only\n// a problem because the tool has to load the DDP server code just in order to\n// be a DDP client; see https://github.com/meteor/meteor/issues/3452 .)\nvar websocketExtensions = _.once(function () {\n  var extensions = [];\n\n  var websocketCompressionConfig = process.env.SERVER_WEBSOCKET_COMPRESSION\n        ? JSON.parse(process.env.SERVER_WEBSOCKET_COMPRESSION) : {};\n  if (websocketCompressionConfig) {\n    extensions.push(Npm.require('permessage-deflate').configure(\n      websocketCompressionConfig\n    ));\n  }\n\n  return extensions;\n});\n\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX ||  \"\";\n\nStreamServer = function () {\n  var self = this;\n  self.registration_callbacks = [];\n  self.open_sockets = [];\n\n  // Because we are installing directly onto WebApp.httpServer instead of using\n  // WebApp.app, we have to process the path prefix ourselves.\n  self.prefix = pathPrefix + '/sockjs';\n  RoutePolicy.declare(self.prefix + '/', 'network');\n\n  // set up sockjs\n  var sockjs = Npm.require('sockjs');\n  var serverOptions = {\n    prefix: self.prefix,\n    log: function() {},\n    // this is the default, but we code it explicitly because we depend\n    // on it in stream_client:HEARTBEAT_TIMEOUT\n    heartbeat_delay: 45000,\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU\n    // bound for that much time, SockJS might not notice that the user has\n    // reconnected because the timer (of disconnect_delay ms) can fire before\n    // SockJS processes the new connection. Eventually we'll fix this by not\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which\n    // converts to Unix sockets) but for now, raise the delay.\n    disconnect_delay: 60 * 1000,\n    // Set the USE_JSESSIONID environment variable to enable setting the\n    // JSESSIONID cookie. This is useful for setting up proxies with\n    // session affinity.\n    jsessionid: !!process.env.USE_JSESSIONID\n  };\n\n  // If you know your server environment (eg, proxies) will prevent websockets\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,\n  // browsers) will not waste time attempting to use them.\n  // (Your server will still have a /websocket endpoint.)\n  if (process.env.DISABLE_WEBSOCKETS) {\n    serverOptions.websocket = false;\n  } else {\n    serverOptions.faye_server_options = {\n      extensions: websocketExtensions()\n    };\n  }\n\n  self.server = sockjs.createServer(serverOptions);\n\n  // Install the sockjs handlers, but we want to keep around our own particular\n  // request handler that adjusts idle timeouts while we have an outstanding\n  // request.  This compensates for the fact that sockjs removes all listeners\n  // for \"request\" to add its own.\n  WebApp.httpServer.removeListener(\n    'request', WebApp._timeoutAdjustmentRequestCallback);\n  self.server.installHandlers(WebApp.httpServer);\n  WebApp.httpServer.addListener(\n    'request', WebApp._timeoutAdjustmentRequestCallback);\n\n  // Support the /websocket endpoint\n  self._redirectWebsocketEndpoint();\n\n  self.server.on('connection', function (socket) {\n    socket.send = function (data) {\n      socket.write(data);\n    };\n    socket.on('close', function () {\n      self.open_sockets = _.without(self.open_sockets, socket);\n    });\n    self.open_sockets.push(socket);\n\n    // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which\n    // will force old clients to reload. Remove this once we're not\n    // concerned about people upgrading from a pre-0.7.0 release. Also,\n    // remove the clause in the client that ignores the welcome message\n    // (livedata_connection.js)\n    socket.send(JSON.stringify({server_id: \"0\"}));\n\n    // call all our callbacks when we get a new socket. they will do the\n    // work of setting up handlers and such for specific messages.\n    _.each(self.registration_callbacks, function (callback) {\n      callback(socket);\n    });\n  });\n\n};\n\n_.extend(StreamServer.prototype, {\n  // call my callback when a new socket connects.\n  // also call it for all current connections.\n  register: function (callback) {\n    var self = this;\n    self.registration_callbacks.push(callback);\n    _.each(self.all_sockets(), function (socket) {\n      callback(socket);\n    });\n  },\n\n  // get a list of all sockets\n  all_sockets: function () {\n    var self = this;\n    return _.values(self.open_sockets);\n  },\n\n  // Redirect /websocket to /sockjs/websocket in order to not expose\n  // sockjs to clients that want to use raw websockets\n  _redirectWebsocketEndpoint: function() {\n    var self = this;\n    // Unfortunately we can't use a connect middleware here since\n    // sockjs installs itself prior to all existing listeners\n    // (meaning prior to any connect middlewares) so we need to take\n    // an approach similar to overshadowListeners in\n    // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee\n    _.each(['request', 'upgrade'], function(event) {\n      var httpServer = WebApp.httpServer;\n      var oldHttpServerListeners = httpServer.listeners(event).slice(0);\n      httpServer.removeAllListeners(event);\n\n      // request and upgrade have different arguments passed but\n      // we only care about the first one which is always request\n      var newListener = function(request /*, moreArguments */) {\n        // Store arguments for use within the closure below\n        var args = arguments;\n\n        // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while\n        // preserving query string.\n        var parsedUrl = url.parse(request.url);\n        if (parsedUrl.pathname === pathPrefix + '/websocket' ||\n            parsedUrl.pathname === pathPrefix + '/websocket/') {\n          parsedUrl.pathname = self.prefix + '/websocket';\n          request.url = url.format(parsedUrl);\n        }\n        _.each(oldHttpServerListeners, function(oldListener) {\n          oldListener.apply(httpServer, args);\n        });\n      };\n      httpServer.addListener(event, newListener);\n    });\n  }\n});\n"]},"hash":"68c8d8805574b85fd5b139b25e79b7ddcfbed566"}
