{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ddp-server/livedata_server.js","filenameRelative":"/packages/ddp-server/livedata_server.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ddp-server/livedata_server.js.map","sourceFileName":"/packages/ddp-server/livedata_server.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"livedata_server"},"ignored":false,"code":"var _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});\nDDPServer = {};\n\nvar Fiber = Npm.require('fibers');\n\n// This file contains classes:\n// * Session - The server's connection to a single DDP client\n// * Subscription - A single subscription for a single client\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.\n//\n// Session and Subscription are file scope. For now, until we freeze\n// the interface, Server is package scope (in the future it should be\n// exported.)\n\n// Represents a single document in a SessionCollectionView\nvar SessionDocumentView = function SessionDocumentView() {\n  var self = this;\n  self.existsIn = {}; // set of subscriptionHandle\n  self.dataByKey = {}; // key-> [ {subscriptionHandle, value} by precedence]\n};\n\nDDPServer._SessionDocumentView = SessionDocumentView;\n\n_.extend(SessionDocumentView.prototype, {\n\n  getFields: function () {\n    function getFields() {\n      var self = this;\n      var ret = {};\n      _.each(self.dataByKey, function (precedenceList, key) {\n        ret[key] = precedenceList[0].value;\n      });\n      return ret;\n    }\n\n    return getFields;\n  }(),\n\n  clearField: function () {\n    function clearField(subscriptionHandle, key, changeCollector) {\n      var self = this;\n      // Publish API ignores _id if present in fields\n      if (key === \"_id\") return;\n      var precedenceList = self.dataByKey[key];\n\n      // It's okay to clear fields that didn't exist. No need to throw\n      // an error.\n      if (!precedenceList) return;\n\n      var removedValue = undefined;\n      for (var i = 0; i < precedenceList.length; i++) {\n        var precedence = precedenceList[i];\n        if (precedence.subscriptionHandle === subscriptionHandle) {\n          // The view's value can only change if this subscription is the one that\n          // used to have precedence.\n          if (i === 0) removedValue = precedence.value;\n          precedenceList.splice(i, 1);\n          break;\n        }\n      }\n      if (_.isEmpty(precedenceList)) {\n        delete self.dataByKey[key];\n        changeCollector[key] = undefined;\n      } else if (removedValue !== undefined && !EJSON.equals(removedValue, precedenceList[0].value)) {\n        changeCollector[key] = precedenceList[0].value;\n      }\n    }\n\n    return clearField;\n  }(),\n\n  changeField: function () {\n    function changeField(subscriptionHandle, key, value, changeCollector, isAdd) {\n      var self = this;\n      // Publish API ignores _id if present in fields\n      if (key === \"_id\") return;\n\n      // Don't share state with the data passed in by the user.\n      value = EJSON.clone(value);\n\n      if (!_.has(self.dataByKey, key)) {\n        self.dataByKey[key] = [{ subscriptionHandle: subscriptionHandle,\n          value: value }];\n        changeCollector[key] = value;\n        return;\n      }\n      var precedenceList = self.dataByKey[key];\n      var elt;\n      if (!isAdd) {\n        elt = _.find(precedenceList, function (precedence) {\n          return precedence.subscriptionHandle === subscriptionHandle;\n        });\n      }\n\n      if (elt) {\n        if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\n          // this subscription is changing the value of this field.\n          changeCollector[key] = value;\n        }\n        elt.value = value;\n      } else {\n        // this subscription is newly caring about this field\n        precedenceList.push({ subscriptionHandle: subscriptionHandle, value: value });\n      }\n    }\n\n    return changeField;\n  }()\n});\n\n/**\n * Represents a client's view of a single collection\n * @param {String} collectionName Name of the collection it represents\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed\n * @class SessionCollectionView\n */\nvar SessionCollectionView = function SessionCollectionView(collectionName, sessionCallbacks) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.documents = {};\n  self.callbacks = sessionCallbacks;\n};\n\nDDPServer._SessionCollectionView = SessionCollectionView;\n\n_.extend(SessionCollectionView.prototype, {\n\n  isEmpty: function () {\n    function isEmpty() {\n      var self = this;\n      return _.isEmpty(self.documents);\n    }\n\n    return isEmpty;\n  }(),\n\n  diff: function () {\n    function diff(previous) {\n      var self = this;\n      DiffSequence.diffObjects(previous.documents, self.documents, {\n        both: _.bind(self.diffDocument, self),\n\n        rightOnly: function () {\n          function rightOnly(id, nowDV) {\n            self.callbacks.added(self.collectionName, id, nowDV.getFields());\n          }\n\n          return rightOnly;\n        }(),\n\n        leftOnly: function () {\n          function leftOnly(id, prevDV) {\n            self.callbacks.removed(self.collectionName, id);\n          }\n\n          return leftOnly;\n        }()\n      });\n    }\n\n    return diff;\n  }(),\n\n  diffDocument: function () {\n    function diffDocument(id, prevDV, nowDV) {\n      var self = this;\n      var fields = {};\n      DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {\n        both: function () {\n          function both(key, prev, now) {\n            if (!EJSON.equals(prev, now)) fields[key] = now;\n          }\n\n          return both;\n        }(),\n        rightOnly: function () {\n          function rightOnly(key, now) {\n            fields[key] = now;\n          }\n\n          return rightOnly;\n        }(),\n        leftOnly: function () {\n          function leftOnly(key, prev) {\n            fields[key] = undefined;\n          }\n\n          return leftOnly;\n        }()\n      });\n      self.callbacks.changed(self.collectionName, id, fields);\n    }\n\n    return diffDocument;\n  }(),\n\n  added: function () {\n    function added(subscriptionHandle, id, fields) {\n      var self = this;\n      var docView = self.documents[id];\n      var added = false;\n      if (!docView) {\n        added = true;\n        docView = new SessionDocumentView();\n        self.documents[id] = docView;\n      }\n      docView.existsIn[subscriptionHandle] = true;\n      var changeCollector = {};\n      _.each(fields, function (value, key) {\n        docView.changeField(subscriptionHandle, key, value, changeCollector, true);\n      });\n      if (added) self.callbacks.added(self.collectionName, id, changeCollector);else self.callbacks.changed(self.collectionName, id, changeCollector);\n    }\n\n    return added;\n  }(),\n\n  changed: function () {\n    function changed(subscriptionHandle, id, _changed) {\n      var self = this;\n      var changedResult = {};\n      var docView = self.documents[id];\n      if (!docView) throw new Error(\"Could not find element with id \" + id + \" to change\");\n      _.each(_changed, function (value, key) {\n        if (value === undefined) docView.clearField(subscriptionHandle, key, changedResult);else docView.changeField(subscriptionHandle, key, value, changedResult);\n      });\n      self.callbacks.changed(self.collectionName, id, changedResult);\n    }\n\n    return changed;\n  }(),\n\n  removed: function () {\n    function removed(subscriptionHandle, id) {\n      var self = this;\n      var docView = self.documents[id];\n      if (!docView) {\n        var err = new Error(\"Removed nonexistent document \" + id);\n        throw err;\n      }\n      delete docView.existsIn[subscriptionHandle];\n      if (_.isEmpty(docView.existsIn)) {\n        // it is gone from everyone\n        self.callbacks.removed(self.collectionName, id);\n        delete self.documents[id];\n      } else {\n        var changed = {};\n        // remove this subscription from every precedence list\n        // and record the changes\n        _.each(docView.dataByKey, function (precedenceList, key) {\n          docView.clearField(subscriptionHandle, key, changed);\n        });\n\n        self.callbacks.changed(self.collectionName, id, changed);\n      }\n    }\n\n    return removed;\n  }()\n});\n\n/******************************************************************************/\n/* Session                                                                    */\n/******************************************************************************/\n\nvar Session = function Session(server, version, socket, options) {\n  var self = this;\n  self.id = Random.id();\n\n  self.server = server;\n  self.version = version;\n\n  self.initialized = false;\n  self.socket = socket;\n\n  // set to null when the session is destroyed. multiple places below\n  // use this to determine if the session is alive or not.\n  self.inQueue = new Meteor._DoubleEndedQueue();\n\n  self.blocked = false;\n  self.workerRunning = false;\n\n  // Sub objects for active subscriptions\n  self._namedSubs = {};\n  self._universalSubs = [];\n\n  self.userId = null;\n\n  self.collectionViews = {};\n\n  // Set this to false to not send messages when collectionViews are\n  // modified. This is done when rerunning subs in _setUserId and those messages\n  // are calculated via a diff instead.\n  self._isSending = true;\n\n  // If this is true, don't start a newly-created universal publisher on this\n  // session. The session will take care of starting it when appropriate.\n  self._dontStartNewUniversalSubs = false;\n\n  // when we are rerunning subscriptions, any ready messages\n  // we want to buffer up for when we are done rerunning subscriptions\n  self._pendingReady = [];\n\n  // List of callbacks to call when this connection is closed.\n  self._closeCallbacks = [];\n\n  // XXX HACK: If a sockjs connection, save off the URL. This is\n  // temporary and will go away in the near future.\n  self._socketUrl = socket.url;\n\n  // Allow tests to disable responding to pings.\n  self._respondToPings = options.respondToPings;\n\n  // This object is the public interface to the session. In the public\n  // API, it is called the `connection` object.  Internally we call it\n  // a `connectionHandle` to avoid ambiguity.\n  self.connectionHandle = {\n    id: self.id,\n    close: function () {\n      function close() {\n        self.close();\n      }\n\n      return close;\n    }(),\n    onClose: function () {\n      function onClose(fn) {\n        var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");\n        if (self.inQueue) {\n          self._closeCallbacks.push(cb);\n        } else {\n          // if we're already closed, call the callback.\n          Meteor.defer(cb);\n        }\n      }\n\n      return onClose;\n    }(),\n    clientAddress: self._clientAddress(),\n    httpHeaders: self.socket.headers\n  };\n\n  self.send({ msg: 'connected', session: self.id });\n\n  // On initial connect, spin up all the universal publishers.\n  Fiber(function () {\n    self.startUniversalSubs();\n  }).run();\n\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {\n    self.heartbeat = new DDPCommon.Heartbeat({\n      heartbeatInterval: options.heartbeatInterval,\n      heartbeatTimeout: options.heartbeatTimeout,\n      onTimeout: function () {\n        function onTimeout() {\n          self.close();\n        }\n\n        return onTimeout;\n      }(),\n      sendPing: function () {\n        function sendPing() {\n          self.send({ msg: 'ping' });\n        }\n\n        return sendPing;\n      }()\n    });\n    self.heartbeat.start();\n  }\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"sessions\", 1);\n};\n\n_.extend(Session.prototype, {\n\n  sendReady: function () {\n    function sendReady(subscriptionIds) {\n      var self = this;\n      if (self._isSending) self.send({ msg: \"ready\", subs: subscriptionIds });else {\n        _.each(subscriptionIds, function (subscriptionId) {\n          self._pendingReady.push(subscriptionId);\n        });\n      }\n    }\n\n    return sendReady;\n  }(),\n\n  sendAdded: function () {\n    function sendAdded(collectionName, id, fields) {\n      var self = this;\n      if (self._isSending) self.send({ msg: \"added\", collection: collectionName, id: id, fields: fields });\n    }\n\n    return sendAdded;\n  }(),\n\n  sendChanged: function () {\n    function sendChanged(collectionName, id, fields) {\n      var self = this;\n      if (_.isEmpty(fields)) return;\n\n      if (self._isSending) {\n        self.send({\n          msg: \"changed\",\n          collection: collectionName,\n          id: id,\n          fields: fields\n        });\n      }\n    }\n\n    return sendChanged;\n  }(),\n\n  sendRemoved: function () {\n    function sendRemoved(collectionName, id) {\n      var self = this;\n      if (self._isSending) self.send({ msg: \"removed\", collection: collectionName, id: id });\n    }\n\n    return sendRemoved;\n  }(),\n\n  getSendCallbacks: function () {\n    function getSendCallbacks() {\n      var self = this;\n      return {\n        added: _.bind(self.sendAdded, self),\n        changed: _.bind(self.sendChanged, self),\n        removed: _.bind(self.sendRemoved, self)\n      };\n    }\n\n    return getSendCallbacks;\n  }(),\n\n  getCollectionView: function () {\n    function getCollectionView(collectionName) {\n      var self = this;\n      if (_.has(self.collectionViews, collectionName)) {\n        return self.collectionViews[collectionName];\n      }\n      var ret = new SessionCollectionView(collectionName, self.getSendCallbacks());\n      self.collectionViews[collectionName] = ret;\n      return ret;\n    }\n\n    return getCollectionView;\n  }(),\n\n  added: function () {\n    function added(subscriptionHandle, collectionName, id, fields) {\n      var self = this;\n      var view = self.getCollectionView(collectionName);\n      view.added(subscriptionHandle, id, fields);\n    }\n\n    return added;\n  }(),\n\n  removed: function () {\n    function removed(subscriptionHandle, collectionName, id) {\n      var self = this;\n      var view = self.getCollectionView(collectionName);\n      view.removed(subscriptionHandle, id);\n      if (view.isEmpty()) {\n        delete self.collectionViews[collectionName];\n      }\n    }\n\n    return removed;\n  }(),\n\n  changed: function () {\n    function changed(subscriptionHandle, collectionName, id, fields) {\n      var self = this;\n      var view = self.getCollectionView(collectionName);\n      view.changed(subscriptionHandle, id, fields);\n    }\n\n    return changed;\n  }(),\n\n  startUniversalSubs: function () {\n    function startUniversalSubs() {\n      var self = this;\n      // Make a shallow copy of the set of universal handlers and start them. If\n      // additional universal publishers start while we're running them (due to\n      // yielding), they will run separately as part of Server.publish.\n      var handlers = _.clone(self.server.universal_publish_handlers);\n      _.each(handlers, function (handler) {\n        self._startSubscription(handler);\n      });\n    }\n\n    return startUniversalSubs;\n  }(),\n\n  // Destroy this session and unregister it at the server.\n  close: function () {\n    function close() {\n      var self = this;\n\n      // Destroy this session, even if it's not registered at the\n      // server. Stop all processing and tear everything down. If a socket\n      // was attached, close it.\n\n      // Already destroyed.\n      if (!self.inQueue) return;\n\n      // Drop the merge box data immediately.\n      self.inQueue = null;\n      self.collectionViews = {};\n\n      if (self.heartbeat) {\n        self.heartbeat.stop();\n        self.heartbeat = null;\n      }\n\n      if (self.socket) {\n        self.socket.close();\n        self.socket._meteorSession = null;\n      }\n\n      Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"sessions\", -1);\n\n      Meteor.defer(function () {\n        // stop callbacks can yield, so we defer this on close.\n        // sub._isDeactivated() detects that we set inQueue to null and\n        // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\n        self._deactivateAllSubscriptions();\n\n        // Defer calling the close callbacks, so that the caller closing\n        // the session isn't waiting for all the callbacks to complete.\n        _.each(self._closeCallbacks, function (callback) {\n          callback();\n        });\n      });\n\n      // Unregister the session.\n      self.server._removeSession(self);\n    }\n\n    return close;\n  }(),\n\n  // Send a message (doing nothing if no socket is connected right now.)\n  // It should be a JSON object (it will be stringified.)\n  send: function () {\n    function send(msg) {\n      var self = this;\n      if (self.socket) {\n        if (Meteor._printSentDDP) Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));\n        self.socket.send(DDPCommon.stringifyDDP(msg));\n      }\n    }\n\n    return send;\n  }(),\n\n  // Send a connection error.\n  sendError: function () {\n    function sendError(reason, offendingMessage) {\n      var self = this;\n      var msg = { msg: 'error', reason: reason };\n      if (offendingMessage) msg.offendingMessage = offendingMessage;\n      self.send(msg);\n    }\n\n    return sendError;\n  }(),\n\n  // Process 'msg' as an incoming message. (But as a guard against\n  // race conditions during reconnection, ignore the message if\n  // 'socket' is not the currently connected socket.)\n  //\n  // We run the messages from the client one at a time, in the order\n  // given by the client. The message handler is passed an idempotent\n  // function 'unblock' which it may call to allow other messages to\n  // begin running in parallel in another fiber (for example, a method\n  // that wants to yield.) Otherwise, it is automatically unblocked\n  // when it returns.\n  //\n  // Actually, we don't have to 'totally order' the messages in this\n  // way, but it's the easiest thing that's correct. (unsub needs to\n  // be ordered against sub, methods need to be ordered against each\n  // other.)\n  processMessage: function () {\n    function processMessage(msg_in) {\n      var self = this;\n      if (!self.inQueue) // we have been destroyed.\n        return;\n\n      // Respond to ping and pong messages immediately without queuing.\n      // If the negotiated DDP version is \"pre1\" which didn't support\n      // pings, preserve the \"pre1\" behavior of responding with a \"bad\n      // request\" for the unknown messages.\n      //\n      // Fibers are needed because heartbeat uses Meteor.setTimeout, which\n      // needs a Fiber. We could actually use regular setTimeout and avoid\n      // these new fibers, but it is easier to just make everything use\n      // Meteor.setTimeout and not think too hard.\n      //\n      // Any message counts as receiving a pong, as it demonstrates that\n      // the client is still alive.\n      if (self.heartbeat) {\n        Fiber(function () {\n          self.heartbeat.messageReceived();\n        }).run();\n      }\n\n      if (self.version !== 'pre1' && msg_in.msg === 'ping') {\n        if (self._respondToPings) self.send({ msg: \"pong\", id: msg_in.id });\n        return;\n      }\n      if (self.version !== 'pre1' && msg_in.msg === 'pong') {\n        // Since everything is a pong, nothing to do\n        return;\n      }\n\n      self.inQueue.push(msg_in);\n      if (self.workerRunning) return;\n      self.workerRunning = true;\n\n      var processNext = function () {\n        function processNext() {\n          var msg = self.inQueue && self.inQueue.shift();\n          if (!msg) {\n            self.workerRunning = false;\n            return;\n          }\n\n          Fiber(function () {\n            var blocked = true;\n\n            var unblock = function () {\n              function unblock() {\n                if (!blocked) return; // idempotent\n                blocked = false;\n                processNext();\n              }\n\n              return unblock;\n            }();\n\n            if (_.has(self.protocol_handlers, msg.msg)) self.protocol_handlers[msg.msg].call(self, msg, unblock);else self.sendError('Bad request', msg);\n            unblock(); // in case the handler didn't already do it\n          }).run();\n        }\n\n        return processNext;\n      }();\n\n      processNext();\n    }\n\n    return processMessage;\n  }(),\n\n  protocol_handlers: {\n    sub: function () {\n      function sub(msg) {\n        var self = this;\n\n        // reject malformed messages\n        if (typeof msg.id !== \"string\" || typeof msg.name !== \"string\" || 'params' in msg && !(msg.params instanceof Array)) {\n          self.sendError(\"Malformed subscription\", msg);\n          return;\n        }\n\n        if (!self.server.publish_handlers[msg.name]) {\n          self.send({\n            msg: 'nosub', id: msg.id,\n            error: new Meteor.Error(404, \"Subscription '\" + msg.name + \"' not found\") });\n          return;\n        }\n\n        if (_.has(self._namedSubs, msg.id))\n          // subs are idempotent, or rather, they are ignored if a sub\n          // with that id already exists. this is important during\n          // reconnect.\n          return;\n\n        // XXX It'd be much better if we had generic hooks where any package can\n        // hook into subscription handling, but in the mean while we special case\n        // ddp-rate-limiter package. This is also done for weak requirements to\n        // add the ddp-rate-limiter package in case we don't have Accounts. A\n        // user trying to use the ddp-rate-limiter must explicitly require it.\n        if (Package['ddp-rate-limiter']) {\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n          var rateLimiterInput = {\n            userId: self.userId,\n            clientAddress: self.connectionHandle.clientAddress,\n            type: \"subscription\",\n            name: msg.name,\n            connectionId: self.id\n          };\n\n          DDPRateLimiter._increment(rateLimiterInput);\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n          if (!rateLimitResult.allowed) {\n            self.send({\n              msg: 'nosub', id: msg.id,\n              error: new Meteor.Error('too-many-requests', DDPRateLimiter.getErrorMessage(rateLimitResult), { timeToReset: rateLimitResult.timeToReset })\n            });\n            return;\n          }\n        }\n\n        var handler = self.server.publish_handlers[msg.name];\n\n        self._startSubscription(handler, msg.id, msg.params, msg.name);\n      }\n\n      return sub;\n    }(),\n\n    unsub: function () {\n      function unsub(msg) {\n        var self = this;\n\n        self._stopSubscription(msg.id);\n      }\n\n      return unsub;\n    }(),\n\n    method: function () {\n      function method(msg, unblock) {\n        var self = this;\n\n        // reject malformed messages\n        // For now, we silently ignore unknown attributes,\n        // for forwards compatibility.\n        if (typeof msg.id !== \"string\" || typeof msg.method !== \"string\" || 'params' in msg && !(msg.params instanceof Array) || 'randomSeed' in msg && typeof msg.randomSeed !== \"string\") {\n          self.sendError(\"Malformed method invocation\", msg);\n          return;\n        }\n\n        var randomSeed = msg.randomSeed || null;\n\n        // set up to mark the method as satisfied once all observers\n        // (and subscriptions) have reacted to any writes that were\n        // done.\n        var fence = new DDPServer._WriteFence();\n        fence.onAllCommitted(function () {\n          // Retire the fence so that future writes are allowed.\n          // This means that callbacks like timers are free to use\n          // the fence, and if they fire before it's armed (for\n          // example, because the method waits for them) their\n          // writes will be included in the fence.\n          fence.retire();\n          self.send({\n            msg: 'updated', methods: [msg.id] });\n        });\n\n        // find the handler\n        var handler = self.server.method_handlers[msg.method];\n        if (!handler) {\n          self.send({\n            msg: 'result', id: msg.id,\n            error: new Meteor.Error(404, \"Method '\" + msg.method + \"' not found\") });\n          fence.arm();\n          return;\n        }\n\n        var setUserId = function () {\n          function setUserId(userId) {\n            self._setUserId(userId);\n          }\n\n          return setUserId;\n        }();\n\n        var invocation = new DDPCommon.MethodInvocation({\n          isSimulation: false,\n          userId: self.userId,\n          setUserId: setUserId,\n          unblock: unblock,\n          connection: self.connectionHandle,\n          randomSeed: randomSeed\n        });\n\n        var promise = new Promise(function (resolve, reject) {\n          // XXX It'd be better if we could hook into method handlers better but\n          // for now, we need to check if the ddp-rate-limiter exists since we\n          // have a weak requirement for the ddp-rate-limiter package to be added\n          // to our application.\n          if (Package['ddp-rate-limiter']) {\n            var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n            var rateLimiterInput = {\n              userId: self.userId,\n              clientAddress: self.connectionHandle.clientAddress,\n              type: \"method\",\n              name: msg.method,\n              connectionId: self.id\n            };\n            DDPRateLimiter._increment(rateLimiterInput);\n            var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n            if (!rateLimitResult.allowed) {\n              reject(new Meteor.Error(\"too-many-requests\", DDPRateLimiter.getErrorMessage(rateLimitResult), { timeToReset: rateLimitResult.timeToReset }));\n              return;\n            }\n          }\n\n          resolve(DDPServer._CurrentWriteFence.withValue(fence, function () {\n            return DDP._CurrentInvocation.withValue(invocation, function () {\n              return maybeAuditArgumentChecks(handler, invocation, msg.params, \"call to '\" + msg.method + \"'\");\n            });\n          }));\n        });\n\n        function finish() {\n          fence.arm();\n          unblock();\n        }\n\n        var payload = {\n          msg: \"result\",\n          id: msg.id\n        };\n\n        promise.then(function (result) {\n          finish();\n          if (result !== undefined) {\n            payload.result = result;\n          }\n          self.send(payload);\n        }, function (exception) {\n          finish();\n          payload.error = wrapInternalException(exception, \"while invoking method '\" + msg.method + \"'\");\n          self.send(payload);\n        });\n      }\n\n      return method;\n    }()\n  },\n\n  _eachSub: function () {\n    function _eachSub(f) {\n      var self = this;\n      _.each(self._namedSubs, f);\n      _.each(self._universalSubs, f);\n    }\n\n    return _eachSub;\n  }(),\n\n  _diffCollectionViews: function () {\n    function _diffCollectionViews(beforeCVs) {\n      var self = this;\n      DiffSequence.diffObjects(beforeCVs, self.collectionViews, {\n        both: function () {\n          function both(collectionName, leftValue, rightValue) {\n            rightValue.diff(leftValue);\n          }\n\n          return both;\n        }(),\n        rightOnly: function () {\n          function rightOnly(collectionName, rightValue) {\n            _.each(rightValue.documents, function (docView, id) {\n              self.sendAdded(collectionName, id, docView.getFields());\n            });\n          }\n\n          return rightOnly;\n        }(),\n        leftOnly: function () {\n          function leftOnly(collectionName, leftValue) {\n            _.each(leftValue.documents, function (doc, id) {\n              self.sendRemoved(collectionName, id);\n            });\n          }\n\n          return leftOnly;\n        }()\n      });\n    }\n\n    return _diffCollectionViews;\n  }(),\n\n  // Sets the current user id in all appropriate contexts and reruns\n  // all subscriptions\n  _setUserId: function () {\n    function _setUserId(userId) {\n      var self = this;\n\n      if (userId !== null && typeof userId !== \"string\") throw new Error(\"setUserId must be called on string or null, not \" + (typeof userId === \"undefined\" ? \"undefined\" : _typeof(userId)));\n\n      // Prevent newly-created universal subscriptions from being added to our\n      // session; they will be found below when we call startUniversalSubs.\n      //\n      // (We don't have to worry about named subscriptions, because we only add\n      // them when we process a 'sub' message. We are currently processing a\n      // 'method' message, and the method did not unblock, because it is illegal\n      // to call setUserId after unblock. Thus we cannot be concurrently adding a\n      // new named subscription.)\n      self._dontStartNewUniversalSubs = true;\n\n      // Prevent current subs from updating our collectionViews and call their\n      // stop callbacks. This may yield.\n      self._eachSub(function (sub) {\n        sub._deactivate();\n      });\n\n      // All subs should now be deactivated. Stop sending messages to the client,\n      // save the state of the published collections, reset to an empty view, and\n      // update the userId.\n      self._isSending = false;\n      var beforeCVs = self.collectionViews;\n      self.collectionViews = {};\n      self.userId = userId;\n\n      // Save the old named subs, and reset to having no subscriptions.\n      var oldNamedSubs = self._namedSubs;\n      self._namedSubs = {};\n      self._universalSubs = [];\n\n      _.each(oldNamedSubs, function (sub, subscriptionId) {\n        self._namedSubs[subscriptionId] = sub._recreate();\n        // nb: if the handler throws or calls this.error(), it will in fact\n        // immediately send its 'nosub'. This is OK, though.\n        self._namedSubs[subscriptionId]._runHandler();\n      });\n\n      // Allow newly-created universal subs to be started on our connection in\n      // parallel with the ones we're spinning up here, and spin up universal\n      // subs.\n      self._dontStartNewUniversalSubs = false;\n      self.startUniversalSubs();\n\n      // Start sending messages again, beginning with the diff from the previous\n      // state of the world to the current state. No yields are allowed during\n      // this diff, so that other changes cannot interleave.\n      Meteor._noYieldsAllowed(function () {\n        self._isSending = true;\n        self._diffCollectionViews(beforeCVs);\n        if (!_.isEmpty(self._pendingReady)) {\n          self.sendReady(self._pendingReady);\n          self._pendingReady = [];\n        }\n      });\n    }\n\n    return _setUserId;\n  }(),\n\n  _startSubscription: function () {\n    function _startSubscription(handler, subId, params, name) {\n      var self = this;\n\n      var sub = new Subscription(self, handler, subId, params, name);\n      if (subId) self._namedSubs[subId] = sub;else self._universalSubs.push(sub);\n\n      sub._runHandler();\n    }\n\n    return _startSubscription;\n  }(),\n\n  // tear down specified subscription\n  _stopSubscription: function () {\n    function _stopSubscription(subId, error) {\n      var self = this;\n\n      var subName = null;\n\n      if (subId && self._namedSubs[subId]) {\n        subName = self._namedSubs[subId]._name;\n        self._namedSubs[subId]._removeAllDocuments();\n        self._namedSubs[subId]._deactivate();\n        delete self._namedSubs[subId];\n      }\n\n      var response = { msg: 'nosub', id: subId };\n\n      if (error) {\n        response.error = wrapInternalException(error, subName ? \"from sub \" + subName + \" id \" + subId : \"from sub id \" + subId);\n      }\n\n      self.send(response);\n    }\n\n    return _stopSubscription;\n  }(),\n\n  // tear down all subscriptions. Note that this does NOT send removed or nosub\n  // messages, since we assume the client is gone.\n  _deactivateAllSubscriptions: function () {\n    function _deactivateAllSubscriptions() {\n      var self = this;\n\n      _.each(self._namedSubs, function (sub, id) {\n        sub._deactivate();\n      });\n      self._namedSubs = {};\n\n      _.each(self._universalSubs, function (sub) {\n        sub._deactivate();\n      });\n      self._universalSubs = [];\n    }\n\n    return _deactivateAllSubscriptions;\n  }(),\n\n  // Determine the remote client's IP address, based on the\n  // HTTP_FORWARDED_COUNT environment variable representing how many\n  // proxies the server is behind.\n  _clientAddress: function () {\n    function _clientAddress() {\n      var self = this;\n\n      // For the reported client address for a connection to be correct,\n      // the developer must set the HTTP_FORWARDED_COUNT environment\n      // variable to an integer representing the number of hops they\n      // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the\n      // server is behind one proxy.\n      //\n      // This could be computed once at startup instead of every time.\n      var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\n\n      if (httpForwardedCount === 0) return self.socket.remoteAddress;\n\n      var forwardedFor = self.socket.headers[\"x-forwarded-for\"];\n      if (!_.isString(forwardedFor)) return null;\n      forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);\n\n      // Typically the first value in the `x-forwarded-for` header is\n      // the original IP address of the client connecting to the first\n      // proxy.  However, the end user can easily spoof the header, in\n      // which case the first value(s) will be the fake IP address from\n      // the user pretending to be a proxy reporting the original IP\n      // address value.  By counting HTTP_FORWARDED_COUNT back from the\n      // end of the list, we ensure that we get the IP address being\n      // reported by *our* first proxy.\n\n      if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length) return null;\n\n      return forwardedFor[forwardedFor.length - httpForwardedCount];\n    }\n\n    return _clientAddress;\n  }()\n});\n\n/******************************************************************************/\n/* Subscription                                                               */\n/******************************************************************************/\n\n// ctor for a sub handle: the input to each publish function\n\n// Instance name is this because it's usually referred to as this inside a\n// publish\n/**\n * @summary The server's side of a subscription\n * @class Subscription\n * @instanceName this\n */\nvar Subscription = function Subscription(session, handler, subscriptionId, params, name) {\n  var self = this;\n  self._session = session; // type is Session\n\n  /**\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server\n   * @name  connection\n   * @memberOf Subscription\n   * @instance\n   */\n  self.connection = session.connectionHandle; // public API object\n\n  self._handler = handler;\n\n  // my subscription ID (generated by client, undefined for universal subs).\n  self._subscriptionId = subscriptionId;\n  // undefined for universal subs\n  self._name = name;\n\n  self._params = params || [];\n\n  // Only named subscriptions have IDs, but we need some sort of string\n  // internally to keep track of all subscriptions inside\n  // SessionDocumentViews. We use this subscriptionHandle for that.\n  if (self._subscriptionId) {\n    self._subscriptionHandle = 'N' + self._subscriptionId;\n  } else {\n    self._subscriptionHandle = 'U' + Random.id();\n  }\n\n  // has _deactivate been called?\n  self._deactivated = false;\n\n  // stop callbacks to g/c this sub.  called w/ zero arguments.\n  self._stopCallbacks = [];\n\n  // the set of (collection, documentid) that this subscription has\n  // an opinion about\n  self._documents = {};\n\n  // remember if we are ready.\n  self._ready = false;\n\n  // Part of the public API: the user of this sub.\n\n  /**\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.\n   * @locus Server\n   * @memberOf Subscription\n   * @name  userId\n   * @instance\n   */\n  self.userId = session.userId;\n\n  // For now, the id filter is going to default to\n  // the to/from DDP methods on MongoID, to\n  // specifically deal with mongo/minimongo ObjectIds.\n\n  // Later, you will be able to make this be \"raw\"\n  // if you want to publish a collection that you know\n  // just has strings for keys and no funny business, to\n  // a ddp consumer that isn't minimongo\n\n  self._idFilter = {\n    idStringify: MongoID.idStringify,\n    idParse: MongoID.idParse\n  };\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"subscriptions\", 1);\n};\n\n_.extend(Subscription.prototype, {\n  _runHandler: function () {\n    function _runHandler() {\n      // XXX should we unblock() here? Either before running the publish\n      // function, or before running _publishCursor.\n      //\n      // Right now, each publish function blocks all future publishes and\n      // methods waiting on data from Mongo (or whatever else the function\n      // blocks on). This probably slows page load in common cases.\n\n      var self = this;\n      try {\n        var res = maybeAuditArgumentChecks(self._handler, self, EJSON.clone(self._params),\n        // It's OK that this would look weird for universal subscriptions,\n        // because they have no arguments so there can never be an\n        // audit-argument-checks failure.\n        \"publisher '\" + self._name + \"'\");\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n\n      // Did the handler call this.error or this.stop?\n      if (self._isDeactivated()) return;\n\n      self._publishHandlerResult(res);\n    }\n\n    return _runHandler;\n  }(),\n\n  _publishHandlerResult: function () {\n    function _publishHandlerResult(res) {\n      // SPECIAL CASE: Instead of writing their own callbacks that invoke\n      // this.added/changed/ready/etc, the user can just return a collection\n      // cursor or array of cursors from the publish function; we call their\n      // _publishCursor method which starts observing the cursor and publishes the\n      // results. Note that _publishCursor does NOT call ready().\n      //\n      // XXX This uses an undocumented interface which only the Mongo cursor\n      // interface publishes. Should we make this interface public and encourage\n      // users to implement it themselves? Arguably, it's unnecessary; users can\n      // already write their own functions like\n      //   var publishMyReactiveThingy = function (name, handler) {\n      //     Meteor.publish(name, function () {\n      //       var reactiveThingy = handler();\n      //       reactiveThingy.publishMe();\n      //     });\n      //   };\n\n      var self = this;\n      var isCursor = function () {\n        function isCursor(c) {\n          return c && c._publishCursor;\n        }\n\n        return isCursor;\n      }();\n      if (isCursor(res)) {\n        try {\n          res._publishCursor(self);\n        } catch (e) {\n          self.error(e);\n          return;\n        }\n        // _publishCursor only returns after the initial added callbacks have run.\n        // mark subscription as ready.\n        self.ready();\n      } else if (_.isArray(res)) {\n        // check all the elements are cursors\n        if (!_.all(res, isCursor)) {\n          self.error(new Error(\"Publish function returned an array of non-Cursors\"));\n          return;\n        }\n        // find duplicate collection names\n        // XXX we should support overlapping cursors, but that would require the\n        // merge box to allow overlap within a subscription\n        var collectionNames = {};\n        for (var i = 0; i < res.length; ++i) {\n          var collectionName = res[i]._getCollectionName();\n          if (_.has(collectionNames, collectionName)) {\n            self.error(new Error(\"Publish function returned multiple cursors for collection \" + collectionName));\n            return;\n          }\n          collectionNames[collectionName] = true;\n        };\n\n        try {\n          _.each(res, function (cur) {\n            cur._publishCursor(self);\n          });\n        } catch (e) {\n          self.error(e);\n          return;\n        }\n        self.ready();\n      } else if (res) {\n        // truthy values other than cursors or arrays are probably a\n        // user mistake (possible returning a Mongo document via, say,\n        // `coll.findOne()`).\n        self.error(new Error(\"Publish function can only return a Cursor or \" + \"an array of Cursors\"));\n      }\n    }\n\n    return _publishHandlerResult;\n  }(),\n\n  // This calls all stop callbacks and prevents the handler from updating any\n  // SessionCollectionViews further. It's used when the user unsubscribes or\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send\n  // removed messages for the published objects; if that is necessary, call\n  // _removeAllDocuments first.\n  _deactivate: function () {\n    function _deactivate() {\n      var self = this;\n      if (self._deactivated) return;\n      self._deactivated = true;\n      self._callStopCallbacks();\n      Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"subscriptions\", -1);\n    }\n\n    return _deactivate;\n  }(),\n\n  _callStopCallbacks: function () {\n    function _callStopCallbacks() {\n      var self = this;\n      // tell listeners, so they can clean up\n      var callbacks = self._stopCallbacks;\n      self._stopCallbacks = [];\n      _.each(callbacks, function (callback) {\n        callback();\n      });\n    }\n\n    return _callStopCallbacks;\n  }(),\n\n  // Send remove messages for every document.\n  _removeAllDocuments: function () {\n    function _removeAllDocuments() {\n      var self = this;\n      Meteor._noYieldsAllowed(function () {\n        _.each(self._documents, function (collectionDocs, collectionName) {\n          // Iterate over _.keys instead of the dictionary itself, since we'll be\n          // mutating it.\n          _.each(_.keys(collectionDocs), function (strId) {\n            self.removed(collectionName, self._idFilter.idParse(strId));\n          });\n        });\n      });\n    }\n\n    return _removeAllDocuments;\n  }(),\n\n  // Returns a new Subscription for the same session with the same\n  // initial creation parameters. This isn't a clone: it doesn't have\n  // the same _documents cache, stopped state or callbacks; may have a\n  // different _subscriptionHandle, and gets its userId from the\n  // session, not from this object.\n  _recreate: function () {\n    function _recreate() {\n      var self = this;\n      return new Subscription(self._session, self._handler, self._subscriptionId, self._params, self._name);\n    }\n\n    return _recreate;\n  }(),\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server\n   * @param {Error} error The error to pass to the client.\n   * @instance\n   * @memberOf Subscription\n   */\n  error: function () {\n    function error(_error) {\n      var self = this;\n      if (self._isDeactivated()) return;\n      self._session._stopSubscription(self._subscriptionId, _error);\n    }\n\n    return error;\n  }(),\n\n  // Note that while our DDP client will notice that you've called stop() on the\n  // server (and clean up its _subscriptions table) we don't actually provide a\n  // mechanism for an app to notice this (the subscribe onError callback only\n  // triggers if there is an error).\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server\n   * @instance\n   * @memberOf Subscription\n   */\n  stop: function () {\n    function stop() {\n      var self = this;\n      if (self._isDeactivated()) return;\n      self._session._stopSubscription(self._subscriptionId);\n    }\n\n    return stop;\n  }(),\n\n  /**\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {Function} func The callback function\n   */\n  onStop: function () {\n    function onStop(callback) {\n      var self = this;\n      if (self._isDeactivated()) callback();else self._stopCallbacks.push(callback);\n    }\n\n    return onStop;\n  }(),\n\n  // This returns true if the sub has been deactivated, *OR* if the session was\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\n  // happened yet.\n  _isDeactivated: function () {\n    function _isDeactivated() {\n      var self = this;\n      return self._deactivated || self._session.inQueue === null;\n    }\n\n    return _isDeactivated;\n  }(),\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the new document.\n   * @param {String} id The new document's ID.\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.\n   */\n  added: function () {\n    function added(collectionName, id, fields) {\n      var self = this;\n      if (self._isDeactivated()) return;\n      id = self._idFilter.idStringify(id);\n      Meteor._ensure(self._documents, collectionName)[id] = true;\n      self._session.added(self._subscriptionHandle, collectionName, id, fields);\n    }\n\n    return added;\n  }(),\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the changed document.\n   * @param {String} id The changed document's ID.\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */\n  changed: function () {\n    function changed(collectionName, id, fields) {\n      var self = this;\n      if (self._isDeactivated()) return;\n      id = self._idFilter.idStringify(id);\n      self._session.changed(self._subscriptionHandle, collectionName, id, fields);\n    }\n\n    return changed;\n  }(),\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that the document has been removed from.\n   * @param {String} id The ID of the document that has been removed.\n   */\n  removed: function () {\n    function removed(collectionName, id) {\n      var self = this;\n      if (self._isDeactivated()) return;\n      id = self._idFilter.idStringify(id);\n      // We don't bother to delete sets of things in a collection if the\n      // collection is empty.  It could break _removeAllDocuments.\n      delete self._documents[collectionName][id];\n      self._session.removed(self._subscriptionHandle, collectionName, id);\n    }\n\n    return removed;\n  }(),\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   */\n  ready: function () {\n    function ready() {\n      var self = this;\n      if (self._isDeactivated()) return;\n      if (!self._subscriptionId) return; // unnecessary but ignored for universal sub\n      if (!self._ready) {\n        self._session.sendReady([self._subscriptionId]);\n        self._ready = true;\n      }\n    }\n\n    return ready;\n  }()\n});\n\n/******************************************************************************/\n/* Server                                                                     */\n/******************************************************************************/\n\nServer = function Server(options) {\n  var self = this;\n\n  // The default heartbeat interval is 30 seconds on the server and 35\n  // seconds on the client.  Since the client doesn't need to send a\n  // ping as long as it is receiving pings, this means that pings\n  // normally go from the server to the client.\n  //\n  // Note: Troposphere depends on the ability to mutate\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n  self.options = _.defaults(options || {}, {\n    heartbeatInterval: 15000,\n    heartbeatTimeout: 15000,\n    // For testing, allow responding to pings to be disabled.\n    respondToPings: true\n  });\n\n  // Map of callbacks to call when a new connection comes in to the\n  // server and completes DDP version negotiation. Use an object instead\n  // of an array so we can safely remove one from the list while\n  // iterating over it.\n  self.onConnectionHook = new Hook({\n    debugPrintExceptions: \"onConnection callback\"\n  });\n\n  self.publish_handlers = {};\n  self.universal_publish_handlers = [];\n\n  self.method_handlers = {};\n\n  self.sessions = {}; // map from id to session\n\n  self.stream_server = new StreamServer();\n\n  self.stream_server.register(function (socket) {\n    // socket implements the SockJSConnection interface\n    socket._meteorSession = null;\n\n    var sendError = function sendError(reason, offendingMessage) {\n      var msg = { msg: 'error', reason: reason };\n      if (offendingMessage) msg.offendingMessage = offendingMessage;\n      socket.send(DDPCommon.stringifyDDP(msg));\n    };\n\n    socket.on('data', function (raw_msg) {\n      if (Meteor._printReceivedDDP) {\n        Meteor._debug(\"Received DDP\", raw_msg);\n      }\n      try {\n        try {\n          var msg = DDPCommon.parseDDP(raw_msg);\n        } catch (err) {\n          sendError('Parse error');\n          return;\n        }\n        if (msg === null || !msg.msg) {\n          sendError('Bad request', msg);\n          return;\n        }\n\n        if (msg.msg === 'connect') {\n          if (socket._meteorSession) {\n            sendError(\"Already connected\", msg);\n            return;\n          }\n          Fiber(function () {\n            self._handleConnect(socket, msg);\n          }).run();\n          return;\n        }\n\n        if (!socket._meteorSession) {\n          sendError('Must connect first', msg);\n          return;\n        }\n        socket._meteorSession.processMessage(msg);\n      } catch (e) {\n        // XXX print stack nicely\n        Meteor._debug(\"Internal exception while processing message\", msg, e.message, e.stack);\n      }\n    });\n\n    socket.on('close', function () {\n      if (socket._meteorSession) {\n        Fiber(function () {\n          socket._meteorSession.close();\n        }).run();\n      }\n    });\n  });\n};\n\n_.extend(Server.prototype, {\n\n  /**\n   * @summary Register a callback to be called when a new DDP connection is made to the server.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP connection is established.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onConnection: function () {\n    function onConnection(fn) {\n      var self = this;\n      return self.onConnectionHook.register(fn);\n    }\n\n    return onConnection;\n  }(),\n\n  _handleConnect: function () {\n    function _handleConnect(socket, msg) {\n      var self = this;\n\n      // The connect message must specify a version and an array of supported\n      // versions, and it must claim to support what it is proposing.\n      if (!(typeof msg.version === 'string' && _.isArray(msg.support) && _.all(msg.support, _.isString) && _.contains(msg.support, msg.version))) {\n        socket.send(DDPCommon.stringifyDDP({ msg: 'failed',\n          version: DDPCommon.SUPPORTED_DDP_VERSIONS[0] }));\n        socket.close();\n        return;\n      }\n\n      // In the future, handle session resumption: something like:\n      //  socket._meteorSession = self.sessions[msg.session]\n      var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);\n\n      if (msg.version !== version) {\n        // The best version to use (according to the client's stated preferences)\n        // is not the one the client is trying to use. Inform them about the best\n        // version to use.\n        socket.send(DDPCommon.stringifyDDP({ msg: 'failed', version: version }));\n        socket.close();\n        return;\n      }\n\n      // Yay, version matches! Create a new session.\n      // Note: Troposphere depends on the ability to mutate\n      // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n      socket._meteorSession = new Session(self, version, socket, self.options);\n      self.sessions[socket._meteorSession.id] = socket._meteorSession;\n      self.onConnectionHook.each(function (callback) {\n        if (socket._meteorSession) callback(socket._meteorSession.connectionHandle);\n        return true;\n      });\n    }\n\n    return _handleConnect;\n  }(),\n  /**\n   * Register a publish handler function.\n   *\n   * @param name {String} identifier for query\n   * @param handler {Function} publish handler\n   * @param options {Object}\n   *\n   * Server will call handler function on each new subscription,\n   * either when receiving DDP sub message for a named subscription, or on\n   * DDP connect for a universal subscription.\n   *\n   * If name is null, this will be a subscription that is\n   * automatically established and permanently on for all connected\n   * client, instead of a subscription that can be turned on and off\n   * with subscribe().\n   *\n   * options to contain:\n   *  - (mostly internal) is_auto: true if generated automatically\n   *    from an autopublish hook. this is for cosmetic purposes only\n   *    (it lets us determine whether to print a warning suggesting\n   *    that you turn off autopublish.)\n   */\n\n  /**\n   * @summary Publish a record set.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @locus Server\n   * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */\n  publish: function () {\n    function publish(name, handler, options) {\n      var self = this;\n\n      if (!_.isObject(name)) {\n        options = options || {};\n\n        if (name && name in self.publish_handlers) {\n          Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");\n          return;\n        }\n\n        if (Package.autopublish && !options.is_auto) {\n          // They have autopublish on, yet they're trying to manually\n          // picking stuff to publish. They probably should turn off\n          // autopublish. (This check isn't perfect -- if you create a\n          // publish before you turn on autopublish, it won't catch\n          // it. But this will definitely handle the simple case where\n          // you've added the autopublish package to your app, and are\n          // calling publish from your app code.)\n          if (!self.warned_about_autopublish) {\n            self.warned_about_autopublish = true;\n            Meteor._debug(\"** You've set up some data subscriptions with Meteor.publish(), but\\n\" + \"** you still have autopublish turned on. Because autopublish is still\\n\" + \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" + \"** will still be sent to all clients.\\n\" + \"**\\n\" + \"** Turn off autopublish by removing the autopublish package:\\n\" + \"**\\n\" + \"**   $ meteor remove autopublish\\n\" + \"**\\n\" + \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" + \"** for each collection that you want clients to see.\\n\");\n          }\n        }\n\n        if (name) self.publish_handlers[name] = handler;else {\n          self.universal_publish_handlers.push(handler);\n          // Spin up the new publisher on any existing session too. Run each\n          // session's subscription in a new Fiber, so that there's no change for\n          // self.sessions to change while we're running this loop.\n          _.each(self.sessions, function (session) {\n            if (!session._dontStartNewUniversalSubs) {\n              Fiber(function () {\n                session._startSubscription(handler);\n              }).run();\n            }\n          });\n        }\n      } else {\n        _.each(name, function (value, key) {\n          self.publish(key, value, {});\n        });\n      }\n    }\n\n    return publish;\n  }(),\n\n  _removeSession: function () {\n    function _removeSession(session) {\n      var self = this;\n      if (self.sessions[session.id]) {\n        delete self.sessions[session.id];\n      }\n    }\n\n    return _removeSession;\n  }(),\n\n  /**\n   * @summary Defines functions that can be invoked over the network by clients.\n   * @locus Anywhere\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  methods: function () {\n    function methods(_methods) {\n      var self = this;\n      _.each(_methods, function (func, name) {\n        if (typeof func !== 'function') throw new Error(\"Method '\" + name + \"' must be a function\");\n        if (self.method_handlers[name]) throw new Error(\"A method named '\" + name + \"' is already defined\");\n        self.method_handlers[name] = func;\n      });\n    }\n\n    return methods;\n  }(),\n\n  call: function () {\n    function call(name /*, arguments */) {\n      // if it's a function, the last argument is the result callback,\n      // not a parameter to the remote method.\n      var args = Array.prototype.slice.call(arguments, 1);\n      if (args.length && typeof args[args.length - 1] === \"function\") var callback = args.pop();\n      return this.apply(name, args, callback);\n    }\n\n    return call;\n  }(),\n\n  // @param options {Optional Object}\n  // @param callback {Optional Function}\n  apply: function () {\n    function apply(name, args, options, callback) {\n      var self = this;\n\n      // We were passed 3 arguments. They may be either (name, args, options)\n      // or (name, args, callback)\n      if (!callback && typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      options = options || {};\n\n      if (callback)\n        // It's not really necessary to do this, since we immediately\n        // run the callback in this fiber before returning, but we do it\n        // anyway for regularity.\n        // XXX improve error message (and how we report it)\n        callback = Meteor.bindEnvironment(callback, \"delivering result of invoking '\" + name + \"'\");\n\n      // Run the handler\n      var handler = self.method_handlers[name];\n      var exception;\n      if (!handler) {\n        exception = new Meteor.Error(404, \"Method '\" + name + \"' not found\");\n      } else {\n        // If this is a method call from within another method, get the\n        // user state from the outer method, otherwise don't allow\n        // setUserId to be called\n        var userId = null;\n        var setUserId = function () {\n          function setUserId() {\n            throw new Error(\"Can't call setUserId on a server initiated method call\");\n          }\n\n          return setUserId;\n        }();\n        var connection = null;\n        var currentInvocation = DDP._CurrentInvocation.get();\n        if (currentInvocation) {\n          userId = currentInvocation.userId;\n          setUserId = function () {\n            function setUserId(userId) {\n              currentInvocation.setUserId(userId);\n            }\n\n            return setUserId;\n          }();\n          connection = currentInvocation.connection;\n        }\n\n        var invocation = new DDPCommon.MethodInvocation({\n          isSimulation: false,\n          userId: userId,\n          setUserId: setUserId,\n          connection: connection,\n          randomSeed: DDPCommon.makeRpcSeed(currentInvocation, name)\n        });\n        try {\n          var result = DDP._CurrentInvocation.withValue(invocation, function () {\n            return maybeAuditArgumentChecks(handler, invocation, EJSON.clone(args), \"internal call to '\" + name + \"'\");\n          });\n          result = EJSON.clone(result);\n        } catch (e) {\n          exception = e;\n        }\n      }\n\n      // Return the result in whichever way the caller asked for it. Note that we\n      // do NOT block on the write fence in an analogous way to how the client\n      // blocks on the relevant data being visible, so you are NOT guaranteed that\n      // cursor observe callbacks have fired when your callback is invoked. (We\n      // can change this if there's a real use case.)\n      if (callback) {\n        callback(exception, result);\n        return undefined;\n      }\n      if (exception) throw exception;\n      return result;\n    }\n\n    return apply;\n  }(),\n\n  _urlForSession: function () {\n    function _urlForSession(sessionId) {\n      var self = this;\n      var session = self.sessions[sessionId];\n      if (session) return session._socketUrl;else return null;\n    }\n\n    return _urlForSession;\n  }()\n});\n\nvar calculateVersion = function calculateVersion(clientSupportedVersions, serverSupportedVersions) {\n  var correctVersion = _.find(clientSupportedVersions, function (version) {\n    return _.contains(serverSupportedVersions, version);\n  });\n  if (!correctVersion) {\n    correctVersion = serverSupportedVersions[0];\n  }\n  return correctVersion;\n};\n\nDDPServer._calculateVersion = calculateVersion;\n\n// \"blind\" exceptions other than those that were deliberately thrown to signal\n// errors to the client\nvar wrapInternalException = function wrapInternalException(exception, context) {\n  if (!exception || exception instanceof Meteor.Error) return exception;\n\n  // tests can set the 'expected' flag on an exception so it won't go to the\n  // server log\n  if (!exception.expected) {\n    Meteor._debug(\"Exception \" + context, exception.stack);\n    if (exception.sanitizedError) {\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError.message);\n      Meteor._debug();\n    }\n  }\n\n  // Did the error contain more details that could have been useful if caught in\n  // server code (or if thrown from non-client-originated code), but also\n  // provided a \"sanitized\" version with more context than 500 Internal server\n  // error? Use that.\n  if (exception.sanitizedError) {\n    if (exception.sanitizedError instanceof Meteor.Error) return exception.sanitizedError;\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" + \"is not a Meteor.Error; ignoring\");\n  }\n\n  return new Meteor.Error(500, \"Internal server error\");\n};\n\n// Audit argument checks, if the audit-argument-checks package exists (it is a\n// weak dependency of this package).\nvar maybeAuditArgumentChecks = function maybeAuditArgumentChecks(f, context, args, description) {\n  args = args || [];\n  if (Package['audit-argument-checks']) {\n    return Match._failIfArgumentsAreNotAllChecked(f, context, args, description);\n  }\n  return f.apply(context, args);\n};","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/livedata_server.js"],"names":["DDPServer","Fiber","Npm","require","SessionDocumentView","self","existsIn","dataByKey","_SessionDocumentView","_","extend","prototype","getFields","ret","each","precedenceList","key","value","clearField","subscriptionHandle","changeCollector","removedValue","undefined","i","length","precedence","splice","isEmpty","EJSON","equals","changeField","isAdd","clone","has","elt","find","push","SessionCollectionView","collectionName","sessionCallbacks","documents","callbacks","_SessionCollectionView","diff","previous","DiffSequence","diffObjects","both","bind","diffDocument","rightOnly","id","nowDV","added","leftOnly","prevDV","removed","fields","prev","now","changed","docView","changedResult","Error","err","Session","server","version","socket","options","Random","initialized","inQueue","Meteor","_DoubleEndedQueue","blocked","workerRunning","_namedSubs","_universalSubs","userId","collectionViews","_isSending","_dontStartNewUniversalSubs","_pendingReady","_closeCallbacks","_socketUrl","url","_respondToPings","respondToPings","connectionHandle","close","onClose","fn","cb","bindEnvironment","defer","clientAddress","_clientAddress","httpHeaders","headers","send","msg","session","startUniversalSubs","run","heartbeatInterval","heartbeat","DDPCommon","Heartbeat","heartbeatTimeout","onTimeout","sendPing","start","Package","facts","Facts","incrementServerFact","sendReady","subscriptionIds","subs","subscriptionId","sendAdded","collection","sendChanged","sendRemoved","getSendCallbacks","getCollectionView","view","handlers","universal_publish_handlers","handler","_startSubscription","stop","_meteorSession","_deactivateAllSubscriptions","callback","_removeSession","_printSentDDP","_debug","stringifyDDP","sendError","reason","offendingMessage","processMessage","msg_in","messageReceived","processNext","shift","unblock","protocol_handlers","call","sub","name","params","Array","publish_handlers","error","DDPRateLimiter","rateLimiterInput","type","connectionId","_increment","rateLimitResult","_check","allowed","getErrorMessage","timeToReset","unsub","_stopSubscription","method","randomSeed","fence","_WriteFence","onAllCommitted","retire","methods","method_handlers","arm","setUserId","_setUserId","invocation","MethodInvocation","isSimulation","connection","promise","Promise","resolve","reject","_CurrentWriteFence","withValue","DDP","_CurrentInvocation","maybeAuditArgumentChecks","finish","payload","then","result","exception","wrapInternalException","_eachSub","f","_diffCollectionViews","beforeCVs","leftValue","rightValue","doc","_deactivate","oldNamedSubs","_recreate","_runHandler","_noYieldsAllowed","subId","Subscription","subName","_name","_removeAllDocuments","response","httpForwardedCount","parseInt","process","env","remoteAddress","forwardedFor","isString","trim","split","_session","_handler","_subscriptionId","_params","_subscriptionHandle","_deactivated","_stopCallbacks","_documents","_ready","_idFilter","idStringify","MongoID","idParse","res","e","_isDeactivated","_publishHandlerResult","isCursor","c","_publishCursor","ready","isArray","all","collectionNames","_getCollectionName","cur","_callStopCallbacks","collectionDocs","keys","strId","onStop","_ensure","Server","defaults","onConnectionHook","Hook","debugPrintExceptions","sessions","stream_server","StreamServer","register","on","raw_msg","_printReceivedDDP","parseDDP","_handleConnect","message","stack","onConnection","support","contains","SUPPORTED_DDP_VERSIONS","calculateVersion","publish","isObject","autopublish","is_auto","warned_about_autopublish","func","args","slice","arguments","pop","apply","currentInvocation","get","makeRpcSeed","_urlForSession","sessionId","clientSupportedVersions","serverSupportedVersions","correctVersion","_calculateVersion","context","expected","sanitizedError","description","Match","_failIfArgumentsAreNotAllChecked"],"mappings":"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","file":"/packages/ddp-server/livedata_server.js.map","sourcesContent":["DDPServer = {};\n\nvar Fiber = Npm.require('fibers');\n\n// This file contains classes:\n// * Session - The server's connection to a single DDP client\n// * Subscription - A single subscription for a single client\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.\n//\n// Session and Subscription are file scope. For now, until we freeze\n// the interface, Server is package scope (in the future it should be\n// exported.)\n\n// Represents a single document in a SessionCollectionView\nvar SessionDocumentView = function () {\n  var self = this;\n  self.existsIn = {}; // set of subscriptionHandle\n  self.dataByKey = {}; // key-> [ {subscriptionHandle, value} by precedence]\n};\n\nDDPServer._SessionDocumentView = SessionDocumentView;\n\n\n_.extend(SessionDocumentView.prototype, {\n\n  getFields: function () {\n    var self = this;\n    var ret = {};\n    _.each(self.dataByKey, function (precedenceList, key) {\n      ret[key] = precedenceList[0].value;\n    });\n    return ret;\n  },\n\n  clearField: function (subscriptionHandle, key, changeCollector) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\")\n      return;\n    var precedenceList = self.dataByKey[key];\n\n    // It's okay to clear fields that didn't exist. No need to throw\n    // an error.\n    if (!precedenceList)\n      return;\n\n    var removedValue = undefined;\n    for (var i = 0; i < precedenceList.length; i++) {\n      var precedence = precedenceList[i];\n      if (precedence.subscriptionHandle === subscriptionHandle) {\n        // The view's value can only change if this subscription is the one that\n        // used to have precedence.\n        if (i === 0)\n          removedValue = precedence.value;\n        precedenceList.splice(i, 1);\n        break;\n      }\n    }\n    if (_.isEmpty(precedenceList)) {\n      delete self.dataByKey[key];\n      changeCollector[key] = undefined;\n    } else if (removedValue !== undefined &&\n               !EJSON.equals(removedValue, precedenceList[0].value)) {\n      changeCollector[key] = precedenceList[0].value;\n    }\n  },\n\n  changeField: function (subscriptionHandle, key, value,\n                         changeCollector, isAdd) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\")\n      return;\n\n    // Don't share state with the data passed in by the user.\n    value = EJSON.clone(value);\n\n    if (!_.has(self.dataByKey, key)) {\n      self.dataByKey[key] = [{subscriptionHandle: subscriptionHandle,\n                              value: value}];\n      changeCollector[key] = value;\n      return;\n    }\n    var precedenceList = self.dataByKey[key];\n    var elt;\n    if (!isAdd) {\n      elt = _.find(precedenceList, function (precedence) {\n        return precedence.subscriptionHandle === subscriptionHandle;\n      });\n    }\n\n    if (elt) {\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\n        // this subscription is changing the value of this field.\n        changeCollector[key] = value;\n      }\n      elt.value = value;\n    } else {\n      // this subscription is newly caring about this field\n      precedenceList.push({subscriptionHandle: subscriptionHandle, value: value});\n    }\n\n  }\n});\n\n/**\n * Represents a client's view of a single collection\n * @param {String} collectionName Name of the collection it represents\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed\n * @class SessionCollectionView\n */\nvar SessionCollectionView = function (collectionName, sessionCallbacks) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.documents = {};\n  self.callbacks = sessionCallbacks;\n};\n\nDDPServer._SessionCollectionView = SessionCollectionView;\n\n\n_.extend(SessionCollectionView.prototype, {\n\n  isEmpty: function () {\n    var self = this;\n    return _.isEmpty(self.documents);\n  },\n\n  diff: function (previous) {\n    var self = this;\n    DiffSequence.diffObjects(previous.documents, self.documents, {\n      both: _.bind(self.diffDocument, self),\n\n      rightOnly: function (id, nowDV) {\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());\n      },\n\n      leftOnly: function (id, prevDV) {\n        self.callbacks.removed(self.collectionName, id);\n      }\n    });\n  },\n\n  diffDocument: function (id, prevDV, nowDV) {\n    var self = this;\n    var fields = {};\n    DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {\n      both: function (key, prev, now) {\n        if (!EJSON.equals(prev, now))\n          fields[key] = now;\n      },\n      rightOnly: function (key, now) {\n        fields[key] = now;\n      },\n      leftOnly: function(key, prev) {\n        fields[key] = undefined;\n      }\n    });\n    self.callbacks.changed(self.collectionName, id, fields);\n  },\n\n  added: function (subscriptionHandle, id, fields) {\n    var self = this;\n    var docView = self.documents[id];\n    var added = false;\n    if (!docView) {\n      added = true;\n      docView = new SessionDocumentView();\n      self.documents[id] = docView;\n    }\n    docView.existsIn[subscriptionHandle] = true;\n    var changeCollector = {};\n    _.each(fields, function (value, key) {\n      docView.changeField(\n        subscriptionHandle, key, value, changeCollector, true);\n    });\n    if (added)\n      self.callbacks.added(self.collectionName, id, changeCollector);\n    else\n      self.callbacks.changed(self.collectionName, id, changeCollector);\n  },\n\n  changed: function (subscriptionHandle, id, changed) {\n    var self = this;\n    var changedResult = {};\n    var docView = self.documents[id];\n    if (!docView)\n      throw new Error(\"Could not find element with id \" + id + \" to change\");\n    _.each(changed, function (value, key) {\n      if (value === undefined)\n        docView.clearField(subscriptionHandle, key, changedResult);\n      else\n        docView.changeField(subscriptionHandle, key, value, changedResult);\n    });\n    self.callbacks.changed(self.collectionName, id, changedResult);\n  },\n\n  removed: function (subscriptionHandle, id) {\n    var self = this;\n    var docView = self.documents[id];\n    if (!docView) {\n      var err = new Error(\"Removed nonexistent document \" + id);\n      throw err;\n    }\n    delete docView.existsIn[subscriptionHandle];\n    if (_.isEmpty(docView.existsIn)) {\n      // it is gone from everyone\n      self.callbacks.removed(self.collectionName, id);\n      delete self.documents[id];\n    } else {\n      var changed = {};\n      // remove this subscription from every precedence list\n      // and record the changes\n      _.each(docView.dataByKey, function (precedenceList, key) {\n        docView.clearField(subscriptionHandle, key, changed);\n      });\n\n      self.callbacks.changed(self.collectionName, id, changed);\n    }\n  }\n});\n\n/******************************************************************************/\n/* Session                                                                    */\n/******************************************************************************/\n\nvar Session = function (server, version, socket, options) {\n  var self = this;\n  self.id = Random.id();\n\n  self.server = server;\n  self.version = version;\n\n  self.initialized = false;\n  self.socket = socket;\n\n  // set to null when the session is destroyed. multiple places below\n  // use this to determine if the session is alive or not.\n  self.inQueue = new Meteor._DoubleEndedQueue();\n\n  self.blocked = false;\n  self.workerRunning = false;\n\n  // Sub objects for active subscriptions\n  self._namedSubs = {};\n  self._universalSubs = [];\n\n  self.userId = null;\n\n  self.collectionViews = {};\n\n  // Set this to false to not send messages when collectionViews are\n  // modified. This is done when rerunning subs in _setUserId and those messages\n  // are calculated via a diff instead.\n  self._isSending = true;\n\n  // If this is true, don't start a newly-created universal publisher on this\n  // session. The session will take care of starting it when appropriate.\n  self._dontStartNewUniversalSubs = false;\n\n  // when we are rerunning subscriptions, any ready messages\n  // we want to buffer up for when we are done rerunning subscriptions\n  self._pendingReady = [];\n\n  // List of callbacks to call when this connection is closed.\n  self._closeCallbacks = [];\n\n\n  // XXX HACK: If a sockjs connection, save off the URL. This is\n  // temporary and will go away in the near future.\n  self._socketUrl = socket.url;\n\n  // Allow tests to disable responding to pings.\n  self._respondToPings = options.respondToPings;\n\n  // This object is the public interface to the session. In the public\n  // API, it is called the `connection` object.  Internally we call it\n  // a `connectionHandle` to avoid ambiguity.\n  self.connectionHandle = {\n    id: self.id,\n    close: function () {\n      self.close();\n    },\n    onClose: function (fn) {\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");\n      if (self.inQueue) {\n        self._closeCallbacks.push(cb);\n      } else {\n        // if we're already closed, call the callback.\n        Meteor.defer(cb);\n      }\n    },\n    clientAddress: self._clientAddress(),\n    httpHeaders: self.socket.headers\n  };\n\n  self.send({ msg: 'connected', session: self.id });\n\n  // On initial connect, spin up all the universal publishers.\n  Fiber(function () {\n    self.startUniversalSubs();\n  }).run();\n\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {\n    self.heartbeat = new DDPCommon.Heartbeat({\n      heartbeatInterval: options.heartbeatInterval,\n      heartbeatTimeout: options.heartbeatTimeout,\n      onTimeout: function () {\n        self.close();\n      },\n      sendPing: function () {\n        self.send({msg: 'ping'});\n      }\n    });\n    self.heartbeat.start();\n  }\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\n    \"livedata\", \"sessions\", 1);\n};\n\n_.extend(Session.prototype, {\n\n  sendReady: function (subscriptionIds) {\n    var self = this;\n    if (self._isSending)\n      self.send({msg: \"ready\", subs: subscriptionIds});\n    else {\n      _.each(subscriptionIds, function (subscriptionId) {\n        self._pendingReady.push(subscriptionId);\n      });\n    }\n  },\n\n  sendAdded: function (collectionName, id, fields) {\n    var self = this;\n    if (self._isSending)\n      self.send({msg: \"added\", collection: collectionName, id: id, fields: fields});\n  },\n\n  sendChanged: function (collectionName, id, fields) {\n    var self = this;\n    if (_.isEmpty(fields))\n      return;\n\n    if (self._isSending) {\n      self.send({\n        msg: \"changed\",\n        collection: collectionName,\n        id: id,\n        fields: fields\n      });\n    }\n  },\n\n  sendRemoved: function (collectionName, id) {\n    var self = this;\n    if (self._isSending)\n      self.send({msg: \"removed\", collection: collectionName, id: id});\n  },\n\n  getSendCallbacks: function () {\n    var self = this;\n    return {\n      added: _.bind(self.sendAdded, self),\n      changed: _.bind(self.sendChanged, self),\n      removed: _.bind(self.sendRemoved, self)\n    };\n  },\n\n  getCollectionView: function (collectionName) {\n    var self = this;\n    if (_.has(self.collectionViews, collectionName)) {\n      return self.collectionViews[collectionName];\n    }\n    var ret = new SessionCollectionView(collectionName,\n                                        self.getSendCallbacks());\n    self.collectionViews[collectionName] = ret;\n    return ret;\n  },\n\n  added: function (subscriptionHandle, collectionName, id, fields) {\n    var self = this;\n    var view = self.getCollectionView(collectionName);\n    view.added(subscriptionHandle, id, fields);\n  },\n\n  removed: function (subscriptionHandle, collectionName, id) {\n    var self = this;\n    var view = self.getCollectionView(collectionName);\n    view.removed(subscriptionHandle, id);\n    if (view.isEmpty()) {\n      delete self.collectionViews[collectionName];\n    }\n  },\n\n  changed: function (subscriptionHandle, collectionName, id, fields) {\n    var self = this;\n    var view = self.getCollectionView(collectionName);\n    view.changed(subscriptionHandle, id, fields);\n  },\n\n  startUniversalSubs: function () {\n    var self = this;\n    // Make a shallow copy of the set of universal handlers and start them. If\n    // additional universal publishers start while we're running them (due to\n    // yielding), they will run separately as part of Server.publish.\n    var handlers = _.clone(self.server.universal_publish_handlers);\n    _.each(handlers, function (handler) {\n      self._startSubscription(handler);\n    });\n  },\n\n  // Destroy this session and unregister it at the server.\n  close: function () {\n    var self = this;\n\n    // Destroy this session, even if it's not registered at the\n    // server. Stop all processing and tear everything down. If a socket\n    // was attached, close it.\n\n    // Already destroyed.\n    if (! self.inQueue)\n      return;\n\n    // Drop the merge box data immediately.\n    self.inQueue = null;\n    self.collectionViews = {};\n\n    if (self.heartbeat) {\n      self.heartbeat.stop();\n      self.heartbeat = null;\n    }\n\n    if (self.socket) {\n      self.socket.close();\n      self.socket._meteorSession = null;\n    }\n\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"livedata\", \"sessions\", -1);\n\n    Meteor.defer(function () {\n      // stop callbacks can yield, so we defer this on close.\n      // sub._isDeactivated() detects that we set inQueue to null and\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\n      self._deactivateAllSubscriptions();\n\n      // Defer calling the close callbacks, so that the caller closing\n      // the session isn't waiting for all the callbacks to complete.\n      _.each(self._closeCallbacks, function (callback) {\n        callback();\n      });\n    });\n\n    // Unregister the session.\n    self.server._removeSession(self);\n  },\n\n  // Send a message (doing nothing if no socket is connected right now.)\n  // It should be a JSON object (it will be stringified.)\n  send: function (msg) {\n    var self = this;\n    if (self.socket) {\n      if (Meteor._printSentDDP)\n        Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));\n      self.socket.send(DDPCommon.stringifyDDP(msg));\n    }\n  },\n\n  // Send a connection error.\n  sendError: function (reason, offendingMessage) {\n    var self = this;\n    var msg = {msg: 'error', reason: reason};\n    if (offendingMessage)\n      msg.offendingMessage = offendingMessage;\n    self.send(msg);\n  },\n\n  // Process 'msg' as an incoming message. (But as a guard against\n  // race conditions during reconnection, ignore the message if\n  // 'socket' is not the currently connected socket.)\n  //\n  // We run the messages from the client one at a time, in the order\n  // given by the client. The message handler is passed an idempotent\n  // function 'unblock' which it may call to allow other messages to\n  // begin running in parallel in another fiber (for example, a method\n  // that wants to yield.) Otherwise, it is automatically unblocked\n  // when it returns.\n  //\n  // Actually, we don't have to 'totally order' the messages in this\n  // way, but it's the easiest thing that's correct. (unsub needs to\n  // be ordered against sub, methods need to be ordered against each\n  // other.)\n  processMessage: function (msg_in) {\n    var self = this;\n    if (!self.inQueue) // we have been destroyed.\n      return;\n\n    // Respond to ping and pong messages immediately without queuing.\n    // If the negotiated DDP version is \"pre1\" which didn't support\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad\n    // request\" for the unknown messages.\n    //\n    // Fibers are needed because heartbeat uses Meteor.setTimeout, which\n    // needs a Fiber. We could actually use regular setTimeout and avoid\n    // these new fibers, but it is easier to just make everything use\n    // Meteor.setTimeout and not think too hard.\n    //\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the client is still alive.\n    if (self.heartbeat) {\n      Fiber(function () {\n        self.heartbeat.messageReceived();\n      }).run();\n    }\n\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {\n      if (self._respondToPings)\n        self.send({msg: \"pong\", id: msg_in.id});\n      return;\n    }\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {\n      // Since everything is a pong, nothing to do\n      return;\n    }\n\n    self.inQueue.push(msg_in);\n    if (self.workerRunning)\n      return;\n    self.workerRunning = true;\n\n    var processNext = function () {\n      var msg = self.inQueue && self.inQueue.shift();\n      if (!msg) {\n        self.workerRunning = false;\n        return;\n      }\n\n      Fiber(function () {\n        var blocked = true;\n\n        var unblock = function () {\n          if (!blocked)\n            return; // idempotent\n          blocked = false;\n          processNext();\n        };\n\n        if (_.has(self.protocol_handlers, msg.msg))\n          self.protocol_handlers[msg.msg].call(self, msg, unblock);\n        else\n          self.sendError('Bad request', msg);\n        unblock(); // in case the handler didn't already do it\n      }).run();\n    };\n\n    processNext();\n  },\n\n  protocol_handlers: {\n    sub: function (msg) {\n      var self = this;\n\n      // reject malformed messages\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.name) !== \"string\" ||\n          (('params' in msg) && !(msg.params instanceof Array))) {\n        self.sendError(\"Malformed subscription\", msg);\n        return;\n      }\n\n      if (!self.server.publish_handlers[msg.name]) {\n        self.send({\n          msg: 'nosub', id: msg.id,\n          error: new Meteor.Error(404, `Subscription '${msg.name}' not found`)});\n        return;\n      }\n\n      if (_.has(self._namedSubs, msg.id))\n        // subs are idempotent, or rather, they are ignored if a sub\n        // with that id already exists. this is important during\n        // reconnect.\n        return;\n\n      // XXX It'd be much better if we had generic hooks where any package can\n      // hook into subscription handling, but in the mean while we special case\n      // ddp-rate-limiter package. This is also done for weak requirements to\n      // add the ddp-rate-limiter package in case we don't have Accounts. A\n      // user trying to use the ddp-rate-limiter must explicitly require it.\n      if (Package['ddp-rate-limiter']) {\n        var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n        var rateLimiterInput = {\n          userId: self.userId,\n          clientAddress: self.connectionHandle.clientAddress,\n          type: \"subscription\",\n          name: msg.name,\n          connectionId: self.id\n        };\n\n        DDPRateLimiter._increment(rateLimiterInput);\n        var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n        if (!rateLimitResult.allowed) {\n          self.send({\n            msg: 'nosub', id: msg.id,\n            error: new Meteor.Error(\n              'too-many-requests',\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset})\n          });\n          return;\n        }\n      }\n\n      var handler = self.server.publish_handlers[msg.name];\n\n      self._startSubscription(handler, msg.id, msg.params, msg.name);\n\n    },\n\n    unsub: function (msg) {\n      var self = this;\n\n      self._stopSubscription(msg.id);\n    },\n\n    method: function (msg, unblock) {\n      var self = this;\n\n      // reject malformed messages\n      // For now, we silently ignore unknown attributes,\n      // for forwards compatibility.\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.method) !== \"string\" ||\n          (('params' in msg) && !(msg.params instanceof Array)) ||\n          (('randomSeed' in msg) && (typeof msg.randomSeed !== \"string\"))) {\n        self.sendError(\"Malformed method invocation\", msg);\n        return;\n      }\n\n      var randomSeed = msg.randomSeed || null;\n\n      // set up to mark the method as satisfied once all observers\n      // (and subscriptions) have reacted to any writes that were\n      // done.\n      var fence = new DDPServer._WriteFence;\n      fence.onAllCommitted(function () {\n        // Retire the fence so that future writes are allowed.\n        // This means that callbacks like timers are free to use\n        // the fence, and if they fire before it's armed (for\n        // example, because the method waits for them) their\n        // writes will be included in the fence.\n        fence.retire();\n        self.send({\n          msg: 'updated', methods: [msg.id]});\n      });\n\n      // find the handler\n      var handler = self.server.method_handlers[msg.method];\n      if (!handler) {\n        self.send({\n          msg: 'result', id: msg.id,\n          error: new Meteor.Error(404, `Method '${msg.method}' not found`)});\n        fence.arm();\n        return;\n      }\n\n      var setUserId = function(userId) {\n        self._setUserId(userId);\n      };\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: false,\n        userId: self.userId,\n        setUserId: setUserId,\n        unblock: unblock,\n        connection: self.connectionHandle,\n        randomSeed: randomSeed\n      });\n\n      const promise = new Promise((resolve, reject) => {\n        // XXX It'd be better if we could hook into method handlers better but\n        // for now, we need to check if the ddp-rate-limiter exists since we\n        // have a weak requirement for the ddp-rate-limiter package to be added\n        // to our application.\n        if (Package['ddp-rate-limiter']) {\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n          var rateLimiterInput = {\n            userId: self.userId,\n            clientAddress: self.connectionHandle.clientAddress,\n            type: \"method\",\n            name: msg.method,\n            connectionId: self.id\n          };\n          DDPRateLimiter._increment(rateLimiterInput);\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput)\n          if (!rateLimitResult.allowed) {\n            reject(new Meteor.Error(\n              \"too-many-requests\",\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset}\n            ));\n            return;\n          }\n        }\n\n        resolve(DDPServer._CurrentWriteFence.withValue(\n          fence,\n          () => DDP._CurrentInvocation.withValue(\n            invocation,\n            () => maybeAuditArgumentChecks(\n              handler, invocation, msg.params,\n              \"call to '\" + msg.method + \"'\"\n            )\n          )\n        ));\n      });\n\n      function finish() {\n        fence.arm();\n        unblock();\n      }\n\n      const payload = {\n        msg: \"result\",\n        id: msg.id\n      };\n\n      promise.then((result) => {\n        finish();\n        if (result !== undefined) {\n          payload.result = result;\n        }\n        self.send(payload);\n      }, (exception) => {\n        finish();\n        payload.error = wrapInternalException(\n          exception,\n          `while invoking method '${msg.method}'`\n        );\n        self.send(payload);\n      });\n    }\n  },\n\n  _eachSub: function (f) {\n    var self = this;\n    _.each(self._namedSubs, f);\n    _.each(self._universalSubs, f);\n  },\n\n  _diffCollectionViews: function (beforeCVs) {\n    var self = this;\n    DiffSequence.diffObjects(beforeCVs, self.collectionViews, {\n      both: function (collectionName, leftValue, rightValue) {\n        rightValue.diff(leftValue);\n      },\n      rightOnly: function (collectionName, rightValue) {\n        _.each(rightValue.documents, function (docView, id) {\n          self.sendAdded(collectionName, id, docView.getFields());\n        });\n      },\n      leftOnly: function (collectionName, leftValue) {\n        _.each(leftValue.documents, function (doc, id) {\n          self.sendRemoved(collectionName, id);\n        });\n      }\n    });\n  },\n\n  // Sets the current user id in all appropriate contexts and reruns\n  // all subscriptions\n  _setUserId: function(userId) {\n    var self = this;\n\n    if (userId !== null && typeof userId !== \"string\")\n      throw new Error(\"setUserId must be called on string or null, not \" +\n                      typeof userId);\n\n    // Prevent newly-created universal subscriptions from being added to our\n    // session; they will be found below when we call startUniversalSubs.\n    //\n    // (We don't have to worry about named subscriptions, because we only add\n    // them when we process a 'sub' message. We are currently processing a\n    // 'method' message, and the method did not unblock, because it is illegal\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a\n    // new named subscription.)\n    self._dontStartNewUniversalSubs = true;\n\n    // Prevent current subs from updating our collectionViews and call their\n    // stop callbacks. This may yield.\n    self._eachSub(function (sub) {\n      sub._deactivate();\n    });\n\n    // All subs should now be deactivated. Stop sending messages to the client,\n    // save the state of the published collections, reset to an empty view, and\n    // update the userId.\n    self._isSending = false;\n    var beforeCVs = self.collectionViews;\n    self.collectionViews = {};\n    self.userId = userId;\n\n    // Save the old named subs, and reset to having no subscriptions.\n    var oldNamedSubs = self._namedSubs;\n    self._namedSubs = {};\n    self._universalSubs = [];\n\n    _.each(oldNamedSubs, function (sub, subscriptionId) {\n      self._namedSubs[subscriptionId] = sub._recreate();\n      // nb: if the handler throws or calls this.error(), it will in fact\n      // immediately send its 'nosub'. This is OK, though.\n      self._namedSubs[subscriptionId]._runHandler();\n    });\n\n    // Allow newly-created universal subs to be started on our connection in\n    // parallel with the ones we're spinning up here, and spin up universal\n    // subs.\n    self._dontStartNewUniversalSubs = false;\n    self.startUniversalSubs();\n\n    // Start sending messages again, beginning with the diff from the previous\n    // state of the world to the current state. No yields are allowed during\n    // this diff, so that other changes cannot interleave.\n    Meteor._noYieldsAllowed(function () {\n      self._isSending = true;\n      self._diffCollectionViews(beforeCVs);\n      if (!_.isEmpty(self._pendingReady)) {\n        self.sendReady(self._pendingReady);\n        self._pendingReady = [];\n      }\n    });\n  },\n\n  _startSubscription: function (handler, subId, params, name) {\n    var self = this;\n\n    var sub = new Subscription(\n      self, handler, subId, params, name);\n    if (subId)\n      self._namedSubs[subId] = sub;\n    else\n      self._universalSubs.push(sub);\n\n    sub._runHandler();\n  },\n\n  // tear down specified subscription\n  _stopSubscription: function (subId, error) {\n    var self = this;\n\n    var subName = null;\n\n    if (subId && self._namedSubs[subId]) {\n      subName = self._namedSubs[subId]._name;\n      self._namedSubs[subId]._removeAllDocuments();\n      self._namedSubs[subId]._deactivate();\n      delete self._namedSubs[subId];\n    }\n\n    var response = {msg: 'nosub', id: subId};\n\n    if (error) {\n      response.error = wrapInternalException(\n        error,\n        subName ? (\"from sub \" + subName + \" id \" + subId)\n          : (\"from sub id \" + subId));\n    }\n\n    self.send(response);\n  },\n\n  // tear down all subscriptions. Note that this does NOT send removed or nosub\n  // messages, since we assume the client is gone.\n  _deactivateAllSubscriptions: function () {\n    var self = this;\n\n    _.each(self._namedSubs, function (sub, id) {\n      sub._deactivate();\n    });\n    self._namedSubs = {};\n\n    _.each(self._universalSubs, function (sub) {\n      sub._deactivate();\n    });\n    self._universalSubs = [];\n  },\n\n  // Determine the remote client's IP address, based on the\n  // HTTP_FORWARDED_COUNT environment variable representing how many\n  // proxies the server is behind.\n  _clientAddress: function () {\n    var self = this;\n\n    // For the reported client address for a connection to be correct,\n    // the developer must set the HTTP_FORWARDED_COUNT environment\n    // variable to an integer representing the number of hops they\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the\n    // server is behind one proxy.\n    //\n    // This could be computed once at startup instead of every time.\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\n\n    if (httpForwardedCount === 0)\n      return self.socket.remoteAddress;\n\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];\n    if (! _.isString(forwardedFor))\n      return null;\n    forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);\n\n    // Typically the first value in the `x-forwarded-for` header is\n    // the original IP address of the client connecting to the first\n    // proxy.  However, the end user can easily spoof the header, in\n    // which case the first value(s) will be the fake IP address from\n    // the user pretending to be a proxy reporting the original IP\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the\n    // end of the list, we ensure that we get the IP address being\n    // reported by *our* first proxy.\n\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length)\n      return null;\n\n    return forwardedFor[forwardedFor.length - httpForwardedCount];\n  }\n});\n\n/******************************************************************************/\n/* Subscription                                                               */\n/******************************************************************************/\n\n// ctor for a sub handle: the input to each publish function\n\n// Instance name is this because it's usually referred to as this inside a\n// publish\n/**\n * @summary The server's side of a subscription\n * @class Subscription\n * @instanceName this\n */\nvar Subscription = function (\n    session, handler, subscriptionId, params, name) {\n  var self = this;\n  self._session = session; // type is Session\n\n  /**\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server\n   * @name  connection\n   * @memberOf Subscription\n   * @instance\n   */\n  self.connection = session.connectionHandle; // public API object\n\n  self._handler = handler;\n\n  // my subscription ID (generated by client, undefined for universal subs).\n  self._subscriptionId = subscriptionId;\n  // undefined for universal subs\n  self._name = name;\n\n  self._params = params || [];\n\n  // Only named subscriptions have IDs, but we need some sort of string\n  // internally to keep track of all subscriptions inside\n  // SessionDocumentViews. We use this subscriptionHandle for that.\n  if (self._subscriptionId) {\n    self._subscriptionHandle = 'N' + self._subscriptionId;\n  } else {\n    self._subscriptionHandle = 'U' + Random.id();\n  }\n\n  // has _deactivate been called?\n  self._deactivated = false;\n\n  // stop callbacks to g/c this sub.  called w/ zero arguments.\n  self._stopCallbacks = [];\n\n  // the set of (collection, documentid) that this subscription has\n  // an opinion about\n  self._documents = {};\n\n  // remember if we are ready.\n  self._ready = false;\n\n  // Part of the public API: the user of this sub.\n\n  /**\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.\n   * @locus Server\n   * @memberOf Subscription\n   * @name  userId\n   * @instance\n   */\n  self.userId = session.userId;\n\n  // For now, the id filter is going to default to\n  // the to/from DDP methods on MongoID, to\n  // specifically deal with mongo/minimongo ObjectIds.\n\n  // Later, you will be able to make this be \"raw\"\n  // if you want to publish a collection that you know\n  // just has strings for keys and no funny business, to\n  // a ddp consumer that isn't minimongo\n\n  self._idFilter = {\n    idStringify: MongoID.idStringify,\n    idParse: MongoID.idParse\n  };\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\n    \"livedata\", \"subscriptions\", 1);\n};\n\n_.extend(Subscription.prototype, {\n  _runHandler: function () {\n    // XXX should we unblock() here? Either before running the publish\n    // function, or before running _publishCursor.\n    //\n    // Right now, each publish function blocks all future publishes and\n    // methods waiting on data from Mongo (or whatever else the function\n    // blocks on). This probably slows page load in common cases.\n\n    var self = this;\n    try {\n      var res = maybeAuditArgumentChecks(\n        self._handler, self, EJSON.clone(self._params),\n        // It's OK that this would look weird for universal subscriptions,\n        // because they have no arguments so there can never be an\n        // audit-argument-checks failure.\n        \"publisher '\" + self._name + \"'\");\n    } catch (e) {\n      self.error(e);\n      return;\n    }\n\n    // Did the handler call this.error or this.stop?\n    if (self._isDeactivated())\n      return;\n\n    self._publishHandlerResult(res);\n  },\n\n  _publishHandlerResult: function (res) {\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke\n    // this.added/changed/ready/etc, the user can just return a collection\n    // cursor or array of cursors from the publish function; we call their\n    // _publishCursor method which starts observing the cursor and publishes the\n    // results. Note that _publishCursor does NOT call ready().\n    //\n    // XXX This uses an undocumented interface which only the Mongo cursor\n    // interface publishes. Should we make this interface public and encourage\n    // users to implement it themselves? Arguably, it's unnecessary; users can\n    // already write their own functions like\n    //   var publishMyReactiveThingy = function (name, handler) {\n    //     Meteor.publish(name, function () {\n    //       var reactiveThingy = handler();\n    //       reactiveThingy.publishMe();\n    //     });\n    //   };\n\n    var self = this;\n    var isCursor = function (c) {\n      return c && c._publishCursor;\n    };\n    if (isCursor(res)) {\n      try {\n        res._publishCursor(self);\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      // _publishCursor only returns after the initial added callbacks have run.\n      // mark subscription as ready.\n      self.ready();\n    } else if (_.isArray(res)) {\n      // check all the elements are cursors\n      if (! _.all(res, isCursor)) {\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));\n        return;\n      }\n      // find duplicate collection names\n      // XXX we should support overlapping cursors, but that would require the\n      // merge box to allow overlap within a subscription\n      var collectionNames = {};\n      for (var i = 0; i < res.length; ++i) {\n        var collectionName = res[i]._getCollectionName();\n        if (_.has(collectionNames, collectionName)) {\n          self.error(new Error(\n            \"Publish function returned multiple cursors for collection \" +\n              collectionName));\n          return;\n        }\n        collectionNames[collectionName] = true;\n      };\n\n      try {\n        _.each(res, function (cur) {\n          cur._publishCursor(self);\n        });\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      self.ready();\n    } else if (res) {\n      // truthy values other than cursors or arrays are probably a\n      // user mistake (possible returning a Mongo document via, say,\n      // `coll.findOne()`).\n      self.error(new Error(\"Publish function can only return a Cursor or \"\n                           + \"an array of Cursors\"));\n    }\n  },\n\n  // This calls all stop callbacks and prevents the handler from updating any\n  // SessionCollectionViews further. It's used when the user unsubscribes or\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send\n  // removed messages for the published objects; if that is necessary, call\n  // _removeAllDocuments first.\n  _deactivate: function() {\n    var self = this;\n    if (self._deactivated)\n      return;\n    self._deactivated = true;\n    self._callStopCallbacks();\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"livedata\", \"subscriptions\", -1);\n  },\n\n  _callStopCallbacks: function () {\n    var self = this;\n    // tell listeners, so they can clean up\n    var callbacks = self._stopCallbacks;\n    self._stopCallbacks = [];\n    _.each(callbacks, function (callback) {\n      callback();\n    });\n  },\n\n  // Send remove messages for every document.\n  _removeAllDocuments: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      _.each(self._documents, function(collectionDocs, collectionName) {\n        // Iterate over _.keys instead of the dictionary itself, since we'll be\n        // mutating it.\n        _.each(_.keys(collectionDocs), function (strId) {\n          self.removed(collectionName, self._idFilter.idParse(strId));\n        });\n      });\n    });\n  },\n\n  // Returns a new Subscription for the same session with the same\n  // initial creation parameters. This isn't a clone: it doesn't have\n  // the same _documents cache, stopped state or callbacks; may have a\n  // different _subscriptionHandle, and gets its userId from the\n  // session, not from this object.\n  _recreate: function () {\n    var self = this;\n    return new Subscription(\n      self._session, self._handler, self._subscriptionId, self._params,\n      self._name);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server\n   * @param {Error} error The error to pass to the client.\n   * @instance\n   * @memberOf Subscription\n   */\n  error: function (error) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId, error);\n  },\n\n  // Note that while our DDP client will notice that you've called stop() on the\n  // server (and clean up its _subscriptions table) we don't actually provide a\n  // mechanism for an app to notice this (the subscribe onError callback only\n  // triggers if there is an error).\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server\n   * @instance\n   * @memberOf Subscription\n   */\n  stop: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {Function} func The callback function\n   */\n  onStop: function (callback) {\n    var self = this;\n    if (self._isDeactivated())\n      callback();\n    else\n      self._stopCallbacks.push(callback);\n  },\n\n  // This returns true if the sub has been deactivated, *OR* if the session was\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\n  // happened yet.\n  _isDeactivated: function () {\n    var self = this;\n    return self._deactivated || self._session.inQueue === null;\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the new document.\n   * @param {String} id The new document's ID.\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.\n   */\n  added: function (collectionName, id, fields) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    id = self._idFilter.idStringify(id);\n    Meteor._ensure(self._documents, collectionName)[id] = true;\n    self._session.added(self._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the changed document.\n   * @param {String} id The changed document's ID.\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */\n  changed: function (collectionName, id, fields) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    id = self._idFilter.idStringify(id);\n    self._session.changed(self._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that the document has been removed from.\n   * @param {String} id The ID of the document that has been removed.\n   */\n  removed: function (collectionName, id) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    id = self._idFilter.idStringify(id);\n    // We don't bother to delete sets of things in a collection if the\n    // collection is empty.  It could break _removeAllDocuments.\n    delete self._documents[collectionName][id];\n    self._session.removed(self._subscriptionHandle, collectionName, id);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   */\n  ready: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    if (!self._subscriptionId)\n      return;  // unnecessary but ignored for universal sub\n    if (!self._ready) {\n      self._session.sendReady([self._subscriptionId]);\n      self._ready = true;\n    }\n  }\n});\n\n/******************************************************************************/\n/* Server                                                                     */\n/******************************************************************************/\n\nServer = function (options) {\n  var self = this;\n\n  // The default heartbeat interval is 30 seconds on the server and 35\n  // seconds on the client.  Since the client doesn't need to send a\n  // ping as long as it is receiving pings, this means that pings\n  // normally go from the server to the client.\n  //\n  // Note: Troposphere depends on the ability to mutate\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n  self.options = _.defaults(options || {}, {\n    heartbeatInterval: 15000,\n    heartbeatTimeout: 15000,\n    // For testing, allow responding to pings to be disabled.\n    respondToPings: true\n  });\n\n  // Map of callbacks to call when a new connection comes in to the\n  // server and completes DDP version negotiation. Use an object instead\n  // of an array so we can safely remove one from the list while\n  // iterating over it.\n  self.onConnectionHook = new Hook({\n    debugPrintExceptions: \"onConnection callback\"\n  });\n\n  self.publish_handlers = {};\n  self.universal_publish_handlers = [];\n\n  self.method_handlers = {};\n\n  self.sessions = {}; // map from id to session\n\n  self.stream_server = new StreamServer;\n\n  self.stream_server.register(function (socket) {\n    // socket implements the SockJSConnection interface\n    socket._meteorSession = null;\n\n    var sendError = function (reason, offendingMessage) {\n      var msg = {msg: 'error', reason: reason};\n      if (offendingMessage)\n        msg.offendingMessage = offendingMessage;\n      socket.send(DDPCommon.stringifyDDP(msg));\n    };\n\n    socket.on('data', function (raw_msg) {\n      if (Meteor._printReceivedDDP) {\n        Meteor._debug(\"Received DDP\", raw_msg);\n      }\n      try {\n        try {\n          var msg = DDPCommon.parseDDP(raw_msg);\n        } catch (err) {\n          sendError('Parse error');\n          return;\n        }\n        if (msg === null || !msg.msg) {\n          sendError('Bad request', msg);\n          return;\n        }\n\n        if (msg.msg === 'connect') {\n          if (socket._meteorSession) {\n            sendError(\"Already connected\", msg);\n            return;\n          }\n          Fiber(function () {\n            self._handleConnect(socket, msg);\n          }).run();\n          return;\n        }\n\n        if (!socket._meteorSession) {\n          sendError('Must connect first', msg);\n          return;\n        }\n        socket._meteorSession.processMessage(msg);\n      } catch (e) {\n        // XXX print stack nicely\n        Meteor._debug(\"Internal exception while processing message\", msg,\n                      e.message, e.stack);\n      }\n    });\n\n    socket.on('close', function () {\n      if (socket._meteorSession) {\n        Fiber(function () {\n          socket._meteorSession.close();\n        }).run();\n      }\n    });\n  });\n};\n\n_.extend(Server.prototype, {\n\n  /**\n   * @summary Register a callback to be called when a new DDP connection is made to the server.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP connection is established.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onConnection: function (fn) {\n    var self = this;\n    return self.onConnectionHook.register(fn);\n  },\n\n  _handleConnect: function (socket, msg) {\n    var self = this;\n\n    // The connect message must specify a version and an array of supported\n    // versions, and it must claim to support what it is proposing.\n    if (!(typeof (msg.version) === 'string' &&\n          _.isArray(msg.support) &&\n          _.all(msg.support, _.isString) &&\n          _.contains(msg.support, msg.version))) {\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed',\n                                version: DDPCommon.SUPPORTED_DDP_VERSIONS[0]}));\n      socket.close();\n      return;\n    }\n\n    // In the future, handle session resumption: something like:\n    //  socket._meteorSession = self.sessions[msg.session]\n    var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);\n\n    if (msg.version !== version) {\n      // The best version to use (according to the client's stated preferences)\n      // is not the one the client is trying to use. Inform them about the best\n      // version to use.\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed', version: version}));\n      socket.close();\n      return;\n    }\n\n    // Yay, version matches! Create a new session.\n    // Note: Troposphere depends on the ability to mutate\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n    socket._meteorSession = new Session(self, version, socket, self.options);\n    self.sessions[socket._meteorSession.id] = socket._meteorSession;\n    self.onConnectionHook.each(function (callback) {\n      if (socket._meteorSession)\n        callback(socket._meteorSession.connectionHandle);\n      return true;\n    });\n  },\n  /**\n   * Register a publish handler function.\n   *\n   * @param name {String} identifier for query\n   * @param handler {Function} publish handler\n   * @param options {Object}\n   *\n   * Server will call handler function on each new subscription,\n   * either when receiving DDP sub message for a named subscription, or on\n   * DDP connect for a universal subscription.\n   *\n   * If name is null, this will be a subscription that is\n   * automatically established and permanently on for all connected\n   * client, instead of a subscription that can be turned on and off\n   * with subscribe().\n   *\n   * options to contain:\n   *  - (mostly internal) is_auto: true if generated automatically\n   *    from an autopublish hook. this is for cosmetic purposes only\n   *    (it lets us determine whether to print a warning suggesting\n   *    that you turn off autopublish.)\n   */\n\n  /**\n   * @summary Publish a record set.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @locus Server\n   * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */\n  publish: function (name, handler, options) {\n    var self = this;\n\n    if (! _.isObject(name)) {\n      options = options || {};\n\n      if (name && name in self.publish_handlers) {\n        Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");\n        return;\n      }\n\n      if (Package.autopublish && !options.is_auto) {\n        // They have autopublish on, yet they're trying to manually\n        // picking stuff to publish. They probably should turn off\n        // autopublish. (This check isn't perfect -- if you create a\n        // publish before you turn on autopublish, it won't catch\n        // it. But this will definitely handle the simple case where\n        // you've added the autopublish package to your app, and are\n        // calling publish from your app code.)\n        if (!self.warned_about_autopublish) {\n          self.warned_about_autopublish = true;\n          Meteor._debug(\n    \"** You've set up some data subscriptions with Meteor.publish(), but\\n\" +\n    \"** you still have autopublish turned on. Because autopublish is still\\n\" +\n    \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" +\n    \"** will still be sent to all clients.\\n\" +\n    \"**\\n\" +\n    \"** Turn off autopublish by removing the autopublish package:\\n\" +\n    \"**\\n\" +\n    \"**   $ meteor remove autopublish\\n\" +\n    \"**\\n\" +\n    \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" +\n    \"** for each collection that you want clients to see.\\n\");\n        }\n      }\n\n      if (name)\n        self.publish_handlers[name] = handler;\n      else {\n        self.universal_publish_handlers.push(handler);\n        // Spin up the new publisher on any existing session too. Run each\n        // session's subscription in a new Fiber, so that there's no change for\n        // self.sessions to change while we're running this loop.\n        _.each(self.sessions, function (session) {\n          if (!session._dontStartNewUniversalSubs) {\n            Fiber(function() {\n              session._startSubscription(handler);\n            }).run();\n          }\n        });\n      }\n    }\n    else{\n      _.each(name, function(value, key) {\n        self.publish(key, value, {});\n      });\n    }\n  },\n\n  _removeSession: function (session) {\n    var self = this;\n    if (self.sessions[session.id]) {\n      delete self.sessions[session.id];\n    }\n  },\n\n  /**\n   * @summary Defines functions that can be invoked over the network by clients.\n   * @locus Anywhere\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  methods: function (methods) {\n    var self = this;\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function')\n        throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self.method_handlers[name])\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self.method_handlers[name] = func;\n    });\n  },\n\n  call: function (name /*, arguments */) {\n    // if it's a function, the last argument is the result callback,\n    // not a parameter to the remote method.\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (args.length && typeof args[args.length - 1] === \"function\")\n      var callback = args.pop();\n    return this.apply(name, args, callback);\n  },\n\n  // @param options {Optional Object}\n  // @param callback {Optional Function}\n  apply: function (name, args, options, callback) {\n    var self = this;\n\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = options || {};\n\n    if (callback)\n      // It's not really necessary to do this, since we immediately\n      // run the callback in this fiber before returning, but we do it\n      // anyway for regularity.\n      // XXX improve error message (and how we report it)\n      callback = Meteor.bindEnvironment(\n        callback,\n        \"delivering result of invoking '\" + name + \"'\"\n      );\n\n    // Run the handler\n    var handler = self.method_handlers[name];\n    var exception;\n    if (!handler) {\n      exception = new Meteor.Error(404, `Method '${name}' not found`);\n    } else {\n      // If this is a method call from within another method, get the\n      // user state from the outer method, otherwise don't allow\n      // setUserId to be called\n      var userId = null;\n      var setUserId = function() {\n        throw new Error(\"Can't call setUserId on a server initiated method call\");\n      };\n      var connection = null;\n      var currentInvocation = DDP._CurrentInvocation.get();\n      if (currentInvocation) {\n        userId = currentInvocation.userId;\n        setUserId = function(userId) {\n          currentInvocation.setUserId(userId);\n        };\n        connection = currentInvocation.connection;\n      }\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: false,\n        userId: userId,\n        setUserId: setUserId,\n        connection: connection,\n        randomSeed: DDPCommon.makeRpcSeed(currentInvocation, name)\n      });\n      try {\n        var result = DDP._CurrentInvocation.withValue(invocation, function () {\n          return maybeAuditArgumentChecks(\n            handler, invocation, EJSON.clone(args), \"internal call to '\" +\n              name + \"'\");\n        });\n        result = EJSON.clone(result);\n      } catch (e) {\n        exception = e;\n      }\n    }\n\n    // Return the result in whichever way the caller asked for it. Note that we\n    // do NOT block on the write fence in an analogous way to how the client\n    // blocks on the relevant data being visible, so you are NOT guaranteed that\n    // cursor observe callbacks have fired when your callback is invoked. (We\n    // can change this if there's a real use case.)\n    if (callback) {\n      callback(exception, result);\n      return undefined;\n    }\n    if (exception)\n      throw exception;\n    return result;\n  },\n\n  _urlForSession: function (sessionId) {\n    var self = this;\n    var session = self.sessions[sessionId];\n    if (session)\n      return session._socketUrl;\n    else\n      return null;\n  }\n});\n\nvar calculateVersion = function (clientSupportedVersions,\n                                 serverSupportedVersions) {\n  var correctVersion = _.find(clientSupportedVersions, function (version) {\n    return _.contains(serverSupportedVersions, version);\n  });\n  if (!correctVersion) {\n    correctVersion = serverSupportedVersions[0];\n  }\n  return correctVersion;\n};\n\nDDPServer._calculateVersion = calculateVersion;\n\n\n// \"blind\" exceptions other than those that were deliberately thrown to signal\n// errors to the client\nvar wrapInternalException = function (exception, context) {\n  if (!exception || exception instanceof Meteor.Error)\n    return exception;\n\n  // tests can set the 'expected' flag on an exception so it won't go to the\n  // server log\n  if (!exception.expected) {\n    Meteor._debug(\"Exception \" + context, exception.stack);\n    if (exception.sanitizedError) {\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError.message);\n      Meteor._debug();\n    }\n  }\n\n  // Did the error contain more details that could have been useful if caught in\n  // server code (or if thrown from non-client-originated code), but also\n  // provided a \"sanitized\" version with more context than 500 Internal server\n  // error? Use that.\n  if (exception.sanitizedError) {\n    if (exception.sanitizedError instanceof Meteor.Error)\n      return exception.sanitizedError;\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" +\n                  \"is not a Meteor.Error; ignoring\");\n  }\n\n  return new Meteor.Error(500, \"Internal server error\");\n};\n\n\n// Audit argument checks, if the audit-argument-checks package exists (it is a\n// weak dependency of this package).\nvar maybeAuditArgumentChecks = function (f, context, args, description) {\n  args = args || [];\n  if (Package['audit-argument-checks']) {\n    return Match._failIfArgumentsAreNotAllChecked(\n      f, context, args, description);\n  }\n  return f.apply(context, args);\n};\n"]},"hash":"435d3e82e11555334da8ad6b8e1516b93d39e18a"}
