{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ddp-server/livedata_server_tests.js","filenameRelative":"/packages/ddp-server/livedata_server_tests.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ddp-server/livedata_server_tests.js.map","sourceFileName":"/packages/ddp-server/livedata_server_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"livedata_server_tests"},"ignored":false,"code":"var Fiber = Npm.require('fibers');\n\nTinytest.addAsync(\"livedata server - connectionHandle.onClose()\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // On the server side, wait for the connection to be closed.\n    serverConn.onClose(function () {\n      test.isTrue(true);\n      // Add a new onClose after the connection is already\n      // closed. See that it fires.\n      serverConn.onClose(function () {\n        onComplete();\n      });\n    });\n    // Close the connection from the client.\n    clientConn.disconnect();\n  }, onComplete);\n});\n\nTinytest.addAsync(\"livedata server - connectionHandle.close()\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // Wait for the connection to be closed from the server side.\n    simplePoll(function () {\n      return !clientConn.status().connected;\n    }, onComplete, function () {\n      test.fail(\"timeout waiting for the connection to be closed on the server side\");\n      onComplete();\n    });\n\n    // Close the connection from the server.\n    serverConn.close();\n  }, onComplete);\n});\n\ntestAsyncMulti(\"livedata server - onConnection doesn't get callback after stop.\", [function (test, expect) {\n  var afterStop = false;\n  var expectStop1 = expect();\n  var stopHandle1 = Meteor.onConnection(function (conn) {\n    stopHandle2.stop();\n    stopHandle1.stop();\n    afterStop = true;\n    // yield to the event loop for a moment to see that no other calls\n    // to listener2 are called.\n    Meteor.setTimeout(expectStop1, 10);\n  });\n  var stopHandle2 = Meteor.onConnection(function (conn) {\n    test.isFalse(afterStop);\n  });\n\n  // trigger a connection\n  var expectConnection = expect();\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // Close the connection from the client.\n    clientConn.disconnect();\n    expectConnection();\n  }, expectConnection);\n}]);\n\nMeteor.methods({\n  livedata_server_test_inner: function () {\n    function livedata_server_test_inner() {\n      return this.connection.id;\n    }\n\n    return livedata_server_test_inner;\n  }(),\n\n  livedata_server_test_outer: function () {\n    function livedata_server_test_outer() {\n      return Meteor.call('livedata_server_test_inner');\n    }\n\n    return livedata_server_test_outer;\n  }()\n});\n\nTinytest.addAsync(\"livedata server - connection in method invocation\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    var res = clientConn.call('livedata_server_test_inner');\n    test.equal(res, serverConn.id);\n    clientConn.disconnect();\n    onComplete();\n  }, onComplete);\n});\n\nTinytest.addAsync(\"livedata server - connection in nested method invocation\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    var res = clientConn.call('livedata_server_test_outer');\n    test.equal(res, serverConn.id);\n    clientConn.disconnect();\n    onComplete();\n  }, onComplete);\n});\n\n// connectionId -> callback\nvar onSubscription = {};\n\nMeteor.publish(\"livedata_server_test_sub\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n  if (callback) callback(this);\n  this.stop();\n});\n\nTinytest.addAsync(\"livedata server - connection in publish function\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    onSubscription[serverConn.id] = function (subscription) {\n      delete onSubscription[serverConn.id];\n      test.equal(subscription.connection.id, serverConn.id);\n      clientConn.disconnect();\n      onComplete();\n    };\n    clientConn.subscribe(\"livedata_server_test_sub\", serverConn.id);\n  });\n});\n\nvar _onSubscriptions = {};\n\nMeteor.publish({\n  publicationObject: function () {\n    function publicationObject() {\n      var callback = _onSubscriptions;\n      if (callback) callback();\n      this.stop();\n    }\n\n    return publicationObject;\n  }()\n});\n\nMeteor.publish({\n  \"publication_object\": function () {\n    function publication_object() {\n      var callback = _onSubscriptions;\n      if (callback) callback();\n      this.stop();\n    }\n\n    return publication_object;\n  }()\n});\n\nMeteor.publish(\"publication_compatibility\", function () {\n  var callback = _onSubscriptions;\n  if (callback) callback();\n  this.stop();\n});\n\nTinytest.addAsync(\"livedata server - publish object\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    var testsLength = 0;\n\n    _onSubscriptions = function onSubscriptions(subscription) {\n      delete _onSubscriptions;\n      clientConn.disconnect();\n      testsLength++;\n      if (testsLength == 3) {\n        onComplete();\n      }\n    };\n    clientConn.subscribe(\"publicationObject\");\n    clientConn.subscribe(\"publication_object\");\n    clientConn.subscribe(\"publication_compatibility\");\n  });\n});\n\nMeteor.methods({\n  testResolvedPromise: function () {\n    function testResolvedPromise(arg) {\n      var invocation1 = DDP._CurrentInvocation.get();\n      return new Promise.resolve(arg).then(function (result) {\n        var invocation2 = DDP._CurrentInvocation.get();\n        // This equality holds because Promise callbacks are bound to the\n        // dynamic environment where .then was called.\n        if (invocation1 !== invocation2) {\n          throw new Meteor.Error(\"invocation mismatch\");\n        }\n        return result + \" after waiting\";\n      });\n    }\n\n    return testResolvedPromise;\n  }(),\n  testRejectedPromise: function () {\n    function testRejectedPromise(arg) {\n      return new Promise.resolve(arg).then(function (result) {\n        throw new Meteor.Error(result + \" raised Meteor.Error\");\n      });\n    }\n\n    return testRejectedPromise;\n  }()\n});\n\nTinytest.addAsync(\"livedata server - waiting for Promise\", function (test, onComplete) {\n  return makeTestConnection(test, function (clientConn, serverConn) {\n    test.equal(clientConn.call(\"testResolvedPromise\", \"clientConn.call\"), \"clientConn.call after waiting\");\n\n    var clientCallPromise = new Promise(function (resolve, reject) {\n      return clientConn.call(\"testResolvedPromise\", \"clientConn.call with callback\", function (error, result) {\n        return error ? reject(error) : resolve(result);\n      });\n    });\n\n    var clientCallRejectedPromise = new Promise(function (resolve) {\n      clientConn.call(\"testRejectedPromise\", \"with callback\", function (error, result) {\n        return resolve(error.message);\n      });\n    });\n\n    Promise.all([clientCallPromise, clientCallRejectedPromise]).then(function (results) {\n      return test.equal(results, [\"clientConn.call with callback after waiting\", \"[with callback raised Meteor.Error]\"]);\n    }, function (error) {\n      return test.fail(error);\n    }).then(onComplete);\n  });\n});","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/livedata_server_tests.js"],"names":["Fiber","Npm","require","Tinytest","addAsync","test","onComplete","makeTestConnection","clientConn","serverConn","onClose","isTrue","disconnect","simplePoll","status","connected","fail","close","testAsyncMulti","expect","afterStop","expectStop1","stopHandle1","Meteor","onConnection","conn","stopHandle2","stop","setTimeout","isFalse","expectConnection","methods","livedata_server_test_inner","connection","id","livedata_server_test_outer","call","res","equal","onSubscription","publish","connectionId","callback","subscription","subscribe","onSubscriptions","publicationObject","testsLength","testResolvedPromise","arg","invocation1","DDP","_CurrentInvocation","get","Promise","resolve","then","invocation2","Error","result","testRejectedPromise","clientCallPromise","reject","error","clientCallRejectedPromise","message","all","results"],"mappings":"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","file":"/packages/ddp-server/livedata_server_tests.js.map","sourcesContent":["var Fiber = Npm.require('fibers');\n\n\nTinytest.addAsync(\n  \"livedata server - connectionHandle.onClose()\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // On the server side, wait for the connection to be closed.\n        serverConn.onClose(function () {\n          test.isTrue(true);\n          // Add a new onClose after the connection is already\n          // closed. See that it fires.\n          serverConn.onClose(function () {\n            onComplete();\n          });\n        });\n        // Close the connection from the client.\n        clientConn.disconnect();\n      },\n      onComplete\n    );\n  }\n);\n\nTinytest.addAsync(\n  \"livedata server - connectionHandle.close()\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // Wait for the connection to be closed from the server side.\n        simplePoll(\n          function () {\n            return ! clientConn.status().connected;\n          },\n          onComplete,\n          function () {\n            test.fail(\"timeout waiting for the connection to be closed on the server side\");\n            onComplete();\n          }\n        );\n\n        // Close the connection from the server.\n        serverConn.close();\n      },\n      onComplete\n    );\n  }\n);\n\n\ntestAsyncMulti(\n  \"livedata server - onConnection doesn't get callback after stop.\",\n  [function (test, expect) {\n    var afterStop = false;\n    var expectStop1 = expect();\n    var stopHandle1 = Meteor.onConnection(function (conn) {\n      stopHandle2.stop();\n      stopHandle1.stop();\n      afterStop = true;\n      // yield to the event loop for a moment to see that no other calls\n      // to listener2 are called.\n      Meteor.setTimeout(expectStop1, 10);\n    });\n    var stopHandle2 = Meteor.onConnection(function (conn) {\n      test.isFalse(afterStop);\n    });\n\n    // trigger a connection\n    var expectConnection = expect();\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // Close the connection from the client.\n        clientConn.disconnect();\n        expectConnection();\n      },\n      expectConnection\n    );\n  }]\n);\n\n\nMeteor.methods({\n  livedata_server_test_inner: function () {\n    return this.connection.id;\n  },\n\n  livedata_server_test_outer: function () {\n    return Meteor.call('livedata_server_test_inner');\n  }\n});\n\n\nTinytest.addAsync(\n  \"livedata server - connection in method invocation\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var res = clientConn.call('livedata_server_test_inner');\n        test.equal(res, serverConn.id);\n        clientConn.disconnect();\n        onComplete();\n      },\n      onComplete\n    );\n  }\n);\n\n\nTinytest.addAsync(\n  \"livedata server - connection in nested method invocation\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var res = clientConn.call('livedata_server_test_outer');\n        test.equal(res, serverConn.id);\n        clientConn.disconnect();\n        onComplete();\n      },\n      onComplete\n    );\n  }\n);\n\n\n// connectionId -> callback\nvar onSubscription = {};\n\nMeteor.publish(\"livedata_server_test_sub\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n  if (callback)\n    callback(this);\n  this.stop();\n});\n\n\nTinytest.addAsync(\n  \"livedata server - connection in publish function\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        onSubscription[serverConn.id] = function (subscription) {\n          delete onSubscription[serverConn.id];\n          test.equal(subscription.connection.id, serverConn.id);\n          clientConn.disconnect();\n          onComplete();\n        };\n        clientConn.subscribe(\"livedata_server_test_sub\", serverConn.id);\n      }\n    );\n  }\n);\n\nlet onSubscriptions = {};\n\nMeteor.publish({\n  publicationObject () {\n    let callback = onSubscriptions;\n    if (callback)\n      callback();\n    this.stop();\n  }\n});\n\nMeteor.publish({\n  \"publication_object\": function () {\n    let callback = onSubscriptions;\n    if (callback)\n      callback();\n    this.stop();\n  }\n});\n\nMeteor.publish(\"publication_compatibility\", function () {\n  let callback = onSubscriptions;\n  if (callback)\n    callback();\n  this.stop();\n});\n\nTinytest.addAsync(\n  \"livedata server - publish object\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        let testsLength = 0;\n\n        onSubscriptions = function (subscription) {\n          delete onSubscriptions;\n          clientConn.disconnect();\n          testsLength++;\n          if(testsLength == 3){\n            onComplete();\n          }\n        };\n        clientConn.subscribe(\"publicationObject\");\n        clientConn.subscribe(\"publication_object\");\n        clientConn.subscribe(\"publication_compatibility\");\n      }\n    );\n  }\n);\n\nMeteor.methods({\n  testResolvedPromise(arg) {\n    const invocation1 = DDP._CurrentInvocation.get();\n    return new Promise.resolve(arg).then(result => {\n      const invocation2 = DDP._CurrentInvocation.get();\n      // This equality holds because Promise callbacks are bound to the\n      // dynamic environment where .then was called.\n      if (invocation1 !== invocation2) {\n        throw new Meteor.Error(\"invocation mismatch\");\n      }\n      return result + \" after waiting\";\n    });\n  },\n\n  testRejectedPromise(arg) {\n    return new Promise.resolve(arg).then(result => {\n      throw new Meteor.Error(result + \" raised Meteor.Error\");\n    });\n  }\n});\n\nTinytest.addAsync(\n  \"livedata server - waiting for Promise\",\n  (test, onComplete) => makeTestConnection(test, (clientConn, serverConn) => {\n    test.equal(\n      clientConn.call(\"testResolvedPromise\", \"clientConn.call\"),\n      \"clientConn.call after waiting\"\n    );\n\n    const clientCallPromise = new Promise(\n      (resolve, reject) => clientConn.call(\n        \"testResolvedPromise\",\n        \"clientConn.call with callback\",\n        (error, result) => error ? reject(error) : resolve(result)\n      )\n    );\n\n    const clientCallRejectedPromise = new Promise(resolve => {\n      clientConn.call(\n        \"testRejectedPromise\",\n        \"with callback\",\n        (error, result) => resolve(error.message)\n      );\n    });\n\n    Promise.all([\n      clientCallPromise,\n      clientCallRejectedPromise,\n    ]).then(results => test.equal(results, [\n      \"clientConn.call with callback after waiting\",\n      \"[with callback raised Meteor.Error]\",\n    ]), error => test.fail(error))\n      .then(onComplete);\n  })\n);\n"]},"hash":"70a4ef80997c0c98a76549264ddef5de84021501"}
