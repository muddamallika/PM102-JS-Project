{"metadata":{"usedHelpers":["typeof","classCallCheck"],"marked":[],"modules":{"imports":[],"exports":{"exported":["listen","shellDir","disable","shellDir"],"specifiers":[{"kind":"local","local":"listen","exported":"listen"},{"kind":"local","local":"shellDir","exported":"shellDir"},{"kind":"local","local":"disable","exported":"disable"},{"kind":"local","local":"shellDir","exported":"shellDir"}]}}},"options":{"filename":"/packages/shell-server/shell-server.js","filenameRelative":"/packages/shell-server/shell-server.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/shell-server/shell-server.js.map","sourceFileName":"/packages/shell-server/shell-server.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"shell-server"},"ignored":false,"code":"module.export({listen:function(){return listen},disable:function(){return disable}});var _classCallCheck;module.import(\"babel-runtime/helpers/classCallCheck\",{\"default\":function(v){_classCallCheck=v}});var _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});\n\nvar assert = require(\"assert\");\nvar path = require(\"path\");\nvar stream = require(\"stream\");\nvar fs = require(\"fs\");\nvar net = require(\"net\");\nvar tty = require(\"tty\");\nvar vm = require(\"vm\");\nvar _ = require(\"underscore\");\nvar INFO_FILE_MODE = parseInt(\"600\", 8); // Only the owner can read or write.\nvar EXITING_MESSAGE = \"Shell exiting...\";\n\n// Invoked by the server process to listen for incoming connections from\n// shell clients. Each connection gets its own REPL instance.\nfunction listen(shellDir) {\n  function callback() {\n    new Server(shellDir).listen();\n  }\n\n  // If the server is still in the very early stages of starting up,\n  // Meteor.startup may not available yet.\n  if ((typeof Meteor === \"undefined\" ? \"undefined\" : _typeof(Meteor)) === \"object\") {\n    Meteor.startup(callback);\n  } else if ((typeof __meteor_bootstrap__ === \"undefined\" ? \"undefined\" : _typeof(__meteor_bootstrap__)) === \"object\") {\n    var hooks = __meteor_bootstrap__.startupHooks;\n    if (hooks) {\n      hooks.push(callback);\n    } else {\n      // As a fallback, just call the callback asynchronously.\n      setImmediate(callback);\n    }\n  }\n}\n\n// Disabling the shell causes all attached clients to disconnect and exit.\nfunction disable(shellDir) {\n  try {\n    // Replace info.json with a file that says the shell server is\n    // disabled, so that any connected shell clients will fail to\n    // reconnect after the server process closes their sockets.\n    fs.writeFileSync(getInfoFile(shellDir), JSON.stringify({\n      status: \"disabled\",\n      reason: \"Shell server has shut down.\"\n    }) + \"\\n\", { mode: INFO_FILE_MODE });\n  } catch (ignored) {}\n}\n\nvar Server = function () {\n  function Server(shellDir) {\n    _classCallCheck(this, Server);\n\n    var self = this;\n    assert.ok(self instanceof Server);\n\n    self.shellDir = shellDir;\n    self.key = Math.random().toString(36).slice(2);\n\n    self.server = net.createServer(function (socket) {\n      self.onConnection(socket);\n    }).on(\"error\", function (err) {\n      console.error(err.stack);\n    });\n  }\n\n  Server.prototype.listen = function () {\n    function listen() {\n      var self = this;\n      var infoFile = getInfoFile(self.shellDir);\n\n      fs.unlink(infoFile, function () {\n        self.server.listen(0, \"127.0.0.1\", function () {\n          fs.writeFileSync(infoFile, JSON.stringify({\n            status: \"enabled\",\n            port: self.server.address().port,\n            key: self.key\n          }) + \"\\n\", {\n            mode: INFO_FILE_MODE\n          });\n        });\n      });\n    }\n\n    return listen;\n  }();\n\n  Server.prototype.onConnection = function () {\n    function onConnection(socket) {\n      var self = this;\n\n      // Make sure this function doesn't try to write anything to the socket\n      // after it has been closed.\n      socket.on(\"close\", function () {\n        socket = null;\n      });\n\n      // If communication is not established within 1000ms of the first\n      // connection, forcibly close the socket.\n      var timeout = setTimeout(function () {\n        if (socket) {\n          socket.removeAllListeners(\"data\");\n          socket.end(EXITING_MESSAGE + \"\\n\");\n        }\n      }, 1000);\n\n      // Let connecting clients configure certain REPL options by sending a\n      // JSON object over the socket. For example, only the client knows\n      // whether it's running a TTY or an Emacs subshell or some other kind of\n      // terminal, so the client must decide the value of options.terminal.\n      readJSONFromStream(socket, function (error, options, replInputSocket) {\n        clearTimeout(timeout);\n\n        if (error) {\n          socket = null;\n          console.error(error.stack);\n          return;\n        }\n\n        if (options.key !== self.key) {\n          if (socket) {\n            socket.end(EXITING_MESSAGE + \"\\n\");\n          }\n          return;\n        }\n        delete options.key;\n\n        if (options.evaluateAndExit) {\n          evalCommand.call(Object.create(null), // Dummy repl object without ._RecoverableError.\n          \"(\" + options.evaluateAndExit.command + \")\", null, // evalCommand ignores the context parameter, anyway\n          options.evaluateAndExit.filename || \"<meteor shell>\", function (error, result) {\n            if (socket) {\n              var message = error ? {\n                error: error + \"\",\n                code: 1\n              } : {\n                result: result\n              };\n\n              // Sending back a JSON payload allows the client to\n              // distinguish between errors and successful results.\n              socket.end(JSON.stringify(message) + \"\\n\");\n            }\n          });\n          return;\n        }\n        delete options.evaluateAndExit;\n\n        // Immutable options.\n        _.extend(options, {\n          input: replInputSocket,\n          output: socket\n        });\n\n        // Overridable options.\n        _.defaults(options, {\n          prompt: \"> \",\n          terminal: true,\n          useColors: true,\n          useGlobal: true,\n          ignoreUndefined: true\n        });\n\n        self.startREPL(options);\n      });\n    }\n\n    return onConnection;\n  }();\n\n  Server.prototype.startREPL = function () {\n    function startREPL(options) {\n      var self = this;\n\n      if (!options.output.columns) {\n        // The REPL's tab completion logic assumes process.stdout is a TTY,\n        // and while that isn't technically true here, we can get tab\n        // completion to behave correctly if we fake the .columns property.\n        options.output.columns = getTerminalWidth();\n      }\n\n      // Make sure this function doesn't try to write anything to the output\n      // stream after it has been closed.\n      options.output.on(\"close\", function () {\n        options.output = null;\n      });\n\n      var repl = self.repl = require(\"repl\").start(options);\n\n      // History persists across shell sessions!\n      self.initializeHistory();\n\n      // Save the global `_` object in the server.  This is probably defined by the\n      // underscore package.  It is unlikely to be the same object as the `var _ =\n      // require('underscore')` in this file!\n      var originalUnderscore = repl.context._;\n\n      Object.defineProperty(repl.context, \"_\", {\n        // Force the global _ variable to remain bound to underscore.\n        get: function () {\n          function get() {\n            return originalUnderscore;\n          }\n\n          return get;\n        }(),\n\n        // Expose the last REPL result as __ instead of _.\n        set: function () {\n          function set(lastResult) {\n            repl.context.__ = lastResult;\n          }\n\n          return set;\n        }(),\n\n        enumerable: true,\n\n        // Allow this property to be (re)defined more than once (e.g. each\n        // time the server restarts).\n        configurable: true\n      });\n\n      if (Package.modules) {\n        // Use the same `require` function and `module` object visible to the\n        // application.\n        var toBeInstalled = {};\n        var shellModuleName = \"meteor-shell-\" + Math.random().toString(36).slice(2) + \".js\";\n\n        toBeInstalled[shellModuleName] = function (require, exports, module) {\n          repl.context.module = module;\n          repl.context.require = require;\n\n          // Tab completion sometimes uses require.extensions, but only for\n          // the keys.\n          require.extensions = {\n            \".js\": true,\n            \".json\": true,\n            \".node\": true\n          };\n        };\n\n        // This populates repl.context.{module,require} by evaluating the\n        // module defined above.\n        Package.modules.meteorInstall(toBeInstalled)(\"./\" + shellModuleName);\n      }\n\n      repl.context.repl = repl;\n\n      // Some improvements to the existing help messages.\n      function addHelp(cmd, helpText) {\n        var info = repl.commands[cmd] || repl.commands[\".\" + cmd];\n        if (info) {\n          info.help = helpText;\n        }\n      }\n      addHelp(\"break\", \"Terminate current command input and display new prompt\");\n      addHelp(\"exit\", \"Disconnect from server and leave shell\");\n      addHelp(\"help\", \"Show this help information\");\n\n      // When the REPL exits, signal the attached client to exit by sending it\n      // the special EXITING_MESSAGE.\n      repl.on(\"exit\", function () {\n        if (options.output) {\n          options.output.write(EXITING_MESSAGE + \"\\n\");\n          options.output.end();\n        }\n      });\n\n      // When the server process exits, end the output stream but do not\n      // signal the attached client to exit.\n      process.on(\"exit\", function () {\n        if (options.output) {\n          options.output.end();\n        }\n      });\n\n      // This Meteor-specific shell command rebuilds the application as if a\n      // change was made to server code.\n      repl.defineCommand(\"reload\", {\n        help: \"Restart the server and the shell\",\n        action: function () {\n          function action() {\n            process.exit(0);\n          }\n\n          return action;\n        }()\n      });\n\n      // Trigger one recoverable error using the default eval function, just\n      // to capture the Recoverable error constructor, so that our custom\n      // evalCommand function can wrap recoverable errors properly.\n      repl.eval(\"{\", null, \"<meteor shell>\", function (error) {\n        // Capture the Recoverable error constructor.\n        repl._RecoverableError = error && error.constructor;\n\n        // Now set repl.eval to the actual evalCommand function that we want\n        // to use, bound to repl._domain if necessary.\n        repl.eval = repl._domain ? repl._domain.bind(evalCommand) : evalCommand;\n\n        // Terminate the partial evaluation of the { command.\n        repl.commands[\"break\"].action.call(repl);\n      });\n    }\n\n    return startREPL;\n  }();\n\n  // This function allows a persistent history of shell commands to be saved\n  // to and loaded from .meteor/local/shell-history.\n\n\n  Server.prototype.initializeHistory = function () {\n    function initializeHistory() {\n      var self = this;\n      var rli = self.repl.rli;\n      var historyFile = getHistoryFile(self.shellDir);\n      var historyFd = fs.openSync(historyFile, \"a+\");\n      var historyLines = fs.readFileSync(historyFile, \"utf8\").split(\"\\n\");\n      var seenLines = Object.create(null);\n\n      if (!rli.history) {\n        rli.history = [];\n        rli.historyIndex = -1;\n      }\n\n      while (rli.history && historyLines.length > 0) {\n        var line = historyLines.pop();\n        if (line && /\\S/.test(line) && !seenLines[line]) {\n          rli.history.push(line);\n          seenLines[line] = true;\n        }\n      }\n\n      rli.addListener(\"line\", function (line) {\n        if (historyFd >= 0 && /\\S/.test(line)) {\n          fs.writeSync(historyFd, line + \"\\n\");\n        }\n      });\n\n      self.repl.on(\"exit\", function () {\n        fs.closeSync(historyFd);\n        historyFd = -1;\n      });\n    }\n\n    return initializeHistory;\n  }();\n\n  return Server;\n}();\n\nfunction readJSONFromStream(inputStream, callback) {\n  var outputStream = new stream.PassThrough();\n  var dataSoFar = \"\";\n\n  function onData(buffer) {\n    var lines = buffer.toString(\"utf8\").split(\"\\n\");\n\n    while (lines.length > 0) {\n      dataSoFar += lines.shift();\n\n      try {\n        var json = JSON.parse(dataSoFar);\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          continue;\n        }\n\n        return finish(error);\n      }\n\n      if (lines.length > 0) {\n        outputStream.write(lines.join(\"\\n\"));\n      }\n\n      inputStream.pipe(outputStream);\n\n      return finish(null, json);\n    }\n  }\n\n  function onClose() {\n    finish(new Error(\"stream unexpectedly closed\"));\n  }\n\n  var finished = false;\n  function finish(error, json) {\n    if (!finished) {\n      finished = true;\n      inputStream.removeListener(\"data\", onData);\n      inputStream.removeListener(\"error\", finish);\n      inputStream.removeListener(\"close\", onClose);\n      callback(error, json, outputStream);\n    }\n  }\n\n  inputStream.on(\"data\", onData);\n  inputStream.on(\"error\", finish);\n  inputStream.on(\"close\", onClose);\n}\n\nfunction getInfoFile(shellDir) {\n  return path.join(shellDir, \"info.json\");\n}\n\nfunction getHistoryFile(shellDir) {\n  return path.join(shellDir, \"history\");\n}\n\nfunction getTerminalWidth() {\n  try {\n    // Inspired by https://github.com/TooTallNate/ttys/blob/master/index.js\n    var fd = fs.openSync(\"/dev/tty\", \"r\");\n    assert.ok(tty.isatty(fd));\n    var ws = new tty.WriteStream(fd);\n    ws.end();\n    return ws.columns;\n  } catch (fancyApproachWasTooFancy) {\n    return 80;\n  }\n}\n\n// Shell commands need to be executed in a Fiber in case they call into\n// code that yields. Using a Promise is an even better idea, since it runs\n// its callbacks in Fibers drawn from a pool, so the Fibers are recycled.\nvar evalCommandPromise = Promise.resolve();\n\nfunction evalCommand(command, context, filename, callback) {\n  var repl = this;\n\n  function finish(error, result) {\n    if (error) {\n      if (repl._RecoverableError && isRecoverableError(error, repl)) {\n        callback(new repl._RecoverableError(error));\n      } else {\n        callback(error);\n      }\n    } else {\n      callback(null, result);\n    }\n  }\n\n  if (Package.ecmascript) {\n    var noParens = stripParens(command);\n    if (noParens !== command) {\n      var classMatch = /^\\s*class\\s+(\\w+)/.exec(noParens);\n      if (classMatch && classMatch[1] !== \"extends\") {\n        // If the command looks like a named ES2015 class, we remove the\n        // extra layer of parentheses added by the REPL so that the\n        // command will be evaluated as a class declaration rather than as\n        // a named class expression. Note that you can still type (class A\n        // {}) explicitly to evaluate a named class expression. The REPL\n        // code that calls evalCommand handles named function expressions\n        // similarly (first with and then without parentheses), but that\n        // code doesn't know about ES2015 classes, which is why we have to\n        // handle them here.\n        command = noParens;\n      }\n    }\n\n    try {\n      command = Package.ecmascript.ECMAScript.compileForShell(command);\n    } catch (error) {\n      finish(error);\n      return;\n    }\n  }\n\n  try {\n    var script = new vm.Script(command, {\n      filename: filename,\n      displayErrors: false\n    });\n  } catch (parseError) {\n    finish(parseError);\n    return;\n  }\n\n  evalCommandPromise.then(function () {\n    finish(null, script.runInThisContext());\n  })[\"catch\"](finish);\n}\n\nfunction stripParens(command) {\n  if (command.charAt(0) === \"(\" && command.charAt(command.length - 1) === \")\") {\n    return command.slice(1, command.length - 1);\n  }\n  return command;\n}\n\n// The bailOnIllegalToken and isRecoverableError functions are taken from\n// https://github.com/nodejs/node/blob/c9e670ea2a/lib/repl.js#L1227-L1253\nfunction bailOnIllegalToken(parser) {\n  return parser._literal === null && !parser.blockComment && !parser.regExpLiteral;\n}\n\n// If the error is that we've unexpectedly ended the input,\n// then let the user try to recover by adding more input.\nfunction isRecoverableError(e, repl) {\n  if (e && e.name === 'SyntaxError') {\n    var message = e.message;\n    if (message === 'Unterminated template literal' || message === 'Missing } in template expression') {\n      repl._inTemplateLiteral = true;\n      return true;\n    }\n\n    if (message.startsWith('Unexpected end of input') || message.startsWith('missing ) after argument list') || message.startsWith('Unexpected token')) {\n      return true;\n    }\n\n    if (message === 'Invalid or unexpected token') {\n      return !bailOnIllegalToken(repl.lineParser);\n    }\n  }\n\n  return false;\n}","ast":null,"map":{"version":3,"sources":["/packages/shell-server/shell-server.js"],"names":["assert","require","path","stream","fs","net","tty","vm","_","INFO_FILE_MODE","parseInt","EXITING_MESSAGE","listen","shellDir","callback","Server","Meteor","startup","__meteor_bootstrap__","hooks","startupHooks","push","setImmediate","disable","writeFileSync","getInfoFile","JSON","stringify","status","reason","mode","ignored","self","ok","key","Math","random","toString","slice","server","createServer","socket","onConnection","on","err","console","error","stack","infoFile","unlink","port","address","timeout","setTimeout","removeAllListeners","end","readJSONFromStream","options","replInputSocket","clearTimeout","evaluateAndExit","evalCommand","call","Object","create","command","filename","result","message","code","extend","input","output","defaults","prompt","terminal","useColors","useGlobal","ignoreUndefined","startREPL","columns","getTerminalWidth","repl","start","initializeHistory","originalUnderscore","context","defineProperty","get","set","lastResult","__","enumerable","configurable","Package","modules","toBeInstalled","shellModuleName","exports","module","extensions","meteorInstall","addHelp","cmd","helpText","info","commands","help","write","process","defineCommand","action","exit","eval","_RecoverableError","constructor","_domain","bind","rli","historyFile","getHistoryFile","historyFd","openSync","historyLines","readFileSync","split","seenLines","history","historyIndex","length","line","pop","test","addListener","writeSync","closeSync","inputStream","outputStream","PassThrough","dataSoFar","onData","buffer","lines","shift","json","parse","SyntaxError","finish","join","pipe","onClose","Error","finished","removeListener","fd","isatty","ws","WriteStream","fancyApproachWasTooFancy","evalCommandPromise","Promise","resolve","isRecoverableError","ecmascript","noParens","stripParens","classMatch","exec","ECMAScript","compileForShell","script","Script","displayErrors","parseError","then","runInThisContext","charAt","bailOnIllegalToken","parser","_literal","blockComment","regExpLiteral","e","name","_inTemplateLiteral","startsWith","lineParser"],"mappings":"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","file":"/packages/shell-server/shell-server.js.map","sourcesContent":["var assert = require(\"assert\");\nvar path = require(\"path\");\nvar stream = require(\"stream\");\nvar fs = require(\"fs\");\nvar net = require(\"net\");\nvar tty = require(\"tty\");\nvar vm = require(\"vm\");\nvar _ = require(\"underscore\");\nvar INFO_FILE_MODE = parseInt(\"600\", 8); // Only the owner can read or write.\nvar EXITING_MESSAGE = \"Shell exiting...\";\n\n// Invoked by the server process to listen for incoming connections from\n// shell clients. Each connection gets its own REPL instance.\nexport function listen(shellDir) {\n  function callback() {\n    new Server(shellDir).listen();\n  }\n\n  // If the server is still in the very early stages of starting up,\n  // Meteor.startup may not available yet.\n  if (typeof Meteor === \"object\") {\n    Meteor.startup(callback);\n  } else if (typeof __meteor_bootstrap__ === \"object\") {\n    var hooks = __meteor_bootstrap__.startupHooks;\n    if (hooks) {\n      hooks.push(callback);\n    } else {\n      // As a fallback, just call the callback asynchronously.\n      setImmediate(callback);\n    }\n  }\n}\n\n// Disabling the shell causes all attached clients to disconnect and exit.\nexport function disable(shellDir) {\n  try {\n    // Replace info.json with a file that says the shell server is\n    // disabled, so that any connected shell clients will fail to\n    // reconnect after the server process closes their sockets.\n    fs.writeFileSync(\n      getInfoFile(shellDir),\n      JSON.stringify({\n        status: \"disabled\",\n        reason: \"Shell server has shut down.\"\n      }) + \"\\n\",\n      { mode: INFO_FILE_MODE }\n    );\n  } catch (ignored) {}\n}\n\nclass Server {\n  constructor(shellDir) {\n    var self = this;\n    assert.ok(self instanceof Server);\n\n    self.shellDir = shellDir;\n    self.key = Math.random().toString(36).slice(2);\n\n    self.server = net.createServer(function(socket) {\n      self.onConnection(socket);\n    }).on(\"error\", function(err) {\n      console.error(err.stack);\n    });\n  }\n\n  listen() {\n    var self = this;\n    var infoFile = getInfoFile(self.shellDir);\n\n    fs.unlink(infoFile, function() {\n      self.server.listen(0, \"127.0.0.1\", function() {\n        fs.writeFileSync(infoFile, JSON.stringify({\n          status: \"enabled\",\n          port: self.server.address().port,\n          key: self.key\n        }) + \"\\n\", {\n          mode: INFO_FILE_MODE\n        });\n      });\n    });\n  }\n\n  onConnection(socket) {\n    var self = this;\n\n    // Make sure this function doesn't try to write anything to the socket\n    // after it has been closed.\n    socket.on(\"close\", function() {\n      socket = null;\n    });\n\n    // If communication is not established within 1000ms of the first\n    // connection, forcibly close the socket.\n    var timeout = setTimeout(function() {\n      if (socket) {\n        socket.removeAllListeners(\"data\");\n        socket.end(EXITING_MESSAGE + \"\\n\");\n      }\n    }, 1000);\n\n    // Let connecting clients configure certain REPL options by sending a\n    // JSON object over the socket. For example, only the client knows\n    // whether it's running a TTY or an Emacs subshell or some other kind of\n    // terminal, so the client must decide the value of options.terminal.\n    readJSONFromStream(socket, function (error, options, replInputSocket) {\n      clearTimeout(timeout);\n\n      if (error) {\n        socket = null;\n        console.error(error.stack);\n        return;\n      }\n\n      if (options.key !== self.key) {\n        if (socket) {\n          socket.end(EXITING_MESSAGE + \"\\n\");\n        }\n        return;\n      }\n      delete options.key;\n\n      if (options.evaluateAndExit) {\n        evalCommand.call(\n          Object.create(null), // Dummy repl object without ._RecoverableError.\n          \"(\" + options.evaluateAndExit.command + \")\",\n          null, // evalCommand ignores the context parameter, anyway\n          options.evaluateAndExit.filename || \"<meteor shell>\",\n          function (error, result) {\n            if (socket) {\n              var message = error ? {\n                error: error + \"\",\n                code: 1\n              } : {\n                result: result\n              };\n\n              // Sending back a JSON payload allows the client to\n              // distinguish between errors and successful results.\n              socket.end(JSON.stringify(message) + \"\\n\");\n            }\n          }\n        );\n        return;\n      }\n      delete options.evaluateAndExit;\n\n      // Immutable options.\n      _.extend(options, {\n        input: replInputSocket,\n        output: socket\n      });\n\n      // Overridable options.\n      _.defaults(options, {\n        prompt: \"> \",\n        terminal: true,\n        useColors: true,\n        useGlobal: true,\n        ignoreUndefined: true,\n      });\n\n      self.startREPL(options);\n    });\n  }\n\n  startREPL(options) {\n    var self = this;\n\n    if (! options.output.columns) {\n      // The REPL's tab completion logic assumes process.stdout is a TTY,\n      // and while that isn't technically true here, we can get tab\n      // completion to behave correctly if we fake the .columns property.\n      options.output.columns = getTerminalWidth();\n    }\n\n    // Make sure this function doesn't try to write anything to the output\n    // stream after it has been closed.\n    options.output.on(\"close\", function() {\n      options.output = null;\n    });\n\n    var repl = self.repl = require(\"repl\").start(options);\n\n    // History persists across shell sessions!\n    self.initializeHistory();\n\n    // Save the global `_` object in the server.  This is probably defined by the\n    // underscore package.  It is unlikely to be the same object as the `var _ =\n    // require('underscore')` in this file!\n    var originalUnderscore = repl.context._;\n\n    Object.defineProperty(repl.context, \"_\", {\n      // Force the global _ variable to remain bound to underscore.\n      get: function () { return originalUnderscore; },\n\n      // Expose the last REPL result as __ instead of _.\n      set: function(lastResult) {\n        repl.context.__ = lastResult;\n      },\n\n      enumerable: true,\n\n      // Allow this property to be (re)defined more than once (e.g. each\n      // time the server restarts).\n      configurable: true\n    });\n\n    if (Package.modules) {\n      // Use the same `require` function and `module` object visible to the\n      // application.\n      var toBeInstalled = {};\n      var shellModuleName = \"meteor-shell-\" +\n        Math.random().toString(36).slice(2) + \".js\";\n\n      toBeInstalled[shellModuleName] = function (require, exports, module) {\n        repl.context.module = module;\n        repl.context.require = require;\n\n        // Tab completion sometimes uses require.extensions, but only for\n        // the keys.\n        require.extensions = {\n          \".js\": true,\n          \".json\": true,\n          \".node\": true,\n        };\n      };\n\n      // This populates repl.context.{module,require} by evaluating the\n      // module defined above.\n      Package.modules.meteorInstall(toBeInstalled)(\"./\" + shellModuleName);\n    }\n\n    repl.context.repl = repl;\n\n    // Some improvements to the existing help messages.\n    function addHelp(cmd, helpText) {\n      var info = repl.commands[cmd] || repl.commands[\".\" + cmd];\n      if (info) {\n        info.help = helpText;\n      }\n    }\n    addHelp(\"break\", \"Terminate current command input and display new prompt\");\n    addHelp(\"exit\", \"Disconnect from server and leave shell\");\n    addHelp(\"help\", \"Show this help information\");\n\n    // When the REPL exits, signal the attached client to exit by sending it\n    // the special EXITING_MESSAGE.\n    repl.on(\"exit\", function() {\n      if (options.output) {\n        options.output.write(EXITING_MESSAGE + \"\\n\");\n        options.output.end();\n      }\n    });\n\n    // When the server process exits, end the output stream but do not\n    // signal the attached client to exit.\n    process.on(\"exit\", function() {\n      if (options.output) {\n        options.output.end();\n      }\n    });\n\n    // This Meteor-specific shell command rebuilds the application as if a\n    // change was made to server code.\n    repl.defineCommand(\"reload\", {\n      help: \"Restart the server and the shell\",\n      action: function() {\n        process.exit(0);\n      }\n    });\n\n    // Trigger one recoverable error using the default eval function, just\n    // to capture the Recoverable error constructor, so that our custom\n    // evalCommand function can wrap recoverable errors properly.\n    repl.eval(\n      \"{\", null, \"<meteor shell>\",\n      function (error) {\n        // Capture the Recoverable error constructor.\n        repl._RecoverableError = error && error.constructor;\n\n        // Now set repl.eval to the actual evalCommand function that we want\n        // to use, bound to repl._domain if necessary.\n        repl.eval = repl._domain\n          ? repl._domain.bind(evalCommand)\n          : evalCommand;\n\n        // Terminate the partial evaluation of the { command.\n        repl.commands[\"break\"].action.call(repl);\n      }\n    );\n  }\n\n  // This function allows a persistent history of shell commands to be saved\n  // to and loaded from .meteor/local/shell-history.\n  initializeHistory() {\n    var self = this;\n    var rli = self.repl.rli;\n    var historyFile = getHistoryFile(self.shellDir);\n    var historyFd = fs.openSync(historyFile, \"a+\");\n    var historyLines = fs.readFileSync(historyFile, \"utf8\").split(\"\\n\");\n    var seenLines = Object.create(null);\n\n    if (! rli.history) {\n      rli.history = [];\n      rli.historyIndex = -1;\n    }\n\n    while (rli.history && historyLines.length > 0) {\n      var line = historyLines.pop();\n      if (line && /\\S/.test(line) && ! seenLines[line]) {\n        rli.history.push(line);\n        seenLines[line] = true;\n      }\n    }\n\n    rli.addListener(\"line\", function(line) {\n      if (historyFd >= 0 && /\\S/.test(line)) {\n        fs.writeSync(historyFd, line + \"\\n\");\n      }\n    });\n\n    self.repl.on(\"exit\", function() {\n      fs.closeSync(historyFd);\n      historyFd = -1;\n    });\n  }\n}\n\nfunction readJSONFromStream(inputStream, callback) {\n  var outputStream = new stream.PassThrough;\n  var dataSoFar = \"\";\n\n  function onData(buffer) {\n    var lines = buffer.toString(\"utf8\").split(\"\\n\");\n\n    while (lines.length > 0) {\n      dataSoFar += lines.shift();\n\n      try {\n        var json = JSON.parse(dataSoFar);\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          continue;\n        }\n\n        return finish(error);\n      }\n\n      if (lines.length > 0) {\n        outputStream.write(lines.join(\"\\n\"));\n      }\n\n      inputStream.pipe(outputStream);\n\n      return finish(null, json);\n    }\n  }\n\n  function onClose() {\n    finish(new Error(\"stream unexpectedly closed\"));\n  }\n\n  var finished = false;\n  function finish(error, json) {\n    if (! finished) {\n      finished = true;\n      inputStream.removeListener(\"data\", onData);\n      inputStream.removeListener(\"error\", finish);\n      inputStream.removeListener(\"close\", onClose);\n      callback(error, json, outputStream);\n    }\n  }\n\n  inputStream.on(\"data\", onData);\n  inputStream.on(\"error\", finish);\n  inputStream.on(\"close\", onClose);\n}\n\nfunction getInfoFile(shellDir) {\n  return path.join(shellDir, \"info.json\");\n}\n\nfunction getHistoryFile(shellDir) {\n  return path.join(shellDir, \"history\");\n}\n\nfunction getTerminalWidth() {\n  try {\n    // Inspired by https://github.com/TooTallNate/ttys/blob/master/index.js\n    var fd = fs.openSync(\"/dev/tty\", \"r\");\n    assert.ok(tty.isatty(fd));\n    var ws = new tty.WriteStream(fd);\n    ws.end();\n    return ws.columns;\n  } catch (fancyApproachWasTooFancy) {\n    return 80;\n  }\n}\n\n// Shell commands need to be executed in a Fiber in case they call into\n// code that yields. Using a Promise is an even better idea, since it runs\n// its callbacks in Fibers drawn from a pool, so the Fibers are recycled.\nvar evalCommandPromise = Promise.resolve();\n\nfunction evalCommand(command, context, filename, callback) {\n  var repl = this;\n\n  function finish(error, result) {\n    if (error) {\n      if (repl._RecoverableError &&\n          isRecoverableError(error, repl)) {\n        callback(new repl._RecoverableError(error));\n      } else {\n        callback(error);\n      }\n    } else {\n      callback(null, result);\n    }\n  }\n\n  if (Package.ecmascript) {\n    var noParens = stripParens(command);\n    if (noParens !== command) {\n      var classMatch = /^\\s*class\\s+(\\w+)/.exec(noParens);\n      if (classMatch && classMatch[1] !== \"extends\") {\n        // If the command looks like a named ES2015 class, we remove the\n        // extra layer of parentheses added by the REPL so that the\n        // command will be evaluated as a class declaration rather than as\n        // a named class expression. Note that you can still type (class A\n        // {}) explicitly to evaluate a named class expression. The REPL\n        // code that calls evalCommand handles named function expressions\n        // similarly (first with and then without parentheses), but that\n        // code doesn't know about ES2015 classes, which is why we have to\n        // handle them here.\n        command = noParens;\n      }\n    }\n\n    try {\n      command = Package.ecmascript.ECMAScript.compileForShell(command);\n    } catch (error) {\n      finish(error);\n      return;\n    }\n  }\n\n  try {\n    var script = new vm.Script(command, {\n      filename: filename,\n      displayErrors: false\n    });\n  } catch (parseError) {\n    finish(parseError);\n    return;\n  }\n\n  evalCommandPromise.then(function () {\n    finish(null, script.runInThisContext());\n  }).catch(finish);\n}\n\nfunction stripParens(command) {\n  if (command.charAt(0) === \"(\" &&\n      command.charAt(command.length - 1) === \")\") {\n    return command.slice(1, command.length - 1);\n  }\n  return command;\n}\n\n// The bailOnIllegalToken and isRecoverableError functions are taken from\n// https://github.com/nodejs/node/blob/c9e670ea2a/lib/repl.js#L1227-L1253\nfunction bailOnIllegalToken(parser) {\n  return parser._literal === null &&\n    ! parser.blockComment &&\n    ! parser.regExpLiteral;\n}\n\n// If the error is that we've unexpectedly ended the input,\n// then let the user try to recover by adding more input.\nfunction isRecoverableError(e, repl) {\n  if (e && e.name === 'SyntaxError') {\n    var message = e.message;\n    if (message === 'Unterminated template literal' ||\n        message === 'Missing } in template expression') {\n      repl._inTemplateLiteral = true;\n      return true;\n    }\n\n    if (message.startsWith('Unexpected end of input') ||\n        message.startsWith('missing ) after argument list') ||\n        message.startsWith('Unexpected token')) {\n      return true;\n    }\n\n    if (message === 'Invalid or unexpected token') {\n      return ! bailOnIllegalToken(repl.lineParser);\n    }\n  }\n\n  return false;\n}\n"]},"hash":"5d316476bbf32231be17918c908587af8dfcd3a4"}
